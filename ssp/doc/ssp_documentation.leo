<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="20" left="20" height="580" width="896"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ntallen.20080228100701" a="E"><vh>SSP Documentation</vh>
<v t="ntallen.20080228100842"><vh>IIP Development Notes</vh>
<v t="ntallen.20080228100842.1"><vh>Design Issues</vh>
<v t="ntallen.20080228100842.2"><vh>Multiple Clocks</vh></v>
<v t="ntallen.20080228100842.3"><vh>Implement Coadd and N Channels</vh></v>
<v t="ntallen.20080228100842.4"><vh>Back to benchmarks</vh></v>
<v t="ntallen.20080228100842.5" a="E"><vh>Data Transfer Strategies</vh>
<v t="ntallen.20080228100842.6"><vh>V1</vh></v>
<v t="ntallen.20080228100842.7"><vh>V2</vh></v>
<v t="ntallen.20080228100842.8"><vh>V3</vh></v>
</v>
</v>
<v t="ntallen.20080228100842.9"><vh>Knowledge Base</vh>
<v t="ntallen.20080228100842.10"><vh>Software Versions</vh>
<v t="ntallen.20080228100842.11"><vh>LwIP</vh></v>
<v t="ntallen.20080228100842.12"><vh>Cygwin compatability</vh></v>
</v>
<v t="ntallen.20080228100842.13"><vh>Do we need to have different pcores for different FPGA targets?</vh></v>
<v t="ntallen.20080228100842.14"><vh>Xilkernel timer bug</vh></v>
</v>
<v t="ntallen.20080228100842.15"><vh>Document clearly what we need to build this app</vh>
<v t="ntallen.20080228100842.14"><vh>Xilkernel timer bug</vh></v>
<v t="ntallen.20080228100842.16"><vh>Sysgen Pcore Creation</vh>
<v t="ntallen.20080228100842.13"><vh>Do we need to have different pcores for different FPGA targets?</vh></v>
<v t="ntallen.20080228100842.17" a="E"><vh>Things to do after generation</vh>
<v t="ntallen.20080228100842.18"><vh>Edit .mpd to mark interrupt</vh></v>
<v t="ntallen.20080228100842.19"><vh>Edit .tcl to workaround bug</vh></v>
<v t="ntallen.20080228100842.20"><vh>Edit src files to fix ArrayRead prototype</vh></v>
</v>
</v>
<v t="ntallen.20080228100842.21"><vh>HW Components</vh>
<v t="ntallen.20080228100842.22"><vh>CPU: Microblaze</vh></v>
<v t="ntallen.20080228100842.23"><vh>opb_spi</vh></v>
<v t="ntallen.20080228100842.24"><vh>Ethernet</vh></v>
<v t="ntallen.20080228100842.25"><vh>opb_timer</vh></v>
<v t="ntallen.20080228100842.26"><vh>scan_ctrl pcore</vh></v>
<v t="ntallen.20080228100842.27"><vh>arp_ssp pcore</vh></v>
<v t="ntallen.20080228100842.28"><vh>ssp_ad_scan</vh></v>
<v t="ntallen.20080228100842.29"><vh>opb_intc</vh></v>
<v t="ntallen.20080228100842.30"><vh>UCF</vh></v>
</v>
<v t="ntallen.20080228100842.31" a="E"><vh>SW Components</vh>
<v t="ntallen.20080228100842.32"><vh>xilkernel</vh></v>
<v t="ntallen.20080228100842.33"><vh>LwIP</vh></v>
</v>
<v t="ntallen.20080228100842.34"><vh>Remote Driver</vh>
<v t="ntallen.20080228100842.35"><vh>Incoming Messages</vh>
<v t="ntallen.20080228100842.36"><vh>Commands</vh></v>
<v t="ntallen.20080228100842.37"><vh>Status Requests</vh></v>
<v t="ntallen.20080228100842.38"><vh>TCP responses</vh></v>
<v t="ntallen.20080228100842.39"><vh>UDP data</vh></v>
</v>
</v>
<v t="ntallen.20080228100842.40" a="E"><vh>Revisions</vh>
<v t="ntallen.20080228100842.41" a="E"><vh>XPS</vh>
<v t="ntallen.20080228100842.42" a="E"><vh>SSP_Proto_c3</vh>
<v t="ntallen.20080228100842.43"><vh>ssp_ad_scan V2.01b</vh></v>
<v t="ntallen.20080228100842.44"><vh>ssp_ad_preaddr V1.00a</vh></v>
<v t="ntallen.20080228100842.45"><vh>arp_ssp V2.00a</vh></v>
</v>
</v>
<v t="ntallen.20080228100842.46" a="E"><vh>IP</vh>
<v t="ntallen.20080228100842.47" a="E"><vh>ssp_ad_scan</vh>
<v t="ntallen.20080228100842.48"><vh>ssp_ad_scan V2.00a</vh></v>
<v t="ntallen.20080228100842.49"><vh>ssp_ad_scan V2.01a</vh></v>
<v t="ntallen.20080228100842.43"><vh>ssp_ad_scan V2.01b</vh></v>
<v t="ntallen.20080228100842.50" a="E"><vh>ssp_ad_scan V2.02a</vh>
<v t="ntallen.20080228100842.51"><vh>Scan Logic</vh></v>
</v>
</v>
<v t="ntallen.20080228100842.52" a="E"><vh>ssp_ad_preaddr</vh>
<v t="ntallen.20080228100842.44"><vh>ssp_ad_preaddr V1.00a</vh></v>
<v t="ntallen.20080228100842.53"><vh>ssp_ad_preaddr V1.00b</vh></v>
<v t="ntallen.20080228100842.54"><vh>ssp_ad_preaddr V2.00a</vh></v>
</v>
<v t="ntallen.20080228100842.55" a="E"><vh>arp_ssp</vh>
<v t="ntallen.20080228100842.56"><vh>arp_ssp V1.00a</vh></v>
<v t="ntallen.20080228100842.45"><vh>arp_ssp V2.00a</vh></v>
</v>
</v>
</v>
</v>
<v t="ntallen.20080228100842.57"><vh>LwIP</vh>
<v t="ntallen.20080228100842.58"><vh>Debugging</vh>
<v t="ntallen.20080228100842.59"><vh>sys_arch.c</vh></v>
<v t="ntallen.20080228100842.60"><vh>xadapter.c</vh>
<v t="ntallen.20080228100842.61"><vh>The Problem</vh></v>
</v>
<v t="ntallen.20080228100842.62"><vh>netif/xemacif.h</vh></v>
<v t="ntallen.20080228100842.63"><vh>netif/xemacliteif.c</vh></v>
<v t="ntallen.20080228100842.64"><vh>Reply to Siva</vh></v>
</v>
</v>
</v>
<v t="ntallen.20080228133017" a="E"><vh>Documentation</vh>
<v t="ntallen.20080228133017.1" a="E"><vh>Circuits</vh>
<v t="ntallen.20080228133017.2" a="E"><vh>SSP Prototype V2.2</vh>
<v t="ntallen.20080228133017.3" a="M"><vh>arp_ssp V3.0</vh></v>
<v t="ntallen.20080228133017.4"><vh>ssp_trigger V1.0</vh></v>
<v t="ntallen.20080228133017.5" a="ETV"><vh>ssp_ad_preaddr V2.00a</vh>
<v t="ntallen.20080228140103"><vh>Handshaking</vh></v>
<v t="ntallen.20080229125358" a="E"><vh>Rework Again?</vh>
<v t="ntallen.20080229125358.1"><vh>dual-clock FIFO</vh></v>
</v>
</v>
<v t="ntallen.20080228133017.6" a="E"><vh>ssp_ad_scan V???</vh>
<v t="ntallen.20080229125358.2"><vh>DStat</vh></v>
<v t="ntallen.20080229125358.3"><vh>SampleCount</vh></v>
</v>
</v>
</v>
<v t="ntallen.20080228133017.7"><vh>Software</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ntallen.20080228100701">@nocolor</t>
<t tx="ntallen.20080228100842"></t>
<t tx="ntallen.20080228100842.1"></t>
<t tx="ntallen.20080228100842.2">The Multiple Subsystem bocks in Sysgen die catastrophically. How do we work around that?</t>
<t tx="ntallen.20080228100842.3"></t>
<t tx="ntallen.20080228100842.4">Things to look into:
    cache
    barrel shifter
    hardware multiply
    hardware checksums
    TEMAC vs EthernetLite
    Raw vs Sockets
</t>
<t tx="ntallen.20080228100842.5"></t>
<t tx="ntallen.20080228100842.6">HW: Don't start writing a scan unless the whole scan will fit in the FIFO
SW: Dont' start reading a scan until EOS interrupt</t>
<t tx="ntallen.20080228100842.7">HW: Still use a FIFO. Assume SW can keep up with the data transfer. If not, fail and require a reset to restart
SW: Transfer data whenever a sufficient amount is ready</t>
<t tx="ntallen.20080228100842.8">Figure out whether a real shared-memory approach exists with PLB. If so, keep the whole UDP packet in the shared memory and transfer when ready.</t>
<t tx="ntallen.20080228100842.9"></t>
<t tx="ntallen.20080228100842.10">12/04/2007:
    ISE 9.2i SP3
      Virtex4 QPro Devices for ISE 9.2.03i
      ISE 9.2i IP Update 2 (May be incompatible with Sysgen 9.2 SP1)
    EDK 9.2i SP1
    Matlab 7.3 R2006b (still)
    DSP_Tools 9.2.01.1028 (Includes Sysgen and AccelDSP)
    cygwin make 3.79.1
    cygwin bash: see below
      
Before:
    ISE 9.1i SP3
    EDK 9.1i SP2
    Matlab 7.3 R2006b
    Sysgen 9.1.01

</t>
<t tx="ntallen.20080228100842.11">LwIP v3.00.a apparently only supports ethernetlite
Having some trouble getting through GenLib, Oh, looks like I've gotta use the new ethernet cores.
And I've gotta rewrite the TCP/IP stuff to use RAW
</t>
<t tx="ntallen.20080228100842.12">I'm running latest cygwin, but EDK wants a few things that are older:
  bash: I believe the current bash will work fine if you set the variables:
      XILINX_EDK_DISABLE_CYGWIN_CHECK=1
      SHELLOPTS=igncr
    but for the moment I have copied in their bash to see if that helps
    No, it doesn't. Copied the new one back and reset the environment variables
  make: They want make version 3.79.1, which I have copied in from the EDK distro.
</t>
<t tx="ntallen.20080228100842.13">It would appear the answer is no. I generated two versions of the scan_ctrl model, one targeted at xc4vlx25-10ff668 (ML401) and the other at xc4vsx35-10ff668 (ML402), then compared the generated directory structure. The only differences were direct references to the version name.

In 9.2 (at least) the .mpd lists multiple architectures as supported

</t>
<t tx="ntallen.20080228100842.14">Examine C:\EDK\sw\lib\bsp\xilkernel_v3_00_a\src\src\sys\timer.c
to make sure remove_tmr() function does not decrement nactive.</t>
<t tx="ntallen.20080228100842.15"></t>
<t tx="ntallen.20080228100842.16"></t>
<t tx="ntallen.20080228100842.17"></t>
<t tx="ntallen.20080228100842.18">Any interrupt ports need to have the attributes 'SIGIS' and 'SENSITIVITY' added:
    
PORT scanintr = "", DIR = O
PORT scanintr = "", DIR = O, SIGIS = INTERRUPT, SENSITIVITY = EDGE_RISING
</t>
<t tx="ntallen.20080228100842.19">in 'proc generate', the last 'expand_Template' invocation fails when running libgen from inside the SDK. This line can either be commented out or modified to get an explicit path.</t>
<t tx="ntallen.20080228100842.20">As written, the prototype for _ArrayRead functions lists the buffer pointer as int **buf, which is one '*' too many. It works that way, but it's wrong, and it generates warnings in the compiler.</t>
<t tx="ntallen.20080228100842.21"></t>
<t tx="ntallen.20080228100842.22">Configure IP
  Instructions
    Enable Barrel Shifter     [] (definitely want to try this!)
    Enable Integer Multiplier     [Mul32]
    Enable Integer Divider    [] (and this!)
    Enable Cache              [] (helps a great deal)
  Debug
    Enable MicroBlaze Debug Module Interface [x]
    Number of PC Breakpoints                  8 (increase from 2)
</t>
<t tx="ntallen.20080228100842.23">Configure IP
  Number of Off-chip slave select devices      [1]
  Total number of slave select bits            [1]
  Support Interrupt                            [x]

Don't forget to connect to OPB

Connect ports:
    SCK
    MISO
    MOSI
    SS
    IP2INTC_Irpt =&gt; opt_intc


XPS SPI has slightly different options
  Number of Off-chip slave select devices is a checkbox, not a number
  There is no "Support Interrupt" option</t>
<t tx="ntallen.20080228100842.24">Configure IP
  Should consider enabling CSUM of TX Side, but need to figure out whether the LwIP software supports it and whether it improves performance.
  NO DMA [LwIP does not support it]

XPS Ethernet Lite
  Not many options, but enable an extra transmit buffer
  </t>
<t tx="ntallen.20080228100842.25">Only one timer present                [x]
</t>
<t tx="ntallen.20080228100842.26">Earlier version
Connect all ports.
  ce =&gt; net_vcc
  clk =&gt; sys_clk_s
  scanintr =&gt; opb_intc
  data and data_valid mapped to arp_ssp pcore
  OTHERS external</t>
<t tx="ntallen.20080228100842.27">Make _P and _N signals external
</t>
<t tx="ntallen.20080228100842.28">Connect the ports
 PORT clk = sys_clk_s
 PORT ce = net_vcc
 PORT data_in = SSP_Data (from arp_ssp)
 PORT data_valid = SSP_Data_Valid (from arp_ssp)
 PORT trigger = SSP_Trigger (Make External)
 PORT scanintr = SSP_ScanIntr connect to intc
</t>
<t tx="ntallen.20080228100842.29">Make sure all the interrupts are connected</t>
<t tx="ntallen.20080228100842.30"></t>
<t tx="ntallen.20080228100842.31"></t>
<t tx="ntallen.20080228100842.32">sysintc_spec [opb_intc] [xps_intc]
stdin        [debug_module] [RS232 Uart]
stdout       [debug_module] [RS232 Uart]
systmr_dev   [opb_timer_1] [xps_timer_1]
pthread_stacksize [8000]
static_pthread_table: [main_main,2] [priority needs to be greater than 1 with LwIP v3]
config_pthread_mutex [true]
max_pthreads  [10] (still, may need to increase later)

sched_type   [SCHED_PRIO]

config_sema  [true]
  max        [40] (up from 10)
config_time  [true]

enhanced features [true]
  config yield    [true]   Until LwIP is rewritten to use semaphore
</t>
<t tx="ntallen.20080228100842.33">EMAC:  0:0xA:0x35:55:55:55 (change low order bits for uniqueness)
Checksum offload only for UDP TX (check to see if implemented)
api_mode [SOCKETS_API]

Don't forget to copy over development libraries


xps_ethernetlite may require second transmit buffer
</t>
<t tx="ntallen.20080228100842.34">This is the component that talks to the SSP over ethernet. It sends commands via TCP and receives gobs of scan data via UDP. As a proper driver, it needs to provide an API of some sort for providing control and access to the data. No doubt I will want to stick close to the 'High Speed A/D Interface'.</t>
<t tx="ntallen.20080228100842.35"></t>
<t tx="ntallen.20080228100842.36">Commands are implemented as reads from the command hierarchy.
What about status requests?
</t>
<t tx="ntallen.20080228100842.37">Suppose we only support report of CPCI number and basic status (Ready/Armed/Trigger/Gone)
What exactly is the collection interface?</t>
<t tx="ntallen.20080228100842.38"></t>
<t tx="ntallen.20080228100842.39"></t>
<t tx="ntallen.20080228100842.40"></t>
<t tx="ntallen.20080228100842.41"></t>
<t tx="ntallen.20080228100842.42">EDK 9.2i
Introducing ssp_ad_preaddr 1.00a
ssp_ad_scan 2.01a which supports pre adder
arp_ssp 2.00a which includes DATA_VALID_INV for pre adder
xps_spi which was used in SSP_Proto_c2

Software will use patches worked out for SSP_Proto_c2:
    fix to xps_ethernetlite driver
    fix to LwIP emacliteif.c
    hack to LwIP etharp.c
Need to support Sample Rate, NAvg</t>
<t tx="ntallen.20080228100842.43">Addition of pre-adder circuit
Demonstration of use of separate clock domains
</t>
<t tx="ntallen.20080228100842.44"></t>
<t tx="ntallen.20080228100842.45">Added DATA_VALID_INV for clocking the pre adder.</t>
<t tx="ntallen.20080228100842.46"></t>
<t tx="ntallen.20080228100842.47">Added support for ssp_ad_preaddr 1.00a
</t>
<t tx="ntallen.20080228100842.48"></t>
<t tx="ntallen.20080228100842.49"></t>
<t tx="ntallen.20080228100842.50">Addition of coadd circuitry and new pre adder interface
</t>
<t tx="ntallen.20080228100842.51">Processing of individual scans occurs independent of the enable input. When a trigger is detected, the BOS signal is asserted, the scan number is incremented, and write enables will begin. The enable input helps decide whether or not to begin a new coadd sequence, but once a coadd sequence is begun, it runs to completion unless interrupted by a reset.

Once we begin a coadd sequence, we continue accepting scans at least until the coadd sequence is complete. That means that the enable control line is only referenced If we need to throttle, that would be the right time to do it (from a data analysis standpoint) From a data processing standpoint, we can't really make the decision until we're just about ready to accept the last scan, but that's not a good time to discard scans</t>
<t tx="ntallen.20080228100842.52"></t>
<t tx="ntallen.20080228100842.53"></t>
<t tx="ntallen.20080228100842.54">Implement new simpler handshaking protocol for output, allowing clock rate to approach CPU clock rate.

The pre adder enable input is controlled from ssp_ad_scan</t>
<t tx="ntallen.20080228100842.55"></t>
<t tx="ntallen.20080228100842.56"></t>
<t tx="ntallen.20080228100842.57"></t>
<t tx="ntallen.20080228100842.58"></t>
<t tx="ntallen.20080228100842.59">src/contrib/ports/xilinx/sys_arch.c
  sys_mbox_post()
    249-252: Wasted statements
    Overflow is not detected

  sys_thread_new()
    358: In the case of no free threads, function returns an undefined pointer</t>
<t tx="ntallen.20080228100842.60">xemacif_input_thread() needs to be started in lwip_sock_init()--actually later, after the interface has been initialized. As written, if it starts, it runs in a busy loop polling for new input in the pq. In Socket mode, there should be a semaphore associated with the pq.

In LwIP v2.00 raw mode with interrupts, the interface input function is called as a handler when the interface interrupt signals an incoming packet. The interface input function reads the packet and passes it directly on to the higher level packet processing functions, which ultimately call the user functions.

In LwIP v3.00, the recv handler reads in the packet and enqueues it in both socket and raw modes, and there is no provision for dequeuing. My guess is that in raw mode, the recv handler should invoke the higher-level functions directly as in v2.00. In socket mode, the packets should be enqueued and a semaphore posted.
</t>
<t tx="ntallen.20080228100842.61">Chad, While I have not actually tried to run a program, I don't believe Sockets support is in fact functional. There are a lot of the pieces in place, but not everything is connected.

Specifically, on receipt of a packet:

    * Interrupt handler gets called: XEmacLite_InterruptHandler()
          o calls xemacif_recv_handler()
                + calls XEmacLite_Recv() to read the packet
                + then calls pq_enqueue(recv_q) to enqueue the packet

So where is the packet processed?

    * pq_dequeue(recv_q) is called from:
    * low_level_input() which is called from:
    * xemacliteif_input() which is called from:
    * xemacif_input() which is called from
    * xemacif_input_thread() which is not called or referenced anywhere else in the library

In v2, the corresponding input_thread function was started up in a separate thread during lwip_init(). That seems to be missing here (and who knows what else.)
</t>
<t tx="ntallen.20080228100842.62">Apparently a totally useless file.
Inclusion generates syntax errors.
</t>
<t tx="ntallen.20080228100842.63">low_level_output():
    Apparently XEmacLite_TxBufferAvailable() is returning TRUE but _unbuffered_low_level_output() is failing on second fragment.
</t>
<t tx="ntallen.20080228100842.64">Siva,

Here's what I found today:
    As is, your patch did not work. I tracked it down to the original line in transmit_packet() where over-long packets were truncated. I had previously pushed the truncation out to 1514 bytes, and you went ahead and removed the line entirely, but apparently it is still required, because without it, I can't connect.
    I set a breakpoint there to see who was sending packets larger than 1514, and it turns out we get a 1518-byte packet for an ARP response (from etharp.c) This is because they reuse the inbound packet, and it has the raw max packet length from the driver (since--if I am not mistaken--the driver really can't know how long the packet is) I'm going to try adding:
    p-&gt;len = p-&gt;tot_len = sizeof(struct etharp_hdr);
    </t>
<t tx="ntallen.20080228133017"></t>
<t tx="ntallen.20080228133017.1"></t>
<t tx="ntallen.20080228133017.2">Location: D:\Data\Xilinx\sysgen\SSP\ssp_proto\V2_2

This design implements the circuitry for three channels of high-speed A/D conversion. It is intended for the SSP Prototype board (single channel) and also the SSP board (3 channels). The implementation within Xilinx's EDK is accomplished using four main components (at least)
    arp_ssp: hand-coded VHDL to implement LVDS interfaces
    ssp_trigger: to handle triggering
    ssp_ad_preaddr: to handle A/D interface and time-based filtering
    ssp_ad_scan: to handle scan processing, coadding and connection to the processor

An overall system diagram will be created that describes the interconnection</t>
<t tx="ntallen.20080228133017.3">This block needs to be entered into CVS

arp_ssp implements the LVDS input buffers for the A/D data and clock. It takes P,N pairs as input and outputs buffered signals. It also provides both true and inverted outputs for the clock to facilitate synchronization.

The A/D clock goes high at the same time the data is updated, so the data should be latched on the falling edge of the clock. Hence the ssp_ad_preaddr block will be driven by the inverted signal clock. On the other hand, we need to synchronize signals coming from ssp_ad_scan, which runs off the processor's clock. There are three ssp_ad_preaddrs, and each has it's own clock. These should be very closely matched, and in theory we can use the 9510 to tweak out any phase differences, but in practice, it's possible that there will be some slight difference between the clocks. In order to reliably synchronize signals from ssp_ad_scan and from the external trigger, we will have the ssp_trigger block use the non-inverted signal clock from one of the A/D channels.</t>
<t tx="ntallen.20080228133017.4">This block handles trigger configuration and synchronization. The clock input for this block should be connected to the non-inverted data clock from one of the three A/D converters. They should all be approximately in phase, so it should not matter which one your choose.

Inputs:
    TrigConfig: A 4-bit control vector including:
        0-1: Trigger source index
        2: Trigger_Rising
        3: Auto Trigger Enable
    TrigLvl[0:3]
    TrigArm_In

Outputs:
    Trigger
    TrigArm_Out

The trigger source index indicates which one of the four TrigLvl inputs will be monitored. TrigLvl0, 1 and 2 will be connected to TrigLvl_Greater outputs from the three ssp_ad_preaddr blocks which are boolean outputs that indicate that the input is greater than the specified trigger level. TrigLvl3 will be connected to the external trigger, which is how we expect to use this circuit in production.

If the Trigger_Rising control bit is asserted, a transition of the indicated input from zero to one will produce a trigger pulse on the output. If Trigger_Rising is not asserted, a transition from one to zero will produce the trigger pulse.

The TrigArm_Out is just TrigArm_In synchronized to the rising edge of the input clock. It does not interact with the trigger signals at all; that is handled in the pre adder where the Arm also serves to reset the adders.</t>
<t tx="ntallen.20080228133017.5">The pre-adder reads in the raw signal from the A/D converter and optionally adds a pre-configured number of samples before passing the data on to the scan processing unit. It also performs level-comparison for level-sensitive triggering.

In the complete design, there will be three of these pre-adders: one for each A/D converter. The clock input to each pre-adder should be connected to the inverted data clock from its associated A/D converter.

Inputs:
    Signal: The 16-bit A/D data from the arp_ssp block
    TrigLevel: 16-bit configuration value from the scan processor for level-sensitive triggering.
    NAvg: 8-bit configuration value. Pre-adder will add NAvg+1 samples before reporting.
    Reset: Boolean control signal from scan processor. Resets all states and counters. The signal must be synchronized to the rising edge of a sample clock via the triggering block.
    RE[0:2]: Read enable vector (one-hot)
    Trigger: Synchronized boolean signal from triggering block.
        
Outputs:
    Signal_Out: The 24-bit pre-added signal to the scan processor
    Empty: Boolean signal true when there is no data on the outputs
    Reset_Ack: True when the circuit has been reset. Will go low when a trigger is accepted
    OVF: Boolean overflow status indication to the scan processor
    LvlGreater: Boolean output to the triggering block indicating current Signal value is greater than the TrigLevel
    
On Reset, all counters and states are reset. No data will be accepted until a Trigger is observed. After the Trigger is observed, data is shifted out via a FIFO. The circuit must be reset after each scan.

When the scan processor determines that the scan is complete, it will raise the Reset signal. After the Reset_Ack is observed, the scan processor will remove the Reset to arm the circuit for the next trigger.</t>
<t tx="ntallen.20080228133017.6"></t>
<t tx="ntallen.20080228133017.7"></t>
<t tx="ntallen.20080228140103">Obsolete: Inadequate

On Reset, DStat_Out (in ssp_ad_preaddr) and DStat_Ack (in ssp_ad_scan) are set to zero. When a new data value is ready to be shipped from the pre-adder to the scan processor, it is latched into Signal_Out and the DStat_Out value is toggled.

In the scan processor, the exclusive-or of DStat_Out and DStat_Ack is monitored. When it is true, that indicates new data is ready. When the new data is clocked into the scan processor, DStat_Ack is toggled to match DStat_Out.

In the pre-adder, if DStat_Ack is not equal to DStat_Out when new data is ready, that is an overflow condition, and the OVF bit is set. This bit is cleared at the end of each scan, but it can be monitored by the scan processor and reported back to the processor.

There are still synchronization issues. I want to make sure I have adequate setup times for the enables that I'm driving off the xor gates. If DStat_Out goes directly to the scan processor, I will need to add a delay or risk unpredictable behavior. The cost of the delay is reducing the maximum data rate from the pre adder to one half the cpu clock rate or less. The alternative is to route all the DStat_Out lines through an outside module to synchronize them to the falling edge of sys_clk</t>
<t tx="ntallen.20080229125358">I'm having trouble with end-of-scan because I haven't worked out a reset handshake. Since the arm circuit is synchronized with the sample clock, we don't have a way of knowing when the pre add circuit is properly reset, and hence whether the incoming sample is the result of a trigger or a stray sample from the previous scan.

I think I would like to see:
    pre-adder controlled by a single reset line. When asserted, the circuit is in reset. When cleared, it is ready for a trigger. Obviously clearing the reset must be synchronized, but setting it could be asynchronous.
    Better FIFO implementation to allow higher throughput.</t>
<t tx="ntallen.20080229125358.1">FIFO holds N samples, where N is most likely greater than 1</t>
<t tx="ntallen.20080229125358.2">The DStat block handles the handshaking. Data must be ready from all enabled channels before the transfer is acknowledged.

The reset input resets the DStat_Ack output to zero. It should be asserted on either system reset or the Arm condition.

The DV0 output will drive the enable on the register which will hold the incoming data. As such, it is one clock in advance of a proper data valid signal.

As discussed in the Handshaking node, the current implementation is not optimal. An implementation with a more robust sort of FIFO could probably increase throughput.</t>
<t tx="ntallen.20080229125358.3">This block is responsible for individual scan processing. Internally, it will maintain the states</t>
</tnodes>
</leo_file>
