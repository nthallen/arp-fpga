<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ntallen.20100702124409.1475"><vh>@chapters</vh></v>
<v t="ntallen.20080228100701" a="E"><vh>SSP Documentation</vh>
<v t="ntallen.20080228100842" a="E"><vh>IIP Development Notes</vh>
<v t="ntallen.20080228100842.1"><vh>Design Issues</vh>
<v t="ntallen.20080228100842.2"><vh>Multiple Clocks</vh></v>
<v t="ntallen.20080228100842.3"><vh>Implement Coadd and N Channels</vh>
<v t="ntallen.20080311125846"><vh>Remaining Work</vh></v>
<v t="ntallen.20080313122934"><vh>Using StateCAD with Sysgen</vh></v>
</v>
<v t="ntallen.20080228100842.4"><vh>Back to benchmarks</vh></v>
<v t="ntallen.20080228100842.5"><vh>Data Transfer Strategies</vh>
<v t="ntallen.20080228100842.6"><vh>V1</vh></v>
<v t="ntallen.20080228100842.7"><vh>V2</vh>
<v t="ntallen.20080311125846.1"><vh>V2a</vh></v>
</v>
<v t="ntallen.20080228100842.8"><vh>V3</vh></v>
</v>
<v t="ntallen.20081031104332"><vh>Network Configuration</vh>
<v t="ntallen.20081031104332.1"><vh>Configuration Contents</vh></v>
<v t="ntallen.20081031104332.2"><vh>Configuration Initialization Strategy</vh>
<v t="ntallen.20081031104332.3"><vh>FPGA Configuration Tool Operation</vh></v>
<v t="ntallen.20081118114833"><vh>TCP for web</vh></v>
</v>
</v>
</v>
<v t="ntallen.20080228100842.9"><vh>Knowledge Base</vh>
<v t="ntallen.20080228100842.10"><vh>Software Versions</vh>
<v t="ntallen.20080228100842.11"><vh>LwIP</vh></v>
<v t="ntallen.20080228100842.12"><vh>Cygwin compatability</vh></v>
</v>
<v t="ntallen.20080228100842.13"><vh>Do we need to have different pcores for different FPGA targets?</vh></v>
<v t="ntallen.20080228100842.14"><vh>Xilkernel timer bug</vh></v>
</v>
<v t="ntallen.20080228100842.15"><vh>Document clearly what we need to build this app</vh>
<v t="ntallen.20080228100842.14"></v>
<v t="ntallen.20080502115342"><vh>System ACE File Generation</vh></v>
<v t="ntallen.20080228100842.16"><vh>Sysgen Pcore Creation</vh>
<v t="ntallen.20080228100842.13"></v>
<v t="ntallen.20080228100842.17"><vh>Things to do after generation</vh>
<v t="ntallen.20080228100842.18"><vh>Edit .mpd to mark interrupt</vh></v>
<v t="ntallen.20080228100842.19"><vh>Edit .tcl to workaround bug</vh></v>
<v t="ntallen.20080228100842.20"><vh>Edit src files to fix ArrayRead prototype</vh></v>
</v>
</v>
<v t="ntallen.20080228100842.21"><vh>HW Components</vh>
<v t="ntallen.20080228100842.22"><vh>CPU: Microblaze</vh></v>
<v t="ntallen.20080228100842.23"><vh>xps_spi</vh></v>
<v t="ntallen.20080228100842.24"><vh>Ethernet</vh></v>
<v t="ntallen.20080228100842.25"><vh>opb_timer</vh></v>
<v t="ntallen.20080228100842.26"><vh>scan_ctrl pcore</vh></v>
<v t="ntallen.20080228100842.27"><vh>arp_ssp pcore</vh></v>
<v t="ntallen.20080228100842.28"><vh>ssp_ad_scan</vh></v>
<v t="ntallen.20080228100842.29"><vh>opb_intc</vh></v>
<v t="ntallen.20081029142547"><vh>xps_iic</vh></v>
<v t="ntallen.20080228100842.30"><vh>UCF</vh></v>
</v>
<v t="ntallen.20080228100842.31"><vh>SW Components</vh>
<v t="ntallen.20080228100842.32"><vh>xilkernel</vh></v>
<v t="ntallen.20080228100842.33"><vh>LwIP</vh></v>
<v t="ntallen.20080512113736"><vh>Libraries</vh></v>
</v>
<v t="ntallen.20080228100842.34"><vh>Remote Driver</vh>
<v t="ntallen.20080228100842.35"><vh>Incoming Messages</vh>
<v t="ntallen.20080228100842.36"><vh>Commands</vh></v>
<v t="ntallen.20080228100842.37"><vh>Status Requests</vh></v>
<v t="ntallen.20080228100842.38"><vh>TCP responses</vh></v>
<v t="ntallen.20080228100842.39"><vh>UDP data</vh></v>
</v>
</v>
<v t="ntallen.20080228100842.40"><vh>Revisions</vh>
<v t="ntallen.20080228100842.41"><vh>XPS</vh>
<v t="ntallen.20080228100842.42"><vh>SSP_Proto_c3</vh>
<v t="ntallen.20080228100842.43"><vh>ssp_ad_scan V2.01b</vh></v>
<v t="ntallen.20080228100842.44"><vh>ssp_ad_preaddr V1.00a</vh></v>
<v t="ntallen.20080228100842.45" a="M"><vh>arp_ssp V2.00a</vh></v>
</v>
<v t="ntallen.20080717103941"><vh>SSP_Proto_402</vh></v>
<v t="ntallen.20080930104722"><vh>SSP_V1 (ML401)</vh>
<v t="ntallen.20080228133017.4"><vh>ssp_trigger V1.0a</vh></v>
<v t="ntallen.20080930104722.1" a="M"><vh>arp_ssp V2.00c</vh></v>
<v t="ntallen.20080403140406"><vh>ssp_ad_preaddr V2.00b</vh>
<v t="ntallen.20080403140406.1"><vh>dual-clock FIFO</vh></v>
<v t="ntallen.20080403140406.2"><vh>Handshaking</vh></v>
<v t="ntallen.20080403140406.3"><vh>Handshaking - old plan</vh></v>
<v t="ntallen.20080403140406.4"><vh>Rework Again?</vh></v>
</v>
<v t="ntallen.20080228133017.6"><vh>ssp_ad_scan V3.00b</vh>
<v t="ntallen.20080229125358.2"><vh>DStat</vh></v>
<v t="ntallen.20080229125358.3"><vh>SampleCount</vh></v>
<v t="ntallen.20080305130648"><vh>CoaddCount</vh></v>
<v t="ntallen.20080305165613"><vh>ShiftOut Logic</vh></v>
</v>
</v>
<v t="ntallen.20080930110102"><vh>SSP_V1a (SSP)</vh>
<v t="ntallen.20080930104722.1" a="M"></v>
<v t="ntallen.20080403140406"></v>
<v t="ntallen.20080228133017.4"></v>
<v t="ntallen.20080228133017.6"></v>
</v>
<v t="ntallen.20080930110904"><vh>SSP_V1p (ML401)</vh>
<v t="ntallen.20080930110904.1"><vh>SSP_PMT_Input</vh></v>
<v t="ntallen.20080930104722.1" a="M"></v>
<v t="ntallen.20080403140406"></v>
<v t="ntallen.20080228133017.4"></v>
<v t="ntallen.20080228133017.6"></v>
</v>
<v t="ntallen.20081031104332.4"><vh>SSP_Devel(SSP)</vh></v>
</v>
<v t="ntallen.20080228100842.46"><vh>IP</vh>
<v t="ntallen.20080228100842.47"><vh>ssp_ad_scan</vh>
<v t="ntallen.20080228100842.48"><vh>ssp_ad_scan V2.00a</vh></v>
<v t="ntallen.20080228100842.49"><vh>ssp_ad_scan V2.01a</vh></v>
<v t="ntallen.20080228100842.43"></v>
<v t="ntallen.20080228100842.50"><vh>ssp_ad_scan V2.02a</vh>
<v t="ntallen.20080228100842.51"><vh>Scan Logic</vh></v>
</v>
<v t="ntallen.20080228133017.6"></v>
</v>
<v t="ntallen.20080228100842.52"><vh>ssp_ad_preaddr</vh>
<v t="ntallen.20080228100842.44"></v>
<v t="ntallen.20080228100842.53"><vh>ssp_ad_preaddr V1.00b</vh></v>
<v t="ntallen.20080228133017.5"><vh>ssp_ad_preaddr V2.00a</vh>
<v t="ntallen.20080229125358.1"><vh>dual-clock FIFO</vh></v>
<v t="ntallen.20080303084933"><vh>Handshaking</vh></v>
<v t="ntallen.20080228140103"><vh>Handshaking - old plan</vh></v>
<v t="ntallen.20080229125358"><vh>Rework Again?</vh></v>
</v>
<v t="ntallen.20080403140406"></v>
</v>
<v t="ntallen.20080228100842.55"><vh>arp_ssp</vh>
<v t="ntallen.20080228100842.56"><vh>arp_ssp V1.00a</vh></v>
<v t="ntallen.20080228100842.45" a="M"></v>
<v t="ntallen.20080930104722.1" a="M"></v>
</v>
<v t="ntallen.20080403141641"><vh>ssp_trigger</vh>
<v t="ntallen.20080228133017.4"></v>
</v>
<v t="ntallen.20080930110904.1"></v>
</v>
</v>
</v>
<v t="ntallen.20080228100842.57"><vh>LwIP</vh>
<v t="ntallen.20080228100842.58"><vh>Debugging</vh>
<v t="ntallen.20080228100842.59"><vh>sys_arch.c</vh></v>
<v t="ntallen.20080228100842.60"><vh>xadapter.c</vh>
<v t="ntallen.20080228100842.61"><vh>The Problem</vh></v>
</v>
<v t="ntallen.20080228100842.62"><vh>netif/xemacif.h</vh></v>
<v t="ntallen.20080228100842.63"><vh>netif/xemacliteif.c</vh></v>
<v t="ntallen.20080228100842.64"><vh>Reply to Siva</vh></v>
</v>
</v>
<v t="ntallen.20080602105139"><vh>Packet Fragmentation Strategy</vh></v>
<v t="ntallen.20080404114126"><vh>Debugging</vh></v>
</v>
<v t="ntallen.20080228133017" a="E"><vh>Documentation</vh>
<v t="ntallen.20080228133017.1"><vh>Circuits</vh>
<v t="ntallen.20080228133017.2"><vh>SSP V1</vh>
<v t="ntallen.20080228100842.45" a="M"></v>
<v t="ntallen.20080228133017.4"></v>
<v t="ntallen.20080228133017.5"></v>
<v t="ntallen.20080228133017.6"></v>
</v>
</v>
<v t="ntallen.20080228133017.7" a="E"><vh>Software</vh>
<v t="ntallen.20081114110138"><vh>SSP_Config</vh>
<v t="ntallen.20081114110138.1"><vh>Threads</vh></v>
</v>
<v t="ntallen.20080331101629"><vh>Server V2.0</vh>
<v t="ntallen.20080331101629.1"><vh>Threads</vh></v>
<v t="ntallen.20080331101629.2"><vh>Commands</vh>
<v t="ntallen.20080331114222"><vh>Inter-thread communication</vh></v>
</v>
<v t="ntallen.20080331131839"><vh>Data</vh></v>
</v>
<v t="ntallen.20080331101629.3" a="E"><vh>Client</vh>
<v t="ntallen.20100702124409.1476" a="E"><vh>cygwin</vh>
<v t="ntallen.20100702124409.1477"><vh>ssp_cmd.exe</vh></v>
<v t="ntallen.20100702124409.1478"><vh>ssp_log.exe</vh></v>
<v t="ntallen.20100702124409.1480"><vh>Matlab: ssp_data.m</vh></v>
</v>
<v t="ntallen.20100702124409.1479"><vh>QNX6</vh></v>
</v>
</v>
</v>
<v t="ntallen.20080617120554" a="E"><vh>To Do</vh>
<v t="ntallen.20080617120554.1"><vh>Read Temperatures</vh></v>
<v t="ntallen.20080617120554.2"><vh>Plug sample rate into header</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ntallen.20080228100701">@nocolor</t>
<t tx="ntallen.20080228100842"></t>
<t tx="ntallen.20080228100842.1"></t>
<t tx="ntallen.20080228100842.10">4/01/2008:
    10.1 is out there....
    
12/04/2007:
    ISE 9.2i SP3
      Virtex4 QPro Devices for ISE 9.2.03i
      ISE 9.2i IP Update 2 (May be incompatible with Sysgen 9.2 SP1)
    EDK 9.2i SP2
    Matlab 7.3 R2006b (still)
    DSP_Tools 9.2.01.1028 (Includes Sysgen and AccelDSP)
    cygwin make 3.79.1
    cygwin bash: see below
      
Before:
    ISE 9.1i SP3
    EDK 9.1i SP2
    Matlab 7.3 R2006b
    Sysgen 9.1.01

</t>
<t tx="ntallen.20080228100842.11">LwIP v3.00.a apparently only supports ethernetlite
Having some trouble getting through GenLib, Oh, looks like I've gotta use the new ethernet cores.
And I've gotta rewrite the TCP/IP stuff to use RAW
</t>
<t tx="ntallen.20080228100842.12">I'm running latest cygwin, but EDK wants a few things that are older:
  bash: I believe the current bash will work fine if you set the variables:
      XILINX_EDK_DISABLE_CYGWIN_CHECK=1
      SHELLOPTS=igncr
    but for the moment I have copied in their bash to see if that helps
    No, it doesn't. Copied the new one back and reset the environment variables
  make: They want make version 3.79.1, which I have copied in from the EDK distro.
</t>
<t tx="ntallen.20080228100842.13">It would appear the answer is no. I generated two versions of the scan_ctrl model, one targeted at xc4vlx25-10ff668 (ML401) and the other at xc4vsx35-10ff668 (ML402), then compared the generated directory structure. The only differences were direct references to the version name.

In 9.2 (at least) the .mpd lists multiple architectures as supported

</t>
<t tx="ntallen.20080228100842.14">Examine C:\EDK\sw\lib\bsp\xilkernel_v3_00_a\src\src\sys\timer.c
to make sure remove_tmr() function does not decrement nactive.</t>
<t tx="ntallen.20080228100842.15"></t>
<t tx="ntallen.20080228100842.16"></t>
<t tx="ntallen.20080228100842.17"></t>
<t tx="ntallen.20080228100842.18">Any interrupt ports need to have the attributes 'SIGIS' and 'SENSITIVITY' added:
    
PORT scanintr = "", DIR = O
PORT scanintr = "", DIR = O, SIGIS = INTERRUPT, SENSITIVITY = EDGE_RISING
</t>
<t tx="ntallen.20080228100842.19">in 'proc generate', the last 'expand_Template' invocation fails when running libgen from inside the SDK. This line can either be commented out or modified to get an explicit path.</t>
<t tx="ntallen.20080228100842.2">The Multiple Subsystem bocks in Sysgen die catastrophically. How do we work around that?
Must make the designs separate and interconnect manually. This is not ideal, since it makes it difficult to use things like FIFOs, but we can deal.</t>
<t tx="ntallen.20080228100842.20">As written, the prototype for _ArrayRead functions lists the buffer pointer as int **buf, which is one '*' too many. It works that way, but it's wrong, and it generates warnings in the compiler.</t>
<t tx="ntallen.20080228100842.21"></t>
<t tx="ntallen.20080228100842.22">Configure IP
  Instructions
    Enable Barrel Shifter     [] (definitely want to try this!)
    Enable Integer Multiplier     [Mul32]
    Enable Integer Divider    [] (and this!)
    Enable Cache              [] (helps a great deal)
  Debug
    Enable MicroBlaze Debug Module Interface [x]
    Number of PC Breakpoints                  8 (increase from 2)
</t>
<t tx="ntallen.20080228100842.23">Configure IP
  Number of Off-chip slave select devices      [1]
  Total number of slave select bits            [1]
  Support Interrupt                            [x]

Don't forget to connect to OPB

Connect ports:
    SCK
    MISO
    MOSI
    SS
    IP2INTC_Irpt =&gt; opt_intc


XPS SPI has slightly different options
  Number of Off-chip slave select devices is a checkbox, not a number
  There is no "Support Interrupt" option</t>
<t tx="ntallen.20080228100842.24">Configure IP
  Should consider enabling CSUM of TX Side, but need to figure out whether the LwIP software supports it and whether it improves performance.
  NO DMA [LwIP does not support it]

XPS Ethernet Lite
  Not many options, but enable an extra transmit buffer
  </t>
<t tx="ntallen.20080228100842.25">Only one timer present                [x]
</t>
<t tx="ntallen.20080228100842.26">Earlier version
Connect all ports.
  ce =&gt; net_vcc
  clk =&gt; sys_clk_s
  scanintr =&gt; opb_intc
  data and data_valid mapped to arp_ssp pcore
  OTHERS external</t>
<t tx="ntallen.20080228100842.27">Make _P and _N signals external
</t>
<t tx="ntallen.20080228100842.28">Connect the ports
 PORT clk = sys_clk_s
 PORT ce = net_vcc
 PORT data_in = SSP_Data (from arp_ssp)
 PORT data_valid = SSP_Data_Valid (from arp_ssp)
 PORT trigger = SSP_Trigger (Make External)
 PORT scanintr = SSP_ScanIntr connect to intc
</t>
<t tx="ntallen.20080228100842.29">Make sure all the interrupts are connected</t>
<t tx="ntallen.20080228100842.3">Full design for 3 channels as documented under SSP V1. Each component required:
    Design
    Simulation
    Export from Sysgen
    Import into XPS

Then the system as a whole required:
    Interconnect in XPS
    Place and Route

Based on P&amp;R results, we can see what size device we're going to need. It looks like the ideal choice will be the XC4VSX35, which has lots of RAM, but we can definitely fit the existing design into the XC4VLS25 which is on the ML401. The additional RAM will allow us to expand the application or simply allow for longer scans at higher resolution.
    </t>
<t tx="ntallen.20080228100842.30"></t>
<t tx="ntallen.20080228100842.31"></t>
<t tx="ntallen.20080228100842.32">sysintc_spec [opb_intc] [xps_intc]
stdin        [debug_module] [RS232 Uart]
stdout       [debug_module] [RS232 Uart]
systmr_dev   [opb_timer_1] [xps_timer_1]
pthread_stacksize [8000]
static_pthread_table: [main_main,2] [priority needs to be greater than 1 with LwIP v3]
config_pthread_mutex [true]
max_pthreads  [10] (still, may need to increase later)

sched_type   [SCHED_PRIO] [SCHED_RR]

config_sema  [true]
  max        [40] (up from 10)
config_time  [true]

enhanced features [true]
  config yield    [true]   Until LwIP is rewritten to use semaphore
</t>
<t tx="ntallen.20080228100842.33">EMAC:  0:0xA:0x35:55:55:55 (change low order bits for uniqueness)
Checksum offload only for UDP TX (check to see if implemented)
api_mode [SOCKETS_API]

Don't forget to copy over development libraries


xps_ethernetlite may require second transmit buffer
</t>
<t tx="ntallen.20080228100842.34">This is the component that talks to the SSP over ethernet. It sends commands via TCP and receives gobs of scan data via UDP. As a proper driver, it needs to provide an API of some sort for providing control and access to the data. No doubt I will want to stick close to the 'High Speed A/D Interface'.</t>
<t tx="ntallen.20080228100842.35"></t>
<t tx="ntallen.20080228100842.36">Commands are implemented as reads from the command hierarchy.
What about status requests?
</t>
<t tx="ntallen.20080228100842.37">Suppose we only support report of CPCI number and basic status (Ready/Armed/Trigger/Gone)
What exactly is the collection interface?</t>
<t tx="ntallen.20080228100842.38"></t>
<t tx="ntallen.20080228100842.39"></t>
<t tx="ntallen.20080228100842.4">Things to look into:
    cache
    barrel shifter
    hardware multiply
    hardware checksums
    TEMAC vs EthernetLite
    Raw vs Sockets
</t>
<t tx="ntallen.20080228100842.40"></t>
<t tx="ntallen.20080228100842.41"></t>
<t tx="ntallen.20080228100842.42">EDK 9.2i
Introducing ssp_ad_preaddr 1.00a
ssp_ad_scan 2.01a which supports pre adder
arp_ssp 2.00a which includes DATA_VALID_INV for pre adder
xps_spi which was used in SSP_Proto_c2

Software will use patches worked out for SSP_Proto_c2:
    fix to xps_ethernetlite driver
    fix to LwIP emacliteif.c
    hack to LwIP etharp.c
Need to support Sample Rate, NAvg</t>
<t tx="ntallen.20080228100842.43">Addition of pre-adder circuit
Demonstration of use of separate clock domains
</t>
<t tx="ntallen.20080228100842.44"></t>
<t tx="ntallen.20080228100842.45">Added DATA_VALID_INV for clocking the pre adder.

This block needs to be entered into CVS
It also needs to be augmented to support the OOR bit from the converter

arp_ssp implements the LVDS input buffers for the A/D data and clock. It takes P,N pairs as input and outputs buffered signals. It also provides both true and inverted outputs for the clock to facilitate synchronization.

The A/D clock goes high at the same time the data is updated, so the data should be latched on the falling edge of the clock. Hence the ssp_ad_preaddr block will be driven by the inverted signal clock. On the other hand, we need to synchronize signals coming from ssp_ad_scan, which runs off the processor's clock. There are three ssp_ad_preaddrs, and each has it's own clock. These should be very closely matched, and in theory we can use the 9510 to tweak out any phase differences, but in practice, it's possible that there will be some slight difference between the clocks. In order to reliably synchronize signals from ssp_ad_scan and from the external trigger, we will have the ssp_trigger block use the non-inverted signal clock from one of the A/D channels.</t>
<t tx="ntallen.20080228100842.46"></t>
<t tx="ntallen.20080228100842.47">Added support for ssp_ad_preaddr 1.00a
</t>
<t tx="ntallen.20080228100842.48"></t>
<t tx="ntallen.20080228100842.49"></t>
<t tx="ntallen.20080228100842.5"></t>
<t tx="ntallen.20080228100842.50">Addition of coadd circuitry and new pre adder interface
</t>
<t tx="ntallen.20080228100842.51">Processing of individual scans occurs independent of the enable input. When a trigger is detected, the BOS signal is asserted, the scan number is incremented, and write enables will begin. The enable input helps decide whether or not to begin a new coadd sequence, but once a coadd sequence is begun, it runs to completion unless interrupted by a reset.

Once we begin a coadd sequence, we continue accepting scans at least until the coadd sequence is complete. That means that the enable control line is only referenced If we need to throttle, that would be the right time to do it (from a data analysis standpoint) From a data processing standpoint, we can't really make the decision until we're just about ready to accept the last scan, but that's not a good time to discard scans</t>
<t tx="ntallen.20080228100842.52"></t>
<t tx="ntallen.20080228100842.53"></t>
<t tx="ntallen.20080228100842.55"></t>
<t tx="ntallen.20080228100842.56"></t>
<t tx="ntallen.20080228100842.57"></t>
<t tx="ntallen.20080228100842.58"></t>
<t tx="ntallen.20080228100842.59">src/contrib/ports/xilinx/sys_arch.c
  sys_mbox_post()
    249-252: Wasted statements
    Overflow is not detected

  sys_thread_new()
    358: In the case of no free threads, function returns an undefined pointer</t>
<t tx="ntallen.20080228100842.6">HW: Don't start writing a scan unless the whole scan will fit in the FIFO
SW: Dont' start reading a scan until EOS interrupt</t>
<t tx="ntallen.20080228100842.60">xemacif_input_thread() needs to be started in lwip_sock_init()--actually later, after the interface has been initialized. As written, if it starts, it runs in a busy loop polling for new input in the pq. In Socket mode, there should be a semaphore associated with the pq.

In LwIP v2.00 raw mode with interrupts, the interface input function is called as a handler when the interface interrupt signals an incoming packet. The interface input function reads the packet and passes it directly on to the higher level packet processing functions, which ultimately call the user functions.

In LwIP v3.00, the recv handler reads in the packet and enqueues it in both socket and raw modes, and there is no provision for dequeuing. My guess is that in raw mode, the recv handler should invoke the higher-level functions directly as in v2.00. In socket mode, the packets should be enqueued and a semaphore posted.
</t>
<t tx="ntallen.20080228100842.61">Chad, While I have not actually tried to run a program, I don't believe Sockets support is in fact functional. There are a lot of the pieces in place, but not everything is connected.

Specifically, on receipt of a packet:

    * Interrupt handler gets called: XEmacLite_InterruptHandler()
          o calls xemacif_recv_handler()
                + calls XEmacLite_Recv() to read the packet
                + then calls pq_enqueue(recv_q) to enqueue the packet

So where is the packet processed?

    * pq_dequeue(recv_q) is called from:
    * low_level_input() which is called from:
    * xemacliteif_input() which is called from:
    * xemacif_input() which is called from
    * xemacif_input_thread() which is not called or referenced anywhere else in the library

In v2, the corresponding input_thread function was started up in a separate thread during lwip_init(). That seems to be missing here (and who knows what else.)
</t>
<t tx="ntallen.20080228100842.62">Apparently a totally useless file.
Inclusion generates syntax errors.
</t>
<t tx="ntallen.20080228100842.63">low_level_output():
    Apparently XEmacLite_TxBufferAvailable() is returning TRUE but _unbuffered_low_level_output() is failing on second fragment.
</t>
<t tx="ntallen.20080228100842.64">Siva,

Here's what I found today:
    As is, your patch did not work. I tracked it down to the original line in transmit_packet() where over-long packets were truncated. I had previously pushed the truncation out to 1514 bytes, and you went ahead and removed the line entirely, but apparently it is still required, because without it, I can't connect.
    I set a breakpoint there to see who was sending packets larger than 1514, and it turns out we get a 1518-byte packet for an ARP response (from etharp.c) This is because they reuse the inbound packet, and it has the raw max packet length from the driver (since--if I am not mistaken--the driver really can't know how long the packet is) I'm going to try adding:
    p-&gt;len = p-&gt;tot_len = sizeof(struct etharp_hdr);
    </t>
<t tx="ntallen.20080228100842.7">HW: Still use a FIFO. Assume SW can keep up with the data transfer. If not, fail and require a reset to restart
SW: Transfer data whenever a sufficient amount is ready</t>
<t tx="ntallen.20080228100842.8">Figure out whether a real shared-memory approach exists with PLB. If so, keep the whole UDP packet in the shared memory and transfer when ready.</t>
<t tx="ntallen.20080228100842.9"></t>
<t tx="ntallen.20080228133017"></t>
<t tx="ntallen.20080228133017.1"></t>
<t tx="ntallen.20080228133017.2">Location: D:\Data\Xilinx\sysgen\SSP\ssp_proto\V2_2

This design implements the circuitry for three channels of high-speed A/D conversion. It is intended for the SSP Prototype board (single channel) and also the SSP board (3 channels). The implementation within Xilinx's EDK is accomplished using four main components (at least)
    arp_ssp: hand-coded VHDL to implement LVDS interfaces
    ssp_trigger: to handle triggering
    ssp_ad_preaddr: to handle A/D interface and time-based filtering
    ssp_ad_scan: to handle scan processing, coadding and connection to the processor

An overall system diagram will be created that describes the interconnection

Tied to software V2_0</t>
<t tx="ntallen.20080228133017.4">This block handles trigger configuration and synchronization. The clock input for this block should be connected to the non-inverted data clock from one of the three A/D converters. They should all be approximately in phase, so it should not matter which one your choose.

Inputs:
    TrigConfig: A 4-bit control vector including:
        0-1: Trigger source index
        2: Trigger_Rising
        3: Auto Trigger Enable
    TrigLvl[0:3]
    TrigReset_In

Outputs:
    Trigger
    TrigReset_Out

The trigger source index indicates which one of the four TrigLvl inputs will be monitored. TrigLvl0, 1 and 2 will be connected to TrigLvl_Greater outputs from the three ssp_ad_preaddr blocks which are boolean outputs that indicate that the input is greater than the specified trigger level. TrigLvl3 will be connected to the external trigger, which is how we expect to use this circuit in production.

If the Trigger_Rising control bit is asserted, a transition of the indicated input from zero to one will produce a trigger pulse on the output. If Trigger_Rising is not asserted, a transition from one to zero will produce the trigger pulse.

The TrigArm_Out is just TrigArm_In synchronized to the rising edge of the input clock. It does not interact with the trigger signals at all; that is handled in the pre adder where the Arm also serves to reset the adders.</t>
<t tx="ntallen.20080228133017.5">The pre-adder reads in the raw signal from the A/D converter and optionally adds a pre-configured number of samples before passing the data on to the scan processing unit. It also performs level-comparison for level-sensitive triggering.

In the complete design, there will be three of these pre-adders: one for each A/D converter. The clock input to each pre-adder should be connected to the inverted data clock from its associated A/D converter.

Inputs:
    Signal: The 16-bit A/D data from the arp_ssp block
    TrigLevel: 16-bit configuration value from the scan processor for level-sensitive triggering.
    NAvg: 8-bit configuration value. Pre-adder will add NAvg+1 samples before reporting.
    Reset: Boolean control signal from scan processor. Resets all states and counters. The signal must be synchronized to the rising edge of a sample clock via the triggering block.
    RE[0:2]: Read enable vector (one-hot)
    Trigger: Synchronized boolean signal from triggering block.
        
Outputs:
    Scan Processor Bus:
        Signal_Out: The 24-bit pre-added signal to the scan processor
        Empty: Boolean signal true when there is no data on the outputs
        Full: Boolean signal true when there are two data in the FIFO
        Reset_Ack: True when the circuit has been reset. Will go low when a trigger is accepted
        OVF: Boolean overflow status indication to the scan processor
    LvlGreater: Boolean output to the triggering block indicating current Signal value is greater than the TrigLevel
    
On Reset, all counters and states are reset. No data will be accepted until a Trigger is observed. After the Trigger is observed, data is shifted out via a FIFO. The circuit must be reset after each scan.

When the scan processor determines that the scan is complete, it will raise the Reset signal. After the Reset_Ack is observed, the scan processor will remove the Reset to arm the circuit for the next trigger.</t>
<t tx="ntallen.20080228133017.6">Inputs:
    NS: 1-4096 (Net samples per scan)
    NA: 0-255 (NA+1 samples pre-added)
    NC: 1-16383 (N Coadds)
    NE: 1-7 (channel enable, bit-mapped)

Would like to read in out-of-range status from the A/D
</t>
<t tx="ntallen.20080228133017.7"></t>
<t tx="ntallen.20080228140103">Obsolete: Inadequate

On Reset, DStat_Out (in ssp_ad_preaddr) and DStat_Ack (in ssp_ad_scan) are set to zero. When a new data value is ready to be shipped from the pre-adder to the scan processor, it is latched into Signal_Out and the DStat_Out value is toggled.

In the scan processor, the exclusive-or of DStat_Out and DStat_Ack is monitored. When it is true, that indicates new data is ready. When the new data is clocked into the scan processor, DStat_Ack is toggled to match DStat_Out.

In the pre-adder, if DStat_Ack is not equal to DStat_Out when new data is ready, that is an overflow condition, and the OVF bit is set. This bit is cleared at the end of each scan, but it can be monitored by the scan processor and reported back to the processor.

There are still synchronization issues. I want to make sure I have adequate setup times for the enables that I'm driving off the xor gates. If DStat_Out goes directly to the scan processor, I will need to add a delay or risk unpredictable behavior. The cost of the delay is reducing the maximum data rate from the pre adder to one half the cpu clock rate or less. The alternative is to route all the DStat_Out lines through an outside module to synchronize them to the falling edge of sys_clk</t>
<t tx="ntallen.20080229125358">I'm having trouble with end-of-scan because I haven't worked out a reset handshake. Since the arm circuit is synchronized with the sample clock, we don't have a way of knowing when the pre add circuit is properly reset, and hence whether the incoming sample is the result of a trigger or a stray sample from the previous scan.

I think I would like to see:
    pre-adder controlled by a single reset line. When asserted, the circuit is in reset. When cleared, it is ready for a trigger. Obviously clearing the reset must be synchronized, but setting it could be asynchronous.
    Better FIFO implementation to allow higher throughput.</t>
<t tx="ntallen.20080229125358.1">FIFO holds N samples, where N is most likely greater than 1
In this case, N is 2. There are 3 registers. The write index and the read index are implemented as 3-bit one-hot shift registers (FIFOdec) with a reset.

Inputs:
    Din: The data to be stored
    WE: Single write enable line
    RE: 3-bit one-hot read enable lines from remote clock domain
    Reset: Clears Overflow, resets write decoder circuit to point to first register

Outputs:
    Dout: The data in the register currently selected by the RE bits
    Empty: True when there is no data in the FIFO
    Full: True when no more data can be written to the FIFO
    OVF: True if a write occurred during a Full condition

The empty condition is when the read and write indexes point to the same register. Full is when incrementing the write index would advance to the empty condition. In this special case where the total capacity of the FIFO is 2, Full indicates that there are 2 data in the FIFO. The signal we really want on the remote side is one that tells us that there is more than one datum in the FIFO, and this fits the bill. If we were to increase the size of the FIFO, we'd probably need to do some more elaborate analysis to come up with that condition.</t>
<t tx="ntallen.20080229125358.2">The DStat block handles the handshaking with the pre addr stages. Data must be ready from all enabled channels before the transfer is acknowledged.

Inputs:
    DSI1,2,3: Data Status Inputs from the three channels consisting of:
        DataReady: True when at least one datum is ready
        DataReady2: True when at least two data are ready
        Reset_Ack: True when Pre_adder channel has been reset
        OVF: True if the channel has overflowed its output FIFO
    ChEn: 3-bit Configuration vector indicating which channels are enabled
    Reset: Resets read FIFO and issues PA_Reset to the pre_adder circuit.

Outputs:
    DV0: Data will be valid on the next cycle. This output should enable the data register
    RE: FIFO Read Enable vector (output to pre_adder channel)
    PA_Reset: Pre_Adder reset (routed through trigger block for synchronization)
    OVF: True if OVF input has been observed from any channel since reset

The Reset input should be driven by the (SSP_Reset + EOS)

The DV0 output will drive the enable on the register which will hold the incoming data. As such, it is one clock in advance of a proper data valid signal.

RE is a 3-bit one-hot vector indicating which of the 3 FIFO registers is currently being read.</t>
<t tx="ntallen.20080229125358.3">This block is responsible for individual scan processing.

Inputs:
    DV0: Data will be valid
    Count: NSample configuration from the CPU
    Reset: Scan Reset. Should be connected to (PA_Reset + SSP_Reset)

Outputs:
    DV: Data is valid (DV0 delayed one cycle and qualified appropriately)
    BOS: Beginning of scan. Synchronous with DVO
    EOS: End of scan. Synchronous with last DV of the scan
    ScanNum: Scan number (free running counter)

Internally, it will maintain the states ResetSt, ScanSt and EOSSt</t>
<t tx="ntallen.20080303084933"></t>
<t tx="ntallen.20080305130648">States:
    PreCoadd: Skipping scans before first scan
    FirstScan: no coadding yet
    PreLast: Skipping scans before last scan
    LastScan: Shifting out the coadded data

Inputs:
    OVFin: Overflow bits from Coadd block
    NCoaddIn: NCoadd from configuration input
    DV: Data valid from Sample Count block
    BOS: Beginning of Scan signal from Sample Count Block
    Reset: SSP_Reset signal
    Empty: FIFO1 empty output
Outputs:
    FirstScan: True when scan is not being coadded
    WE0: Write enable for FIFO0
    RE0: Read enable for FIFO0
    WE1: Write enable for FIFO1
    NSkF: Number of scans skipped before coadding
    NSkL: Number of scans skipped before last scan
    NCoadd: For header
    OVF: Coadd overflow bits</t>
<t tx="ntallen.20080305165613">Everything I might want to record in the header:
    d0: Format Version: 16 bits (0)    NWordsHdr: 16 bits (6)
    d1: NSamples: 14 bits  NChannels: 2 bits
    d2: NAvg: 7 bits  NCoadd: 14 bits
    d3: NSkP: 16 bits NSkL: 16 bits
    d4: ScanNum: 32 bits
    d5: Spare: 32 bits (for recording P, T, etc.)
    D[CE[0],0]
    ...
    D[CE[NChannels-1],0]
    D[CE[0],1]
    ...
    D[CE[NChannels-1],1]
    ...
    D[CE[0],NSamples-1]
    ...
    D[CE[NChannels-1],NSamples-1]

    d6: bits
      15:13: Channel Enable
      12: Auto Trigger Enable
      11: Trigger Rising
      10:9 Trigger Source
      8:6 A/D Out of range
      5:3 Pre-Adder FIFO Overflow
      2:0 Coadd Overflow

As soon as FIFO1 goes non-empty, I can start transmitting the header and data. The next EOS is synchronous with the last DV (and WE1), which means that once we've seen that, we should keep transfering data until FIFO1 is empty, then return to our ready state. CoaddCount is guaranteed not to start writing the next coadd sequence until FIFO1 is empty.

Note that the overflow status bits cannot properly be recorded until after the scan data because all the data has not been recorded when the header goes out.

Inputs:
    full: full signal from outbound FIFO
    SigIn: 96-bit data bus from the inbound FIFO
    empty: empty signal from inbound FIFO
    EOS: End-of-Scan signal from SampleCount block
    NSkP: N scans skipped before coadding
    NSkL: N scans skipped before final scan
    NC: NCoadd from CoaddCount block
    CAOVF: 3-bit Overflow from Coadd block
    Reset: SSP_Reset
    ScanNum: Scan number of last scan(*)
    NS: NSamples from input
    PAOVF: 3-bit Pre-Adder overflow
    ChEn: 3-bit channel enable vector from Control input
    TrigConfig: Trigger configuration from input
    NA: NAvg from input

Overflow bits are cleared on scan reset, so they must be recorded here until end of coadd. Preaddr overflow is held until end of scan, so we don't need to register it on the sample level, but we will need to do so on the scan level.
OVF from CoaddCount is cleared on BOS. In both cases, it should be adequate to record them on EOS. Neither vector is qualified with ChEn prior to being sent to ShiftOut, so ShiftOut should probably do that
(*) ScanNum should probably be latched on last scan. This will only be an issue if the outbound FIFO is so backed up that it takes longer than a scan time to transmit the first few words of the header.

The high order bit or two of the format version word should be reserved as 0 to distinguish the format from the fragmentation word.</t>
<t tx="ntallen.20080311125846">Software:
    Modify firmware to support new configuration:
        Change in control bits
        Different use of interrupts for receiving data
        Support for multiple channels
    Modify driver to support new configuration:
        Change in packet format
        Support for multiple channels

Hardware:
    Clean up top-level diagram and decide on best global new names
    Set defaults in pcores where possible
    Draw and/or implement Shift Header State machine as state diagram.
    </t>
<t tx="ntallen.20080311125846.1">HW: Still use a FIFO. Assume SW can keep up with the data transfer. If not, skip scans as necessary, then use that information to automatically skip scans before next coadd group.
SW: Transfer data whenever a sufficient amount is ready</t>
<t tx="ntallen.20080313122934">Generate VHDL needs some massaging.

First, there are two entities in one file, and Sysgen's Blackbox doesn't like that, but the file is easy to split. If the main diagram is called 'SHSTATE', the output file is named SHSTATE.vhd and the two entities are SHSTATE and SHELL_SHSTATE. Cut out the SHELL_STATE stuff and save it into SHELL_STATE.vhd.

Next, the state machine has a single CLK input, but Sysgen's Blackbox is looking for a clk/ce pair. I modified SHELL.vhd to change the name of the CLK port to sh_clk, properly mapped it to SHELL_SHSTATE's CLK port, and then added a dummy sh_ce input port. (The 'sh_' prefix is arbitrary, as long as the clk and ce signals match)

When you add the black box part, you will select SHSTATE.vhd, and it looks like it's happy, but if you go to simulate, you'll find that it does nothing, although it doesn't complain. I will, however dump a log file into the directory which indicates that it doesn't know where to find the SHELL_SHSTATE entity. What you need to do is edit the .m file that was generated by the black box part and near the end of the file add the SHELL_SHSTATE.vhd file after the SHSTATE.vhd file is listed.</t>
<t tx="ntallen.20080331101629">The source code is in
forge.abcd.harvard.edu:/cvsroot/arp-fpga
/ssp/ad_proto/ssp_proto_b V2_0

The server software is the code that runs on the microblaze processor inside the FPGA. It's responsibilities include:
    Monitoring TCP connections for incoming commands
    Monitoring and servicing the hardware
    Transmitting collected data</t>
<t tx="ntallen.20080331101629.1">main_main,2:
    The startup thread as specified in software platform settings. Invokes lwip_init(), which ultimately runs tcpip_init() which starts the tcpip_thread and then runs ready waiting for tcpip_thread's initialization to complete. As such, main_main needs to run at a lower priority than tcpip_thread or it will never complete. In round robin scheduling, the tcpip_thread should complete its initialization before tcpip_init() hits its busy loop.

tcpip_thread, TCPIP_THREAD_PRIO (1):
    Started by lwip_init(). Services messages in the tcpip mbox (outbound processing) Uses sys_mbox_fetch() to wait for messages.

udpThread, 5:
    Started by main_main. Initializes ethernet and starts xemacif_input_thread. This version will poll for data and sleep() when none is available. Also monitors the command queue. Starts xemacif_input_thread()
    
xemacif_input_thread, 5:
    Started by udpThread. Monitors incoming queue and dispatches packets to the appropriate processor. Currently runs ready or with a yield(), but should use a semaphore signaled from the incoming interrupt. (I patched the LwIP library to use a semaphore)

ServerAppThread,1:
    listens for new TCP connections. Starts a new tcpThread on each new connection

tcpThread, 4:
    Services a TCP connection. Reads commands, queues command requests and formats replies.
    </t>
<t tx="ntallen.20080331101629.2">Note that these command codes differ from the earlier version.
As such, the client code will have to be modified. Only a single command is accepted on each transmission currently, although including multiple commands would be relatively easy, albeit complicating the reply coding.

  Commands:
    DA Disable/Reset: Always legal
    EN Enable: Should not be legal while acquiring
    
    Configuration Commands: Not legal unless disabled
      NS:xxxx N_Samples (1-SSP_MAX_SAMPLES)
      NA:xxxx N_Average (Pre-Adder: 1-SSP_MAX_AVERAGE)
      NC:xxxx N_Coadd (1-SSP_MAX_COADD)
      NP:xxxxx UDP Port Number
      NE:x Channel enable: 1-7 bit-mapped

    Triggering Commands: Take effect immediately
      TU:[-]xxxxx Level Trigger Rising
      TD:[-]xxxxx Level Trigger Falling
      TS:x Trigger Source (0-3)
      AE Autotrig Enable
      AD Autotrig Disable

    Deprecated and/or unimplemented commands:
      EX Quit (not useful in production)
      RS Return Status (not implemented?)

  Return Values:
    200 OK
    410 Gone (successful response to EX)
    500 Bad
    503 Busy (Service Unavailable)
</t>
<t tx="ntallen.20080331101629.3"></t>
<t tx="ntallen.20080331114222">The configuration of the hardware will be maintained in a shared structure. Since it is possible that more than one tcpThread will exist, access to the structure must be controlled. I will maintain a mutex for the structure itself, then a pair of semaphores: udp_sem for signaling udpThread and tcp_sem for signaling a reply to the tcpThread currently holding the mutex. Posting to udp_sem is illegal unless you are holding the mutex. Once tcpThread has posted to udp_sem, it must wait on tcp_sem for the operation to complete. udpThread has control of the structure from the time it receives udp_sem until it posts to tcp_sem.

    CC: Command code.
    RV: Return code
    EN: Enable flag.
    NS: Number of scan samples reported
    NA: Number of consecutive samples average in the pre-adder
    NC: Number of scans coadded
    NP: UDP Port number
    TL: Trigger level (signed short) (from NU or ND commands)
    TrigConfig: includes trigger polarity bit (from NU,ND), trigger source (NT) and AE

tcpThread will write all of these values and signal udpThread when necessary.
tcpThread will only set CC and EN. udpThread will be responsible for clearing these codes.
Updates to NS, NA, NC or NP will be illegal while EN != 0 (Busy return code)

CC values used to signal udpThread:
    UDPCMD_ENABLE
    UDPCMD_DISABLE
    UDPCMD_TRIGGER
    </t>
<t tx="ntallen.20080331131839">The data from the SSP is transmitted in UDP packets

SSP_MAX_SAMPLES (Hardware limit: ~4K)
SSP_MAX_PREADD
SSP_MAX_COADD
SSP_MAX_CHANNELS 3
N_Channels (1-SSP_MAX_CHANNELS, software selectable)

Word 0: [Version: 16 bits. Current Value: 0][NWhdr: 16 bits: Current Value: 6]
Word 1: [NS: 16 bits][NCh: 16 bits]
Word 2: [NA: 16 bits][NC: 16 bits]
Word 3: [NSkP: 16 bits][NSkL: 16 bits]
Word 4: [ScanNum: 32 bits]
Word 5: [0: 32 bits. Fill in P, T? ]
Word 6:6+NS*NCh-1: [32 bits signed integer data]
Word 6+NS*NCh: [32 bits TrigConfig:ChEn:ADovf:PAovf:CAovf]


</t>
<t tx="ntallen.20080403140406">The pre-adder reads in the raw signal from the A/D converter and optionally adds a pre-configured number of samples before passing the data on to the scan processing unit. It also performs level-comparison for level-sensitive triggering.

V2.00b outputs 25bits of signal with the 25th bit being the OOR status.

In the complete design, there will be three of these pre-adders: one for each A/D converter. The clock input to each pre-adder should be connected to the inverted data clock from its associated A/D converter.

Inputs:
    Signal: The 16-bit A/D data from the arp_ssp block
    TrigLevel: 16-bit configuration value from the scan processor for level-sensitive triggering.
    NAvg: 8-bit configuration value. Pre-adder will add NAvg+1 samples before reporting.
    Reset: Boolean control signal from scan processor. Resets all states and counters. The signal must be synchronized to the rising edge of a sample clock via the triggering block.
    RE[0:2]: Read enable vector (one-hot)
    Trigger: Synchronized boolean signal from triggering block.
        
Outputs:
    Scan Processor Bus:
        Signal_Out: The 24-bit pre-added signal to the scan processor
        Empty: Boolean signal true when there is no data on the outputs
        Full: Boolean signal true when there are two data in the FIFO
        Reset_Ack: True when the circuit has been reset. Will go low when a trigger is accepted
        OVF: Boolean overflow status indication to the scan processor
    LvlGreater: Boolean output to the triggering block indicating current Signal value is greater than the TrigLevel
    
On Reset, all counters and states are reset. No data will be accepted until a Trigger is observed. After the Trigger is observed, data is shifted out via a FIFO. The circuit must be reset after each scan.

When the scan processor determines that the scan is complete, it will raise the Reset signal. After the Reset_Ack is observed, the scan processor will remove the Reset to arm the circuit for the next trigger.</t>
<t tx="ntallen.20080403140406.1">FIFO holds N samples, where N is most likely greater than 1
In this case, N is 2. There are 3 registers. The write index and the read index are implemented as 3-bit one-hot shift registers (FIFOdec) with a reset.

Inputs:
    Din: The data to be stored
    WE: Single write enable line
    RE: 3-bit one-hot read enable lines from remote clock domain
    Reset: Clears Overflow, resets write decoder circuit to point to first register

Outputs:
    Dout: The data in the register currently selected by the RE bits
    Empty: True when there is no data in the FIFO
    Full: True when no more data can be written to the FIFO
    OVF: True if a write occurred during a Full condition

The empty condition is when the read and write indexes point to the same register. Full is when incrementing the write index would advance to the empty condition. In this special case where the total capacity of the FIFO is 2, Full indicates that there are 2 data in the FIFO. The signal we really want on the remote side is one that tells us that there is more than one datum in the FIFO, and this fits the bill. If we were to increase the size of the FIFO, we'd probably need to do some more elaborate analysis to come up with that condition.</t>
<t tx="ntallen.20080403140406.2"></t>
<t tx="ntallen.20080403140406.3">Obsolete: Inadequate

On Reset, DStat_Out (in ssp_ad_preaddr) and DStat_Ack (in ssp_ad_scan) are set to zero. When a new data value is ready to be shipped from the pre-adder to the scan processor, it is latched into Signal_Out and the DStat_Out value is toggled.

In the scan processor, the exclusive-or of DStat_Out and DStat_Ack is monitored. When it is true, that indicates new data is ready. When the new data is clocked into the scan processor, DStat_Ack is toggled to match DStat_Out.

In the pre-adder, if DStat_Ack is not equal to DStat_Out when new data is ready, that is an overflow condition, and the OVF bit is set. This bit is cleared at the end of each scan, but it can be monitored by the scan processor and reported back to the processor.

There are still synchronization issues. I want to make sure I have adequate setup times for the enables that I'm driving off the xor gates. If DStat_Out goes directly to the scan processor, I will need to add a delay or risk unpredictable behavior. The cost of the delay is reducing the maximum data rate from the pre adder to one half the cpu clock rate or less. The alternative is to route all the DStat_Out lines through an outside module to synchronize them to the falling edge of sys_clk</t>
<t tx="ntallen.20080403140406.4">I'm having trouble with end-of-scan because I haven't worked out a reset handshake. Since the arm circuit is synchronized with the sample clock, we don't have a way of knowing when the pre add circuit is properly reset, and hence whether the incoming sample is the result of a trigger or a stray sample from the previous scan.

I think I would like to see:
    pre-adder controlled by a single reset line. When asserted, the circuit is in reset. When cleared, it is ready for a trigger. Obviously clearing the reset must be synchronized, but setting it could be asynchronous.
    Better FIFO implementation to allow higher throughput.</t>
<t tx="ntallen.20080403141641"></t>
<t tx="ntallen.20080404114126">SSP_V1
  []DA doesn't seem to get through
  []Communication is spotty
  The FPGA appears to be missing some packets, which is apparently worse when on the LAN.
  Probably should write some benchmark apps to record timing info indicating exactly when particular packets get through. Of course with TCP, we don't have much insight into the retries, but we can follow that with wireshark. What is happening when a packet is lost? Is the ethernetlite firmware busy? Is the driver busy? Is LwIP busy?</t>
<t tx="ntallen.20080502115342">Use GENACE, documented in the Embedded System Tools Reference Manual.</t>
<t tx="ntallen.20080512113736">-llwip4 -lxilkernel</t>
<t tx="ntallen.20080602105139">We have identified at least one system that cannot receive large UDP packets (elec-ws). Since this is a system that is likely to be used during continuing development, we need to come up with our own packet fragmentation strategy.

MTU for 802.3 ethernet is 1500. Does this include the ethernet header? According to Wikipedia, Ethernet 802.3 allows 1500 octets for payload, which should include the entire IP packet.
IP header is 20 bytes, leaving UDP packet max packet size of 1480 bytes.

MTU          1500
IP Hdr         20
UDP Hdr         8
Max UDP Payload: 1472

Total scan size = 4 * (NWHDR + NCh * NS)
If the total scan size exceeds the Max UDP Payload size, we must fragment the scan. We will add an additional 4-byte fragmentation header, with the following contents:
    bit 31: 1 - indicates that the scan is fragmented
    bit 30: Last fragment - true on last fragment of the scan
    bits 16-29: Scan serial number - incremented on each complete scan that is transmitted
    bits 0-15: Word offset of the start of this fragment. Multiply by 4 to get byte offset.

On the receiving end, we should be able to predict fragmentation and be ready for it. In the wide open network, the receiver should be able to tolerate packets arriving out of order, but I think it's safe to assume that won't happen in the lab. I can certainly detect it and report it if it happens.

</t>
<t tx="ntallen.20080617120554"></t>
<t tx="ntallen.20080617120554.1">I believe this is done.
</t>
<t tx="ntallen.20080617120554.2">Also?
</t>
<t tx="ntallen.20080717103941"></t>
<t tx="ntallen.20080930104722">Targeting ML401 for desktop testing

ssp_trigger 1.00.a
arp_ssp 2.00.c
ssp_ad_preaddr 2.00.b X3
ssp_ad_scan_sm 3.00.b</t>
<t tx="ntallen.20080930104722.1">V2.00a: Added DATA_VALID_INV for clocking the pre adder.

This block needs to be entered into CVS
It also needs to be augmented to support the OOR bit from the converter

arp_ssp implements the LVDS input buffers for the A/D data and clock. It takes P,N pairs as input and outputs buffered signals. It also provides both true and inverted outputs for the clock to facilitate synchronization.

The A/D clock goes high at the same time the data is updated, so the data should be latched on the falling edge of the clock. Hence the ssp_ad_preaddr block will be driven by the inverted signal clock. On the other hand, we need to synchronize signals coming from ssp_ad_scan, which runs off the processor's clock. There are three ssp_ad_preaddrs, and each has it's own clock. These should be very closely matched, and in theory we can use the 9510 to tweak out any phase differences, but in practice, it's possible that there will be some slight difference between the clocks. In order to reliably synchronize signals from ssp_ad_scan and from the external trigger, we will have the ssp_trigger block use the non-inverted signal clock from one of the A/D channels.</t>
<t tx="ntallen.20080930110102">Targeting SSP Rev 1

ssp_trigger 1.00.a
arp_ssp 2.00.c X3
ssp_ad_preaddr 2.00.b X3
ssp_ad_scan_sm 3.00.b</t>
<t tx="ntallen.20080930110904">Targeting ML401 for quick test of PMT input

ssp_trigger 1.00.a
arp_ssp 2.00.c
ssp_ad_preaddr 2.00.b X3
ssp_ad_scan_sm 3.00.b
SSP_PMT_Input 1.00.a

Still an open question is how to connect the external trigger and the PMT input to the ML401/SSP_AD_PROTO combination. The SMAs on the ML401 are attractive and connected directly to the FPGA, but there isn't enough clearance under the SSP_AD_PROTO board to make the connection, and only one or two of those connections are Global Clock-capable. There are several pins on the headers that are local-clock-capable:

    J6.38 AC26 HDR1_24 (Associated DGND pins at J6.(n-1))
    J6.6  AC25 HDR1_36
    J6.14  Y24 HDR1_26
    J6.2  AA24 HDR1_28

but these would require some wiring on the proto board.
</t>
<t tx="ntallen.20080930110904.1"></t>
<t tx="ntallen.20081029142547">On the SSP, we use the XPS IIC Bus Interface component to talk to the 24LC04B EEPROM. This is a finicky system. Although xps_iic provides a bus interface, it is necessary to understand the details of the specific device being addressed in order to successfully communicate. In addition, the xps_iic must be fully integrated with the interrupt system even when operation is thoroughly serialized.

XIic_SetAddress() refers to the device address, not a linear address within a memory block. The 24LC04B is configured as two banks of 256 words, and the associated device addresses for the banks are 0x50 and 0x51. The 24LC04B only uses a 7-bit device address, so the xps_iic can be built without 10-bit address support, or the 10-bit address option can be interactively de-selected.

To write to the 24LC04B, we can use XIic_MasterWrite(), which initializes a transfer of a specified number of data bytes. The first byte is the address within the memory block, and the remaining bytes are the data. Note however, that you can write at most 16 bytes of data using this method, and all the target addresses must be within the same 16-byte 'page' of memory. If more than 16 bytes are received or the internal address reaches a page boundary, the internal address will wrap back to the previous page boundary and overwrite. Hence write operations must be broken up into 16-byte chunks.

To read from the 24LC04B, we must first select the address within the memory block from which we wish to read. This is done by writing out a single byte containing the address. After that, XIic_MasterRead() can be used to read data from the device. There is apparently no page limitation on read requests.

Also note that as a general feature of the Xilinx driver libraries, there is a basic undocumented assumption that device instance structures are allocated statically and hence initialized to zero. The *_Initialize() functions (at least for XIntc and XIic) check a 'Started' field and refuse to initialize the device if that field is non-zero. This is counter-intuitive. The purpose of these functions is to initialize these structures, but they assume the structure has already been initialized.
</t>
<t tx="ntallen.20081031104332">Building separate ACE files for each board doesn't make sense. What we want to do is store board-specific configuration options in the EEPROM. I have figured out how to read and write the EEPROM, so now the question is what to store there and how to initialize it.</t>
<t tx="ntallen.20081031104332.1">We will start with a basic configuration with version 0. Each time information is added, the version will be incremented, and the added information will have a well-defined default in case reading from an earlier version.

Configuration Length: 2 bytes: number of bytes total
Configuration checksum: 2 bytes: of some sort
Configuration Version: 2 bytes: Start at zero. Increment each time data is added
MAC Address: 6 bytes
IP Address: 4 bytes
Netmask: 4 bytes
Gateway: 4 bytes
SSP Board Serial Number: ARP_SSP_%05d 2 bytes
Fab Date: YYYY/MM/DD 4 bytes
Configuration Date: YYYY/MM/DD 4 bytes
HW Configuration Notes: As much as it takes

PROM holds 4Kbits or 512 bytes in two banks of 256.</t>
<t tx="ntallen.20081031104332.2">On the FPGA, use configuration address 0 for the network configuration tool. Create an ACE file to run the configuration tool which will read the EEPROM, read the dip switches, and accept TCP connections to report the current configuration and/or set new configuration contents.</t>
<t tx="ntallen.20081031104332.3">Build device with support for Ethernet, IIC, GPIO (dip switches and/or LEDs)
Build software with xilkernel, lwip

Program will read the EEPROM to determine the current configuration
Program will read dip switches to decide on the network configuration to use:
    0: Use default MAC Addr/IP Addr #0 (10.0.0.200)
    1: Use default MAC Addr/IP Addr #1 (10.0.1.200)
    ...
    15: Use current EEPROM configuration

Accept tcp connections on port 80(?)
Support read and write operations. Read reports the current contents in the current format. Write updates the contents and then reports it back. This could be enhanced to do HTTP pretty easily. That would obviate the need to write a configuration client tool.</t>
<t tx="ntallen.20081031104332.4">Using this project to test out various peripherals
</t>
<t tx="ntallen.20081114110138"></t>
<t tx="ntallen.20081114110138.1">main_main,2:
    The startup thread as specified in software platform settings. Invokes lwip_init(), which ultimately runs tcpip_init() which starts the tcpip_thread and then runs ready waiting for tcpip_thread's initialization to complete. As such, main_main needs to run at a lower priority than tcpip_thread or it will never complete. In round robin scheduling, the tcpip_thread should complete its initialization before tcpip_init() hits its busy loop.

tcpip_thread, TCPIP_THREAD_PRIO (1):
    Started by lwip_init(). Services messages in the tcpip mbox (outbound processing) Uses sys_mbox_fetch() to wait for messages.

xemacif_input_thread, 5: (note that ssp_fpga_sw has this set to 1 now since it no longer runs ready)
    Started by serverAppThread. Monitors incoming queue and dispatches packets to the appropriate processor. Currently runs ready or with a yield(), but should use a semaphore signaled from the incoming interrupt. (I patched the LwIP library to use a semaphore)

ServerAppThread,1:
    Started by main_main. Initializes ethernet and starts xemacif_input_thread.    
    listens for new TCP connections. Starts a new tcpThread on each new connection

tcpThread, 4: (ssp_fpga_sw has this set to 1)
    Services a TCP connection. Reads commands, queues command requests and formats replies.
    </t>
<t tx="ntallen.20081118114833">To optimize use of TCP, we would like to invoke the send() function with full buffers matched to the maximum TCP payload size whenever possible. The maximum TCP payload should be:
    MTU: 1500
    IP Header: 20
    TCP Header: 20
    Maximum TCP Payload: 1500-20-20 = 1460</t>
<t tx="ntallen.20100702124409.1475"></t>
<t tx="ntallen.20100702124409.1476">ssp_cmd.exe
ssp_log.exe</t>
<t tx="ntallen.20100702124409.1477">  ssp_cmd
    Opens TCP command connection to 10.0.0.200 or the IP address specified in the
    environment variable SSP_HOSTNAME. Sends the list of commands passed on
    the command line. If the disable command (DA) is sent, attempts to shut down
    ssp_log if it is running. Otherwise, ssp_cmd does not attempt to interpret the
    commands.

  Commands:
    EN Enable
    DA Disable
    EX Quit
    NS:xxxx N_Samples
    NA:xxxx N_Avg
    NC:xxxx N_Coadd
    NP:xxxxx UDP Port Number
    NE:x Channel Enable (1-7)
    TU:[-]xxxxx Level Trigger Rising
    TD:[-]xxxxx Level Trigger Falling
    TS:x Trigger Source (0-3)
    AE Autotrig Enable
    AD Autotrig Disable
  Return Values:
    200 OK
    500 Bad
</t>
<t tx="ntallen.20100702124409.1478">  ssp_log NS:%d NA:%d NC:%d NF:%d NE:%d TS:%d [TU|TD]:%d IX:%d'
    Opens a UDP socket for receiving data
    Opens TCP command connection to SSP board
    Issues the configuration command, informing the SSP board
      what UDP port to send data to
    Reads some quantity of data from the UDP port
    Issues the stop command

  Commands:
    NS:xxxx N_Samples
    NC:xxxx N_Coadd
    NA:xxxx N_Average
    NF:xxxx Frequence Divisor
    NE:xxxx Bit-mapped channel enable
    TS:x    Trigger Source [0-3] (3 =&gt; external)
    TU:xxx  Rising Trigger Level
    TD:xxx  Falling Trigger Level
    IX:xxxx Starting MLF file index

ssp_log initiates communication with the SSP board. The default IP address is 10.0.0.200.
It can be overridden with the environment variable SSP_HOSTNAME in order to target a
different board.

ssp_log issues the appropriate configuration commands to the SSP board, then issues the enable command 'EN'. It then records incoming scans until it receives a SIGHUP. As each scan is
received and written, a status line is written to the header log file, CPCI14/ssp.log

  fprintf( hdr_fp, "%ld %lu %u %u %u %u %u %u %u %u %u %lu %.4f %.4f %lu\n",
    now, mlf-&gt;index,
    hdr-&gt;NWordsHdr, hdr-&gt;FormatVersion, hdr-&gt;NChannels, hdr-&gt;NF,
    hdr-&gt;NSamples, hdr-&gt;NCoadd, hdr-&gt;NAvg, hdr-&gt;NSkL, hdr-&gt;NSkP,
    hdr-&gt;ScanNum, (hdr-&gt;T_HtSink &amp; 0xFFE0)/256.,
    (hdr-&gt;T_FPGA&gt;&gt;3)/16., (unsigned long)scan[raw_length-1] );
  fflush(hdr_fp);

Before each file is written, a lock file is created in CPCI14/ssp_%d.lock. After the file is written, the lock file is renamed to the next index number.</t>
<t tx="ntallen.20100702124409.1479"></t>
<t tx="ntallen.20100702124409.1480">GUI that invokes ssp_cmd and ssp_log, then displays the data in realtime.

GUI actually monitors the lock file to see if a new file is ready to be processed,
then reads the header info from the log file:
    index = 1
    while true
      if data file specified by index exists and corresponding lock file does not
        read a line from the log file and process the data file
        index &lt;= index + 1
      else sleep .1 seconds
    done

    [Note that currently there is no check to make sure the header line matches
     the log file index.]

</t>
</tnodes>
</leo_file>
