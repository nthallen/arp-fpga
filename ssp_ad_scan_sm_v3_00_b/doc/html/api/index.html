<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"  http-equiv="content-type">
  <link rel="stylesheet" href="sgdocstyle.css" type="text/css">
  <title>[hwinst] API documentation</title>
</head>
<body><h1 style="background: url(sgdocbanner.jpg) no-repeat">
EDK Processor - [hwinst] API</h1>
<div>
<p>Memories attached to the System Generator block, <code>EDK Processor</code>,
can be accessed from the processor via a memory-mapped interface.
Software drivers have been generated to provide easy access to these
memories by means of C-style function calls. In order to utilize these
functions, 2 header files need to be included in a user's C-code. The
first header-file is called <code>xparameters.h</code>, the second
header-file's name changes depending on the instance name given to the EDK PCore
peripheral when it is instanced in an EDK project. For example, if the
pcore named <code>mypcore</code> is instanced in an EDK project, it
may be given the name <code>mypcore_0</code>, the include file required will
be <code>mypcore_0.h</code>. This documentation file is elaborated when 
libraries and BSPs are generated by LibGen. This elaboration will expand the
tags: [<code>hwinst</code>] and [<code>HWINST</code>] into the instance name
and capitalized instance-name of the peripheral. 
<br>
<br>
<code>#include "xparameters.h"<br>
#include "[hwinst].h"<br>
</code>
<br>
The second header file contains information on the shared memories
contained in the pcore. Information such as memory map address location, memory bit
width, size and FIFO depth can be found in that header file. Code
snippets showing how to use the different software driver calls can be
found in the <a href="#examples">Examples</a> section of this
document.
<br>
<br>
Refer to the <a href="#software_driver_function_summary"> Software
Driver Function Summary</a> section for information on customizing
driver performance and how to configure the drivers to work for
asynchronous peripherals.</p>
</div>

<h2><a name="smi">Shared Memory Identifiers</a></h2>
<div>
<table style="width: 100%;" cellspacing="0"><tbody><tr><th>Shared Memory Name</th><th>Native Precision*</th><th>Identifier**</th><th>Notes</th></tr><tr><td class="odd"><b><a href="#Control">Control</a></b></td><td class="odd"></td><td class="odd">[HWINST]_CONTROL</td><td class="odd">To Register</td></tr><tr><td class="odd"></td><td class="odd">UFix_8_0</td><td class="odd">[HWINST]_CONTROL_DIN</td><td class="odd">Write only</td></tr><tr><td class="odd"></td><td class="odd">UFix_8_0</td><td class="odd">[HWINST]_CONTROL_DOUT</td><td class="odd">Read only</td></tr><tr><td class="even"><b><a href="#NAvg">NAvg</a></b></td><td class="even"></td><td class="even">[HWINST]_NAVG</td><td class="even">To Register</td></tr><tr><td class="even"></td><td class="even">UFix_8_0</td><td class="even">[HWINST]_NAVG_DIN</td><td class="even">Write only</td></tr><tr><td class="even"></td><td class="even">UFix_8_0</td><td class="even">[HWINST]_NAVG_DOUT</td><td class="even">Read only</td></tr><tr><td class="odd"><b><a href="#NetSamples">NetSamples</a></b></td><td class="odd"></td><td class="odd">[HWINST]_NETSAMPLES</td><td class="odd">To Register</td></tr><tr><td class="odd"></td><td class="odd">UFix_12_0</td><td class="odd">[HWINST]_NETSAMPLES_DIN</td><td class="odd">Write only</td></tr><tr><td class="odd"></td><td class="odd">UFix_12_0</td><td class="odd">[HWINST]_NETSAMPLES_DOUT</td><td class="odd">Read only</td></tr><tr><td class="even"><b><a href="#TriggerLevel">TriggerLevel</a></b></td><td class="even"></td><td class="even">[HWINST]_TRIGGERLEVEL</td><td class="even">To Register</td></tr><tr><td class="even"></td><td class="even">Fix_16_0</td><td class="even">[HWINST]_TRIGGERLEVEL_DIN</td><td class="even">Write only</td></tr><tr><td class="even"></td><td class="even">Fix_16_0</td><td class="even">[HWINST]_TRIGGERLEVEL_DOUT</td><td class="even">Read only</td></tr><tr><td class="odd"><b><a href="#NCoadd">NCoadd</a></b></td><td class="odd"></td><td class="odd">[HWINST]_NCOADD</td><td class="odd">To Register</td></tr><tr><td class="odd"></td><td class="odd">UFix_14_0</td><td class="odd">[HWINST]_NCOADD_DIN</td><td class="odd">Write only</td></tr><tr><td class="odd"></td><td class="odd">UFix_14_0</td><td class="odd">[HWINST]_NCOADD_DOUT</td><td class="odd">Read only</td></tr><tr><td class="even"><b><a href="#SrcSignal">SrcSignal</a></b></td><td class="even"></td><td class="even">[HWINST]_SRCSIGNAL</td><td class="even">From FIFO [512]</td></tr><tr><td class="even"></td><td class="even">UFix_32_0</td><td class="even">[HWINST]_SRCSIGNAL_DOUT</td><td class="even">Read only</td></tr><tr><td class="even"></td><td class="even">UFix_9_0</td><td class="even">[HWINST]_SRCSIGNAL_PERCENTFULL</td><td class="even">Read only</td></tr><tr><td class="even"></td><td class="even">UFix_1_0</td><td class="even">[HWINST]_SRCSIGNAL_EMPTY</td><td class="even">Read only</td></tr><tr><td class="even"></td><td class="even">Boolean</td><td class="even">[HWINST]_SRCSIGNAL_RST</td><td class="even">Write only</td></tr></tbody></table><p><small>* Native precision here refers to the types and bit-sizes of the shared memory in the System Generator environment. When reading and writing to or from these memories in a processor, the values will always be returned as a C unsigned integer type. The software drivers do not perform type conversion.<br> ** [<code>hwinst</code>] is used to refer to the instance name given to the pcore, and [<code>HWINST</code>] the capitalized version of the instance name. </small></p>
</div>

<h2><a name="software_driver_function_summary">Software driver
function summary</a></h2>
<div>
<table style="width: 100%;" cellspacing="0">
  <tbody>
    <tr>
      <td class="odd">int</td>
      <td class="odd"> <code><a href="#Read">[hwinst]_Read</a>
(unsigned int memName,unsigned int addr,unsigned int* val) </code> </td>
    </tr>
    <tr>
      <td class="even">int</td>
      <td class="even"> <code><a href="#ArrayRead">[hwinst]_ArrayRead</a>
(unsigned int memName,unsigned int startAddr,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int transferLength, unsigned int** valBuf); </code> </td>
    </tr>
    <tr>
      <td class="odd">int<br>
      </td>
      <td class="odd"> <code><a href="#Write">[hwinst]_Write</a>
(unsigned int memName, unsigned int addr,unsigned int val); </code> </td>
    </tr>
    <tr>
      <td class="even">int<br>
      </td>
      <td class="even"> <code><a href="#ArrayWrite">[hwinst]_ArrayWrite</a>
(unsigned int memName,unsigned int startAddr,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
unsigned int transferLength, const unsigned int* valBuf); </code> </td>
    </tr>
    <tr>
      <td class="odd">unsigned int<br>
      </td>
      <td class="odd"> <code><a href="#getMaxRetry">[hwinst]_getMaxRetry</a>
(); </code> </td>
    </tr>
    <tr>
      <td class="even">void<br>
      </td>
      <td class="even"> <code><a href="#setMaxRetry">[hwinst]_setMaxRetry</a>
(unsigned int val); </code> </td>
    </tr>
    <tr>
      <td class="odd">void<br>
      </td>
      <td class="odd"> <code><a href="#flushReadFIFO">[hwinst]_flushReadFIFO</a>
(); </code> </td>
    </tr>

  </tbody>
</table>

<br>
<b><a name="asyncdrv">Configuring drivers for asynchronous operation</a></b>
<p>The software drivers generated by System Generator comes in two
  flavours: a non-polling and a polling mode. The non-polling drivers
  expect the Processor to be clocked at the same or slower clock-rate
  than the peripheral. If the Processor is clocked faster than the
  peripheral, the peripheral may not respond fast enough with data
  requested by the Processor. In the later case, polling drivers
  should be used. Polling drivers add a small amount of over-head to
  the software driver, and should not be used unnecessarily. 
  <br> <br>
  Polling drivers can be activated in XPS from the Software Platform
  Settings dialog. From the XPS menu bar, select Software-&gt;Software
  Platform Settings ... Next select Drivers, and you should see a
  Driver Parameters box. Toggle the parameter "SG_USEPOLLING" to true
  for the peripheral in question. Click OK and recompile your software
  libraries.
  <br> <br>
  Reads and write functions for polling and non-polling have identical
  calling conventions. However polling drivers have a retry value that
  governs how many retries the driver will make before reporting an
  error. The retry value can be accessed using the following two functions:
  <br>
  <br><code><a href="#getMaxRetry">[hwinst]_getMaxRetry</a></code>
  <br><code><a href="#setMaxRetry">[hwinst]_setMaxRetry</a></code>
  <br><code><a href="#flushReadFIFO">[hwinst]_flushReadFIFO</a></code>

</p>

<b>Improving array read and write performance</b>
<p>The <code>EDK Processor</code> design is connected to the processor via 
a pair of Fast Simplex Links (FSL), which are essentially FIFOs. Array read and write
performance depend on the size of the FSL FIFOs and the relative clock
speed between the processor and the pcore's me<code>EDK Processor</code>. If
hardware on both sides of the FSL FIFO can keep-up with each other's data rate,
burst read and write lengths is limited by the size of the shared memory. If
however there are differences in data processing rates, the maximum burst sizes
will be determined by the depth of the FSL FIFOs. Users can customize the depth
of these FIFOs from Xilinx Platform Studio.
</p>
</div>


<div>
<h3><a name="Read">Read</a></h3>
<div class="tt">
int [hwinst]_Read(<br>
&nbsp;&nbsp;&nbsp;unsigned int memName,<br>
&nbsp;&nbsp;&nbsp;unsigned int addr, <br>
&nbsp;&nbsp;&nbsp;unsigned int* val)
</div>
<p>
<b>Parameters:</b><br>
<code>memName</code> - An unsigned integer representing the
memory.<br>
<code>addr</code> - The address to read from.<br>
<code>val</code> - A pointer to the location in memory to
store the read value.
</p>
<p>
<b>Returns:</b><br>
Returns 0 if read succeeded. Returns a negative value on error.<br>
</p>
<p>
<b>Notes:</b><br>
Memory name identifiers and pin addresses can be found in the <a
 href="#smi">shared memory identifiers</a> table. 
When reading from a shared memory, addr refers to the shared memory's 
address space. When reading from a shared register or shared FIFO, 
addr refers to the address of the pin to read. 
</p>
</div>
</div>

<div>
<h3><a name="ArrayRead">Array Read</a></h3>
<div class="tt">
int [hwinst]_ArrayRead(<br>
&nbsp;&nbsp;&nbsp; unsigned int memName,<br>
&nbsp;&nbsp;&nbsp; unsigned int startAddr, <br>
&nbsp;&nbsp;&nbsp; unsigned int transferLength, <br>
&nbsp;&nbsp;&nbsp; unsigned int** valBuf)
</div>
<p>
<b>Parameters:</b><br>
<code>memName</code> - An unsigned integer representing the
memory.<br>
<code>startAddr</code> - The address to begin the read from. <br>
<code>transferLength</code> - Length of the burst transfer.<br>
<code>valBuf</code> - A pointer to the location in memory to
store the read values.
</p>
<p>
<b>Returns:</b><br>
Returns the number of reads performed. Returns a negative value on
error.<br>
</p>
<p>
<b>Notes:</b><br>
Memory name identifiers and pin addresses can be found in the <a
 href="#smi">shared memory identifiers</a> table. When reading
from a shared memory, startAddr refers to the shared memory's address
space. When reading from a shared register or shared FIFO, startAddr
refers to the address of the pin to read. <br><br>
An array read operation on a FIFO will not cause the address
counter in the hardware to increment; multiple reads on a FIFO will
return sequential values popped from the same FIFO.<br><br>
An array read operation on a shared memory will cause the address
counter in the hardware to increment.<br><br>
An array read operation on a register will cause the address
counter in the hardware to increment. Registers are given their own
address bank in the generated memory-map. This allows register values
in consecutive address locations to be read using an array read
operation.
</p>
</div>
</div>

<div>
<h3><a name="Write">Write</a></h3>
<div class="tt">
int [hwinst]_Write(<br>
&nbsp;&nbsp;&nbsp; unsigned int memName,<br>
&nbsp;&nbsp;&nbsp; unsigned int addr, <br>
&nbsp;&nbsp;&nbsp; unsigned int val)
</div>
<p>
<b>Parameters:</b><br>
<code>memName</code> - An unsigned integer representing the
memory.<br>
<code>addr</code> - The address to write to. <br>
<code>val</code> - The value to write.
</p>
<p>
<b>Returns:</b><br>
Returns 0 if read succeeded. Returns a negative value on error.<br>
</p>
<p><b>Notes:</b><br>
Memory name identifiers and pin addresses can be found in the <a
 href="#smi">shared memory identifiers</a> table. 
When writing to a shared memory, addr refers to the shared memory's 
address space. When writing to a shared register or shared FIFO, 
addr refers to the address of the pin to write.
</p>
</div>
</div>


<div>
<h3><a name="ArrayWrite">Array Write</a></h3>
<div class="tt">
int [hwinst]_ArrayWrite(<br>
&nbsp;&nbsp;&nbsp; unsigned int memName,<br>
&nbsp;&nbsp;&nbsp; unsigned int startAddr, <br>
&nbsp;&nbsp;&nbsp; unsigned int transferLength, <br>
&nbsp;&nbsp;&nbsp; unsigned int* valBuf)
</div>
<p>
<b>Parameters:</b><br>
<code>memName</code> - An unsigned integer representing the
memory. <br>
<code>startAddr</code> - The address to write to. <br>
<code>valBuf</code> - The value to write.
</p>
<p>
<b>Returns:</b><br>
Returns the number of values written. Returns a negative value on
error.
</p>
<p><b>Notes:</b><br>
Memory name identifiers and pin addresses can be found in the <a
 href="#smi">shared
memory identifiers</a> table. When writing to a shared memory,
startAddr refers to the shared memory's address
space. When writing to a shared register or shared FIFO, startAddr
refers to the address of the pin to write. <br><br>
An array write operation on a FIFO will not cause the address
counter in the hardware to increment; multiple writes on a FIFO will
return sequential values popped from the same FIFO.<br><br>
An array write operation on a shared memory will cause the
address counter in the hardware to increment.<br><br>
An array write operation on a register will cause the address
counter in the hardware to increment. Registers are given their own
address bank in the generated memory-map. This allows register values
in consecutive address locations to be written using an array write
operation.
</p>
</div>

<div>
<h3><a name="getMaxRetry">Get maximum number of retries</a></h3>
<div class="tt">
unsigned int [hwinst]_getMaxRetry()
</div>
<p>
<b>Returns:</b><br>
Returns an unsigned int that represents the number of retries polling
driver will make before returning an error value. <br>
</p>
<p><b>Notes:</b><br>
Polling drivers are used in certain asynchronous peripherals, please
  refer to <a href="#asyncdrv">Configuring drivers for asynchronous
    operation</a> for more information.
</p>
</div>

<div>
<h3><a name="setMaxRetry">Set maximum number of retries</a></h3>
<div class="tt">
void [hwinst]_setMaxRetry(<br>
&nbsp;&nbsp;&nbsp; unsigned int val)
</div>
<p>
<b>Parameters:</b><br>
<code>valBuf</code> - The number of times non-polling drivers should
retry before returning an error.
</p>
<p><b>Notes:</b><br>
Polling drivers are used in certain asynchronous peripherals, please
  refer to <a href="#asyncdrv">Configuring drivers for asynchronous
    operation</a> for more information.
</p>
</div>

<div>
<h3><a name="flushReadFIFO">Flush read FIFO</a></h3>
<div class="tt">
void [hwinst]_flushReadFIFO()
</div>
<p><b>Notes:</b><br>
  When polling drivers are used, time-outs can occur if the hardware
  peripheral does not respond to requests for the processor in a timely
  manner. After a programmable  number of time-outs, the polling drivers will
  give up and return an error condition. If however the hardware
  peripheral responds after this time-out has occured, there will be
  data left in the Read-FIFO that connects the processor with the
  peripheral. It is necessary to flush the FIFO using this command.
  Please refer to <a href="#asyncdrv">Configuring drivers for asynchronous
  operation</a> for more information on polling drivers.
</p>
</div>


</div>

<h2><a name="examples">Examples</a></h2>
<div>
<h3><a name="Control">Accessing to-register: Control </a></h3>
<div class="boxed">
<h4>Single-word writes</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Write([HWINST]_CONTROL, [HWINST]_CONTROL_DIN, val);<br>
</div>
<div>Write data stored in the variable val to the register Control. A negative status value is returned when an error occurs. See also: <a href="#Write">Write</a></div>
</div>
<div class="boxed">
<h4>Single-word reads</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Read([HWINST]_CONTROL, [HWINST]_CONTROL_DOUT, &val);<br>
</div>
<div>Read data stored in the register Control. A negative status value is returned when an error occurs. See also: <a href="#Read">Read</a></div>
</div>
<h3><a name="NAvg">Accessing to-register: NAvg </a></h3>
<div class="boxed">
<h4>Single-word writes</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Write([HWINST]_NAVG, [HWINST]_NAVG_DIN, val);<br>
</div>
<div>Write data stored in the variable val to the register NAvg. A negative status value is returned when an error occurs. See also: <a href="#Write">Write</a></div>
</div>
<div class="boxed">
<h4>Single-word reads</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Read([HWINST]_NAVG, [HWINST]_NAVG_DOUT, &val);<br>
</div>
<div>Read data stored in the register NAvg. A negative status value is returned when an error occurs. See also: <a href="#Read">Read</a></div>
</div>
<h3><a name="NetSamples">Accessing to-register: NetSamples </a></h3>
<div class="boxed">
<h4>Single-word writes</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Write([HWINST]_NETSAMPLES, [HWINST]_NETSAMPLES_DIN, val);<br>
</div>
<div>Write data stored in the variable val to the register NetSamples. A negative status value is returned when an error occurs. See also: <a href="#Write">Write</a></div>
</div>
<div class="boxed">
<h4>Single-word reads</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Read([HWINST]_NETSAMPLES, [HWINST]_NETSAMPLES_DOUT, &val);<br>
</div>
<div>Read data stored in the register NetSamples. A negative status value is returned when an error occurs. See also: <a href="#Read">Read</a></div>
</div>
<h3><a name="TriggerLevel">Accessing to-register: TriggerLevel </a></h3>
<div class="boxed">
<h4>Single-word writes</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Write([HWINST]_TRIGGERLEVEL, [HWINST]_TRIGGERLEVEL_DIN, val);<br>
</div>
<div>Write data stored in the variable val to the register TriggerLevel. A negative status value is returned when an error occurs. See also: <a href="#Write">Write</a></div>
</div>
<div class="boxed">
<h4>Single-word reads</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Read([HWINST]_TRIGGERLEVEL, [HWINST]_TRIGGERLEVEL_DOUT, &val);<br>
</div>
<div>Read data stored in the register TriggerLevel. A negative status value is returned when an error occurs. See also: <a href="#Read">Read</a></div>
</div>
<h3><a name="NCoadd">Accessing to-register: NCoadd </a></h3>
<div class="boxed">
<h4>Single-word writes</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Write([HWINST]_NCOADD, [HWINST]_NCOADD_DIN, val);<br>
</div>
<div>Write data stored in the variable val to the register NCoadd. A negative status value is returned when an error occurs. See also: <a href="#Write">Write</a></div>
</div>
<div class="boxed">
<h4>Single-word reads</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
val = 1;<br>
status=[hwinst]_Read([HWINST]_NCOADD, [HWINST]_NCOADD_DOUT, &val);<br>
</div>
<div>Read data stored in the register NCoadd. A negative status value is returned when an error occurs. See also: <a href="#Read">Read</a></div>
</div>
<h3><a name="SrcSignal">Accessing from-FIFO: SrcSignal </a></h3>
<div class="boxed">
<h4>Single-word reads</h4>
<div class="tt">
unsigned int val;<br>
unsigned int status;<br>
status=[hwinst]_Read([HWINST]_SRCSIGNAL, [HWINST]_SRCSIGNAL_DOUT, &val);<br>
</div>
<div>Read data stored in the FIFO SrcSignal into the variable val. A negative status value is returned when an error occurs. See also: <a href="#Read">Read</a></div>
</div>
<div class="boxed">
<h4>Multi-word read</h4>
<div class="tt">
unsigned int buf[512];<br>
unsigned int status;<br>
status=[hwinst]_ArrayRead([HWINST]_SRCSIGNAL, [HWINST]_SRCSIGNAL_DOUT, 512, &buf);<br>
</div>
<div>Read data stored in the FIFO SrcSignal into the variable buf. A negative status value is returned when an error occurs. If the array write operation suceeded, the number of words read from the FIFO will be returned instead.See also: <a href="#ArrayRead">ArrayRead</a></div>
</div>
<div class="boxed">
<h4>Accessing control signals of a FIFO</h4>
<div class="tt">
status=[hwinst]_Read([HWINST]_SRCSIGNAL, [HWINST]_SRCSIGNAL_EMPTY, &val);<br>
</div>
<div>Returns 1 in the variable val if the FIFO is empty, 0 otherwise.</div><br>
<div class="tt">
status=[hwinst]_Read([HWINST]_SRCSIGNAL, [HWINST]_SRCSIGNAL_PERCENTFULL, &val);<br>
</div>
<div>The SrcSignal FIFO is 512-words deep, with a percentfull control pin that is 9-bits wide. If the FIFO is not empty, a percentfull value of n means that the FIFO has n+1 item of data. (n>=0)</div><br>
<div class="tt">
status=[hwinst]_Write([HWINST]_SRCSIGNAL, [HWINST]_SRCSIGNAL_RST, val);<br>
</div>
<div>The FIFO can be reset by writing a value of 1 to rst.</div>
<div>See also: <a href="#Read">Read</a> <a href="#Write">Write</a></div></div>
</div>

<h6>
<center>Generated by Xilinx System Generator</center>
</h6>
</body>
</html>




