<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ntallen.20100519134237.1502"><vh>@chapters</vh></v>
<v t="ntallen.20100519134237.1501" a="E"><vh>Syscon USB</vh>
<v t="ntallen.20100601150619.1289"><vh>Todo</vh>
<v t="ntallen.20100805085605.1308"><vh>Diagnose Slowness</vh></v>
<v t="ntallen.20100805085605.1309"><vh>Implement timeout in subbusd</vh></v>
<v t="ntallen.20100805085605.1305"><vh>Indexer Features</vh>
<v t="ntallen.20100805085605.1307"><vh>Interrupts</vh>
<v t="ntallen.20100816115707.1311"><vh>API: subbuslib</vh></v>
<v t="ntallen.20100816115707.1312"><vh>Library implementation</vh></v>
<v t="ntallen.20100816115707.1313"><vh>subbusd implementation</vh>
<v t="ntallen.20100816115707.1314"><vh>USB</vh>
<v t="ntallen.20100816115707.1316"><vh>subbusd</vh></v>
<v t="ntallen.20100816115707.1317"><vh>syscon_usb</vh></v>
<v t="ntallen.20100816115707.1318"><vh>DACS</vh></v>
</v>
<v t="ntallen.20100816115707.1315"><vh>Syscon104</vh></v>
</v>
</v>
</v>
<v t="ntallen.20100827154528.1331"><vh>subbusd (here for visibility)</vh></v>
<v t="ntallen.20100907120439.1333"><vh>syscon_usb</vh></v>
</v>
<v t="ntallen.20100520123955.1247" a="E"><vh>Development Issues</vh>
<v t="ntallen.20100519134237.1503"><vh>12.1 Upgrade</vh></v>
<v t="ntallen.20100524120730.1249"><vh>ISE/XPS/SDK</vh>
<v t="ntallen.20100524120730.1250"><vh>Bit Stream</vh></v>
<v t="ntallen.20100524120730.1251"><vh>PROM</vh></v>
</v>
<v t="ntallen.20100524120730.1253"><vh>QNX</vh>
<v t="ntallen.20100602103230.1293"><vh>Library Strategy</vh></v>
<v t="ntallen.20100602103230.1294"><vh>Alternate Strategy</vh></v>
<v t="ntallen.20100602103230.1295"><vh>Driver? The winner!</vh></v>
<v t="ntallen.20100607110403.1299"><vh>sbtest</vh></v>
<v t="ntallen.20100610083250.1301"><vh>Simulation problem</vh></v>
</v>
<v t="ntallen.20101123111757.1383" a="E"><vh>Revision Control</vh>
<v t="ntallen.20101123111757.1384"><vh>HDS archive</vh></v>
<v t="ntallen.20101123111757.1385"><vh>SDK archive</vh></v>
<v t="ntallen.20101123111757.1386"><vh>ISE archive</vh></v>
</v>
</v>
<v t="ntallen.20100525090916.1257" a="E"><vh>Development Plan</vh>
<v t="ntallen.20100525090916.1259"><vh>Document Serial Protocol</vh></v>
<v t="ntallen.20100803111918.1303"><vh>IPC</vh></v>
<v t="ntallen.20100525090916.1258"><vh>Done: Update Syscon</vh>
<v t="ntallen.20100525090916.1263"><vh>Read Operation</vh></v>
<v t="ntallen.20100525090916.1264"><vh>Write Operation</vh></v>
<v t="ntallen.20100527162821.1273"><vh>Implemented syscon VHDL module</vh>
<v t="ntallen.20100527162821.1274"><vh>Done: Update XPS Proj</vh></v>
<v t="ntallen.20100527162821.1275"><vh>Update SDK Proj</vh></v>
<v t="ntallen.20100527162821.1278"><vh>Update ISE Proj</vh>
<v t="ntallen.20100527162821.1277"><vh>Done: Create new top-level VHDL</vh></v>
<v t="ntallen.20100527162821.1279"><vh>Bring in syscon, indexer</vh></v>
<v t="ntallen.20100528083113.1287"><vh>Add reset pin to ctrl bus</vh></v>
<v t="ntallen.20100527162821.1276"><vh>Update ucf</vh></v>
</v>
</v>
</v>
<v t="ntallen.20100525090916.1260"><vh>Done: Implement Subbus Library</vh></v>
<v t="ntallen.20101102122701.1375"><vh>Implement Subbus/Syscon Library</vh></v>
<v t="ntallen.20100525090916.1261"><vh>Indexer: Simulated</vh></v>
<v t="ntallen.20100525090916.1262"><vh>A/D VHDL: Simulated</vh>
<v t="ntallen.20101013150328.1339"><vh>Convert Clock</vh></v>
<v t="ntallen.20101013150328.1340"><vh>A/D =&gt; RAM</vh></v>
<v t="ntallen.20101013150328.1341"><vh>RAM =&gt; Front End</vh></v>
<v t="ntallen.20101013150328.1342"><vh>Subbus RW</vh></v>
<v t="ntallen.20101013150328.1343"><vh>RAM Configuration</vh>
<v t="ntallen.20101014082117.1355"><vh>Simply Dual-ported RAM</vh></v>
<v t="ntallen.20101014082117.1357"><vh>ana_ram</vh></v>
</v>
<v t="ntallen.20101013150328.1344"><vh>Basic Operation</vh></v>
<v t="ntallen.20101013150328.1345"><vh>Enhanced Operations</vh>
<v t="ntallen.20101013150328.1346"><vh>Configuration Readback</vh></v>
</v>
<v t="ntallen.20101019142341.1359"><vh>Design Hierarchy</vh>
<v t="ntallen.20101022104642.1372"><vh>ana_subbus</vh></v>
<v t="ntallen.20101019142341.1363"><vh>ana_ram</vh></v>
<v t="ntallen.20101022104642.1371"><vh>ana_hwside</vh>
<v t="ntallen.20101019142341.1364"><vh>ana_acquire</vh></v>
<v t="ntallen.20101019142341.1362"><vh>ana_s16</vh></v>
<v t="ntallen.20101019142341.1360"><vh>ana_s5</vh>
<v t="ntallen.20101019142341.1361"><vh>ana_s5s</vh></v>
</v>
</v>
</v>
</v>
<v t="ntallen.20100920151402.1335"><vh>Digio VHDL: Simulated</vh>
<v t="ntallen.20100920151402.1336"><vh>Basic Specs</vh></v>
</v>
<v t="ntallen.20101102122701.1376"><vh>D/A VHDL</vh></v>
<v t="ntallen.20101102122701.1377" a="E"><vh>Syscon Features</vh>
<v t="ntallen.20101102122701.1378"><vh>Tick</vh></v>
</v>
</v>
<v t="ntallen.20100823102718.1327" a="E"><vh>Documentation</vh>
<v t="ntallen.20100525090916.1259"></v>
<v t="ntallen.20100824101804.1329"><vh>Document API</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ntallen.20100519134237.1501">@nocolor
</t>
<t tx="ntallen.20100519134237.1502"></t>
<t tx="ntallen.20100519134237.1503">Copied Syscon_rC from K

Performed the following steps several time (with clean copies from K)
Each time, I copied IP from the 11.1 distribution into the 12.1
Copying the old clock_generator 3.01.a did not work, but I just changed the
version to 4.00.a, since the ports never changed...

Opened in ISE 12.1 (upgraded)
Opened system.xmp (requires upgrade...)
  upgrading: microblaze, mdm
  upgrading xps_epc
  clock_generator can be updated from 3.01.a to 4.00.a (incompatible)
    CLK_IN sys_clk_s
    CLKOUT0 clk_60_0000MHz
    RST net_gnd
    LOCKED Dcm_all_locked
    Done
    
  cpu driver update 1.12.a to 1.12.b
  incompatible driver updates for bram, gpio and uartlite
    not done...

Tried to run "implement design"
  </t>
<t tx="ntallen.20100520123955.1247"></t>
<t tx="ntallen.20100524120730.1249">Xilinx provides multiple GUI frameworks for developing using processors.
ISE provides the most control over synthesis and routing.
XPS is a more high-level tool for piecing together IP
SDK is for software and can be invoked from either ISE or XPS.

It is possible to do entire designs in XPS/SDK. When working with a lot of VHDL, it may be easier to use ISE, including the XPS project as one component. That is the current strategy for this project. Hence we need to use all three GUI frameworks.

The ISE project is the root. (Syscon_rC)
The XPS project is found in the "system" subdirectory. XPS should be invoked from ISE by opening system.xmp, not directly.
SDK can be invoked directly or from either XPS or ISE. The SDK projects are under system/SDK.

</t>
<t tx="ntallen.20100524120730.1250">ISE will generate the bitstream for the FPGA. For this design, we expect all the software to bit within BRAM, and as such, initialization of the software can be done with a simple PROM initialization.

To include the program in the bitstream, we apparently need to create a software project in XPS. These seems counterintuitive as Xilinx has been steadily moving us away from XPS and toward the SDK for all software. As it happens, the only thing we need to do in XPS is to create an elf-only software project that points to the .elf file we want to include, and mark that project for inclusion in the bitstream. We don't need to generate the bitstream in XPS, just make that connection. (This is also odd: we don't use XPS to generate the bitstream or the software, but that's still the place we have to go to connect the two, even when the top level design is in ISE.)

Once the connection is made, the "Generate Programming File" option in ISE will create system_download.bit, which differs from system.bit in that it includes the software.
</t>
<t tx="ntallen.20100524120730.1251">We are using an SPI PROM to initialize the FPGA. The configuration is detailed in
http://www.xilinx.com/support/documentation/application_notes/xapp974.pdf

We are using the Indirect in-system programming (ISP) approach.

Note that the FTDI USB interface we are using also has its own connection to the SPI PROM, so we have the option to program it using iMPACT through the FPGA, or using FTDI's program and programming via USB.

To program the PROM, we need to reformat the bit file. The app note lists the command:
    promgen -spi -p mcs -o spi_prom.mcs -s 8192 -u 0 dacs_download.bit

In iMPACT, need to added SPI PROM to the design. The part on the FTDI board is M25P20.</t>
<t tx="ntallen.20100524120730.1253">The DLP board uses the FTDI FT2232D (0x0403,0x6010), but it is reportedly supported
by the devc-serusb driver, which is listed as supporting FT8U232AM (0x0403,0x6001)

I will try specifying the device ID on the devc-serusb command line

Apparently what I need is:
    /sbin/devc-serusb -d vid=0x0403,did=0x6010,module=ftdi

Some instability on removal, but insertion seemed to work fine.
Devices /dev/serusb1 and /dev/serusb2 show up.
</t>
<t tx="ntallen.20100525090916.1257"></t>
<t tx="ntallen.20100525090916.1258">I'm inclined to review the code for read and write and consider implementing some of it in VHDL.
The read logic is faulty, since it resets EXPRD before reading in the data (which is not latched in hardware)</t>
<t tx="ntallen.20100525090916.1259">&lt;hex16&gt; : [0-9A-F]{4}
&lt;addr&gt; : &lt;hex16&gt;
&lt;data&gt; : &lt;hex16&gt;
&lt;cmdline&gt; : &lt;cmd&gt; '\n'
&lt;bit&gt; : '0' | '1'
&lt;cmd&gt; :
    R &lt;addr&gt;    // Read: response codes: RrE
    W &lt;addr&gt; : &lt;data&gt;  // Write: response codes: WwE
    C &lt;bit&gt;    // CMDENBL: response codes: CE
    S &lt;bit&gt;    // CMDSTRB: response codes: SE
    V          // Board Revision: response codes VE
    B          // Board Logical Reset: response: 0? ###
    I &lt;digit&gt; : &lt;addr&gt; // Define and enable Interrupt: response: i &lt;digit&gt;
    I &lt;digit&gt;  // Undefine and disable Interrupt: response: i &lt;digit&gt;
    ''         // NOP: response code: 0
    D          // Read switches: response: D&lt;data&gt; | E&lt;digit&gt; (no switches)
    F &lt;data&gt;   // Set failure: response: F | E
    F          // Read failure: response F &lt;data&gt; | E
    T          // Tick to reset 2-minute timeout: No response

Responses:
    R &lt;data&gt; '\n'  // Read data with acknowledge asserted
    r &lt;data&gt; '\n'  // Read data without acknowledge asserted
    W '\n'         // Write with acknowledge
    w '\n'         // Write without acknowledge
    S &lt;bit&gt; '\n'   // CMDSTRB value
    C &lt;bit&gt; '\n'   // CMDENBL value
    V &lt;version&gt; '\n' // Version string
    I &lt;data&gt; '\n'  // Interrupt string
    i &lt;digit&gt; '\n' // Acknowledge Interrupt config command
    0 '\n'         // NOP
    D &lt;data&gt; '\n'  // Switch data
    E &lt;digit&gt; '\n' // Error--not obviously associated with a specific request
    F &lt;data&gt; '\n'  // Failure status

B - Board Logical Reset: issue hardware reset to syscon, disable all interrupts.
    Does *not* reset the two-minute timer. (that's what "tick" does.) The reason for
    making the distinction is that the board reset will be issued when subbusd
    starts up, whereas tick will be issued by the actual data acquisition
    functions, indicating that the entire instrument is up and running. There
    is a lot that can go wrong between those two events, including spontaneous
    reboots, and we don't want the startup of subbusd to prematurely indicate
    that all is well.</t>
<t tx="ntallen.20100525090916.1260"></t>
<t tx="ntallen.20100525090916.1261"></t>
<t tx="ntallen.20100525090916.1262"></t>
<t tx="ntallen.20100525090916.1263">Make sure data bus is set for input
Set EXPADDR
Set EXPRD
&lt;wait for 1 usec&gt;&lt;could be a hardware test&gt;
Record value of EXPDATA and EXPACK
Reset EXPRD</t>
<t tx="ntallen.20100525090916.1264">Set EXPDATA direction to output
Set EXPADDR
Set EXPDATA
Set EXPWR
&lt;wait for 1usec&gt;&lt;could be hardware timer&gt;
Record value of EXPACK
Reset EXPWR
Reset EXPDATA direction to input
</t>
<t tx="ntallen.20100527162821.1273"></t>
<t tx="ntallen.20100527162821.1274">Reduced the number of GPIO instantiations by combining control and status bits.</t>
<t tx="ntallen.20100527162821.1275">Rewrite read/write operations to use the control and status ports and wait on the Done bit.
</t>
<t tx="ntallen.20100527162821.1276"></t>
<t tx="ntallen.20100527162821.1277"></t>
<t tx="ntallen.20100527162821.1278"></t>
<t tx="ntallen.20100527162821.1279">Brought in syscon_arch.vhd from HDS. Tried several ways to add to project. I want my vhdl to go in a subdirectory so it's separated from the mess of files in the root. "Add Copy of source file" does not allow you to say where you want to copy the source file. The approach that seems to work is to manually copy the source file into the vhdl directory, and then "Add source file" to link it into the project.

</t>
<t tx="ntallen.20100528083113.1287">and propogate through syscon and dacs and the subbus code
This could be handled via the processor reset: that's a discussion we need to have.

</t>
<t tx="ntallen.20100601150619.1289"></t>
<t tx="ntallen.20100602103230.1293">Shared objects:  oooo!

Original implementation loaded the single library that happened to be there, and then could query it to figure out what it was.

This approach might be more like asking for a particular library, perhaps by command-line option, and supporting multiple libraries.

Default behavior should be to load a single library, and perhaps by command-line option, and have the usual functions work

    driver
        Attempt to load some compile-time set of drivers, accepting the first found
    driver -s &lt;name&gt;
        Load the specified driver as the primary

After that, could provide APIs for loading multiple drivers

To support multiple drivers, we can't use the same function names in each driver, or they will be overwritten or otherwise conflicted.</t>
<t tx="ntallen.20100602103230.1294">Create apps linked separately against one or the other. Either:
    -l subbus
or
    -l subbus-usb

The executables could be segregated by hardware or by name

An alternate flavor of the subbus-usb library could use different names for the interface functions, which would allow for linking both into the same app. That would most likely be implemented by (optional) macros that recast the function names, so by recompiling, an app could use the same names, but access the alternate library.</t>
<t tx="ntallen.20100602103230.1295">I probably need a driver to arbitrate access to the serial device, though I can try to get away with the existing subbus library's arbitration scheme.

First implemented driver to arbitrate access to the serial device, but it also helps solve the interrupt problem clearly and also makes the linking of applications unambiguous without playing games. There is only one libsubbus which communicates with the subbus driver. There can be multiple subbus drivers (and will be at least two), but any application that addresses the subbus will be able to operate using either without recompilation.
</t>
<t tx="ntallen.20100607110403.1299">Currently I can control cmdenbl and direction, which suggests that addresses are working,
but I always read back zeros. Changing cmdenbl should produce a 0x8000 from the channel status

Driving in zero or out zero produces a change in direction, but driving out a non-zero
amount has not produced steps, leading me to believe the data value is coming through as zeros

Routing output data &lt;0&gt; to a pin to see if it is coming through
Then may try separating input and output into separate ports

output data bus bit order was wrong. Should have been [15:0], but was [0:15]

Input data is still not registering.

subbus_data_i (between system and syscon) shows non-zero data during ExpRd. It continues to the end of RdEn unless ExpAck is asserted (read_ack( 0, &amp;data ))
</t>
<t tx="ntallen.20100610083250.1301">Unexpected SEH</t>
<t tx="ntallen.20100803111918.1303">Four components:
    subbus_usb library
    subbusd driver
    serusb driver
    syscon_subbus

subbus_usb communicates with subbusd via IO_MSG messages:
    These have a standard _io_msg hdr with type _IO_MSG
    combine_len 0
    mgrid SUBBUSD_MGRID
    subtype 0
    Sent via MsgSend or MsgSendv

subbusd communicates with serusb driver via read/write
serusb communicates with syscon_subbus via USB
</t>
<t tx="ntallen.20100805085605.1305"></t>
<t tx="ntallen.20100805085605.1307">Need to figure out the whole architecture.
Now that I have a dedicated driver, implementation on the QNX side should be
pretty straightforward. Interrupt should cause syscon to issue an appropriate
"I\d\n" string.

QNX6 indexer code includes all the interrupt processing stuff that had been extracted
into intserv. I would like indexer driver to work on either subbus architecture, so
that means changes need to be pushed to the driver:
    Create subbusd for syscon104
        Copy subbusd, then copy in the libsubbus stuff to address the hardware
    Promote libsubbus_usb to be libsubbus, i.e. all programs will use it
    Incorporate intserv capabilities in both drivers

Old architecture:
    we did not know which boards would be plugged in when the interrupt circuit was laid out
    Any board that could produce an interrupt (indexer, mainly) could be programmed to:
        a) assert the interrupt
        b) respond on one of four INTA addresses
        c) respond by driving its status on one of 8 data bits
    The interrupt driver would:
        configure each board, given knowledge of the physical region
        attach the single subbus hardware interrupt
        respond to the interrupt with reads from any of the four INTA addresses in use
        check which bits request service and map those back to original requestor
    The regions were a way to support subbus expansion via a repeater where the
    strategy of driving single lines on the databus would break down. The software
    configuring the board had to know what region the board was in physically.
DACS architecture:
    we know going in exactly which components may request an interrupt, so we
    can wire them directly into the acknowledge without configuration.
    Move acknowledge responsibility into uBlaze. uBlaze will have a table
    of bits and base addresses. When service is requested, it will read
    from INTA address and report: IXXXX where XXXX is the board base address.
    Alternately, it could report IB where B is the bit number and we could
    pass the responsibility back to subbusd, but that would mean subbusd is
    tightly coupled with a specific FPGA configuration. Requiring the uBlaze
    code to be tightly coupled with the circuit makes more sense.
</t>
<t tx="ntallen.20100805085605.1308">Add another IO port to expose timing. 4 bits?
Show:
    start of receive to end of send
    start of addressing HW
    end of addressing HW

Might need to do the same with the parallel port on the PC end.
</t>
<t tx="ntallen.20100805085605.1309"></t>
<t tx="ntallen.20100816115707.1311">This API was actually handled by a separate driver in QNX4 known as IntSrv. Part of the idea was to support both "Experiment Interrupts" on the subbus and other interrupts to the processor itself, allowing unprivileged processes to receive proxies when interrupts arrived. I don't know if we'll need that capability going forward, but I plan to add the ExpInt stuff to the new subbus lib (currently named subbus_usb)

These were previously called "IntSrv_Int_attach/detach" but I will change the prefix.

int Subbus_Int_attach( char *cardID, unsigned short address,
    						int region, struct sigevent event );

  cardID is a application-selected name for the function that is being addressed.
  address is the subbus base address for the specified function
  region is reserved for a mechanism to support interrupts in disjoint bus segments.
    Should be zero for subbus_usb, may be non-zero for syscon104
    Wait, no, the application (e.g. idx64) should not need to know
    what library is in use, so this value should be compatible.
  event specifies how the application wants to be notified
  
  Returns 0 on success
  Errors include interrupt already attached (but may check...)

int Subbus_Int_detach( char *cardID );
</t>
<t tx="ntallen.20100816115707.1312">int Subbus_Int_attach( char *cardID, unsigned short address,
    						int region, struct sigevent event );
int Subbus_Int_detach( char *cardID );

The library will package these requests and forward them to subbusd. The library is not responsible for handling the resulting events, as they need to be worked into the applications event loop.
</t>
<t tx="ntallen.20100816115707.1313">The interrupt implementation in subbusd is necessarily hardware dependent.
I can reuse the bookkeeping code from QNX4/intserv</t>
<t tx="ntallen.20100816115707.1314"></t>
<t tx="ntallen.20100816115707.1315">The implementation here will match the existing implementation in intserv.</t>
<t tx="ntallen.20100816115707.1316">int Subbus_Int_attach( char *cardID, unsigned short address, int region, struct sigevent event );
int Subbus_Int_detach( char *cardID );

For USB, subbusd will maintain some bookkeeping to associate a specific interrupt code with a specific event, and will send the syscon_usb information to configure the interrupt. When the associated "I" code is returned, subbusd will trigger the specified event.

(Since subbusd_usb is tightly coupled with syscon_usb, we don't need to worry too much about making the protocol future-proof, anticipating all possible hardware implementations. For now, I think it should be sufficient
to specify that I want to configure the board at address A with interrupt code N.)

Functions required:
    configure function at address A to respond with interrupt code N
    disable interrupt N
    disable all interrupts
</t>
<t tx="ntallen.20100816115707.1317">Functions required:
    configure function at address A to respond with interrupt code N
    disable interrupt N
    disable all interrupts

The software running on syscon_usb will know what functions are defined.
"Interrupts" will actually be implemented via polling, since that is how
the software runs anyway. All functions that have interrupt capability
will have their interrupt status lines connected to a single interrupt
status register. The bits of the status register are or-ed together
to provide a single bit to signal interrupt activity to the processor.

On each poll cycle, the interrupt status bit will be read.
If it is non-zero, an INTA cycle will be produced, and the returned
value will be the interrupt status register. An "I" code will be
transmitted on the USB for each active bit in the status register.

The software will have
a table to map addresses to status bits. When a function is enabled,
the hardware will be programmed (as in the description of idx64
interrupt configuration) although the bit selection will not be
configurable, since it will be firm-wired. The hardware will still
respond to the specified INTA address (which should be 0x40 for all
functions--doesn't even need to be configurable, really)
</t>
<t tx="ntallen.20100816115707.1318">In the firmware:
    DACS:
        System:
            +Need ExpIntr Bit input: added to status
        Syscon:
            +Collect BdIntr outputs from boards, or them and deliver expintr bit as output
            +Respond to INTA by writing expintr vector
            +Provide INTA output
            +extend test bench
                +Test that reading from 0x40 generates INTA and Data_i shows BdIntr values
                +Test that non-zero value on BdIntr generates non-zero value on ExpIntr
            +Need to provide N_BOARDS generic and make ExpAck a vector
        extend test bench
    gxidx:
        +Add BdIntr output
        +Add INTA input, pass through to channels
        +extend test bench
        decode:
            +Add Interrupt enable logic
            +Add BdIntr output
            +Add Ireq Input vector
            +Add logic mapping Ireq vector to BdIntr
            +Eliminate INTA output/decoding
            +extend test bench
            +Make base address GENERIC
        channel:
            +Add INTA input
            +Add Ireq output
            +Add Running output
            +extend test bench
        Intr:
            Write test bench: HDS doesn't like that--do it at channel level instead</t>
<t tx="ntallen.20100823102718.1327"></t>
<t tx="ntallen.20100824101804.1329">Generating doxygen documentation in source code.</t>
<t tx="ntallen.20100827154528.1331">done: Make sure subbusd/serusb returns SBS_ACK and SBS_NACK status
done: Interrupt functions should have a way to return to client on error without enqueuing command to serusb.
done: Need to implement interrupt attach/detach functions
done: Need to implement timeout and error returns
    timer_create() to create a timer and associate it with a pulse</t>
<t tx="ntallen.20100907120439.1333">Implement all of the protocol defined in serusb/README
Done: Get subbus source into subversion
</t>
<t tx="ntallen.20100920151402.1335"></t>
<t tx="ntallen.20100920151402.1336">120 direction-selectable I/O channels in 15 banks of 8
  Half go to connector board, half to power board
  One 8-bit bank is split between the two boards, but still has
  a single direction select.
8 bidirectional channels to connector board
8 bidirectional channels to the power board

Indexer I/O needs to be carved out of this space

Looks like one "board" of two "connectors" in the Digio64 nomenclature
would do the trick, leaving 3 ports for indexer usage.

DIG_BASE_ADDR 0x800
DIG_CONN_OFFSET 0x20
DIG_CONN_PER_BD 2
DIG_BD_NUM 0
DIG_RESET_OFFSET 0x18

DIGIO_BASE_ADDR DIG_BASE_ADDR + (DIG_CONN_OFFSET*DIG_CONN_PER_BD*DIG_BD_NUM)


</t>
<t tx="ntallen.20101013150328.1339">Upper limit is determined by the time to transfer the data out of the converters.</t>
<t tx="ntallen.20101013150328.1340"></t>
<t tx="ntallen.20101013150328.1341"></t>
<t tx="ntallen.20101013150328.1342"></t>
<t tx="ntallen.20101013150328.1343">BRAM comes in 9Kb blocks which can be configured in various ways:
    As a simple memory, 512x16 where we provide all arbitration
    As a full dual-ported RAM 512x16 where we provide arbitration on the hardware side
    As a simple dual-ported RAM 512x16 or 256x32.
      We would need two 9kb BRAMs, but no additional arbitration.
      </t>
<t tx="ntallen.20101013150328.1344">There are 128 16-bit analog inputs.
Most recently recorded values for channel i can be read from subbus address:
    BASE_ADDRESS + 2*i
BASE_ADDRESS is probably 0x0C00, so read addresses run from 0x0C00 to 0x0CFE

The front end is configured with a 5-bit code. This is programmed by
writing to the same address as the input channel.</t>
<t tx="ntallen.20101013150328.1345"></t>
<t tx="ntallen.20101013150328.1346">For each channel, i, a second 16-bit word can be read from:
    BASE_ADDRESS + 2*i + 1
immediately after reading a channel.
This word includes the 5 bits of configuration and 11 bits of
frame counter. This value is latched when the channel is
read, so providing the next read is from the config address,
it will be correctly mated with the data. The address could
be checked against the latched address to make sure the
value matches.

The configuration value will be read back from the front-end
hardware so as to guarantee that we are reporting the
configuration that was actually in use when the data was
converted.
</t>
<t tx="ntallen.20101014082117.1355">Storage of A/D data (16 bits) and configuration readback (5 bits)
requires a total of 128 x 21 bits. This maps into a simple dual-
ported RAM at 256x32.

Storage of programmed configuration values (5 bits) requires
128x5 bits, which can map into lots of configurations, including
the simple dual-ported RAM at 256x32.

Reading the Spartan-6 BRAM data sheet, it appears that simultaneous
reads and writes to the same address are supported in SDP mode
providing the clocks are synchronous and the write mode is
READ_FIRST. The doc is slightly ambiguous because it defines
the SDP as having two ports with independent clocks, but then
says the collision rules are the same as for TDP, which supports
simultaneous reads when the clocks are synchronous. I guess
"independent" and "synchronous" are not mutually exclusive.</t>
<t tx="ntallen.20101014082117.1357">encapsulation of the RAMB8BWER primitive in SDP mode, 256 x 32

ENTITY ana_ram IS
  PORT (
    RD_ADDR : IN std_logic_vector(7 DOWNTO 0);
    WR_ADDR : IN std_logic_vector(7 DOWNTO 0);
    RD_DATA : OUT std_logic_vector(31 DOWNTO 0);
    WR_DATA : IN std_logic_vector(31 DOWNTO 0);
    WREN : IN std_ulogic;
    RDEN : IN std_ulogic;
    CLK : IN std_ulogic;
    RST : IN std_ulogic
  );
END ENTITY ana_ram;
</t>
<t tx="ntallen.20101019142341.1359">Using AD7687 in "Chain mode with busy indicator", Page 23 of the manual.
This requires that SDI and CNV are tied together. I will make that
association at the top level of this design.</t>
<t tx="ntallen.20101019142341.1360">Wrapper for ana_s5s state machine. Operates on the word level, so does not generate the CS output.
Note: whoever does generate the CS output must ensure the setup time requirements, specifically
 t3 = CS/ to SCK/ min 50 ns setup
 t7 = SCK to CS min 50 ns hold
</t>
<t tx="ntallen.20101019142341.1361">State machine for clocking out configuration bits and generating the configuration clock.</t>
<t tx="ntallen.20101019142341.1362">State machine for clocking in data from A/D. Like ana_s5s, operates on the word level.</t>
<t tx="ntallen.20101019142341.1363">Encapsulation of BRAM block for use in simple dual ported RAM mode.</t>
<t tx="ntallen.20101019142341.1364">State machine generating control signals to drive ana_s5, ana_s16.
      CLK    : IN     std_logic; 30 MHz max. S5.SCK is CLK/6. S16.SCK is CLK/2
      RST    : IN     std_logic; Synch active high
      RdyIn  : IN     std_ulogic; Intended as logical and of Rdy signals from s5 and s16
      SDI    : IN     std_ulogic_vector (1 DOWNTO 0); SDI signals from each bank of A/D converters
      Addr   : OUT    std_ulogic_vector (7 DOWNTO 0); Address for our side of the two RAM banks
      Conv   : OUT    std_ulogic; Convert signal to A/D converters
      NxtRow : OUT    std_ulogic_vector (2 DOWNTO 0); Address lines for the mux
      RdWrEn : OUT    std_ulogic;
      RdyOut : OUT    std_ulogic;
      S5WE   : OUT    std_ulogic_vector (1 DOWNTO 0); Write Enable for the two S5 state machines
      Start  : OUT    std_ulogic

NxtRow is so called because it represents the row of data that will
be retrieved during the next acquisition sequence. According to the
terminology in the AD7687 data sheet, acquisition comes after conversion,
and is the process of retrieving the converted value.

RdWrEn is an enable line that goes to both banks of RAM. It is the
read enable on the configuration RAM and write enable on the data
RAM.

RdyOut goes high when the acquisition sequence is completed. This was intended
as a signal for external synchronization, but in the current configuration,
it is simply a flag that the next conversion/acquisition sequence will start.

Start is a signal to S5 and S16 machines to begin their sequences (or continue
their sequences).</t>
<t tx="ntallen.20101022104642.1371">This component encapsulates all the hardware interface timing.

Copy data from cfg cache on RdWrEn
Set cfg cache from DO5 on S5WE</t>
<t tx="ntallen.20101022104642.1372"></t>
<t tx="ntallen.20101102122701.1375"></t>
<t tx="ntallen.20101102122701.1376"></t>
<t tx="ntallen.20101102122701.1377">Fail Lights/LEDs
I/O Switches
Tick tie in to Fail, CmdEnbl
</t>
<t tx="ntallen.20101102122701.1378">Two-second timeout should clear cmdenbl and ARM, which qualifies it
    In existing design, it is possible to set cmdenbl and then subsequently
    start ticking, which will enable cmdenbl output, or you can start
    ticking and then enable cmdenbl.
    DCCC takes advantage of this independence by setting cmdenbl independent
    of whether telemetry has started or not.
    
Two-minute timeout should light fail light (which can also be set manually)

Old behavior:
    Tick sets ARM
    ARM and cmdenbl_cmd produce CmdEnbl
    TwoSecond Timeout while ARMed
        produces Flt_CPU_Reset
        Clears ARM and CmdEnbl
        Subsequent tick will not reenable cmdenbl. An actual write to cmdenbl is required.
    Disarm command prevents Flt_CPU_Reset, disabled CmdEnbl, clears ARM

I will need a separate arm line in, plus some software logic. Will retain all of the below,
but require that Arm_in be true in order to recognize any ticks or produce reset.

I will not use a separate arm control line. I will count on CmdEnbl_cmd being reset before
a tick will be recognized, and will require a subsequent tick before CmdEnbl will be
asserted.

I will require that the software look monitor the TwoSecondTO bit of the status word
and clear CmdEnbl_cmd if it is observed. That will require the flight software to
explicitly set CmdEnbl before it will be recognized.

This does mean that a late tick could be recognized, but not before the reset is issued.
Even if it is recognized, cmdenbl will not be asserted without another explicit set.
</t>
<t tx="ntallen.20101123111757.1383">Due to the vagaries of the various tools involved, the source code
is separated into multiple modules under the arp-fpga subversion repository.</t>
<t tx="ntallen.20101123111757.1384">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/idx_fpga

This is tied into the HDL Designer Series software and represents the
VHDL code and graphical input formats (block diagrams, state machines)
within the HDS development environment.</t>
<t tx="ntallen.20101123111757.1385">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/fpga_sw/subbus

This is a project to be checked out into the XPS SDK:</t>
<t tx="ntallen.20101123111757.1386">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/DACS_V1_0_ISE

This is the necessary components of the ISE and XPS projects. The SDK project
needs to be set up separately.

Export Hardware project to SDK
In SDK: New Board Support Package:
    Standalone
    Set stdio to mdm
New Project from SVN
    https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/fpga_sw
    subbus
Edit project properties
    C/C++ General
      Paths and Properties
        Includes
          Fix up microblaze include path to match selection in BSP creation
        Library Paths
          Fix up microblaze library path to match selection in BSP creation

Back in XPS, double check path to executable.
</t>
</tnodes>
</leo_file>
