<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ntallen.20100519134237.1502"><vh>@chapters</vh></v>
<v t="ntallen.20100519134237.1501" a="E"><vh>Syscon USB</vh>
<v t="ntallen.20100601150619.1289"><vh>Todo</vh>
<v t="ntallen.20100805085605.1308"><vh>Diagnose Slowness</vh></v>
<v t="ntallen.20100805085605.1309"><vh>Implement timeout in subbusd</vh></v>
<v t="ntallen.20100805085605.1305"><vh>Indexer Features</vh>
<v t="ntallen.20100805085605.1307"><vh>Interrupts</vh>
<v t="ntallen.20100816115707.1311"><vh>API: subbuslib</vh></v>
<v t="ntallen.20100816115707.1312"><vh>Library implementation</vh></v>
<v t="ntallen.20100816115707.1313"><vh>subbusd implementation</vh>
<v t="ntallen.20100816115707.1314"><vh>USB</vh>
<v t="ntallen.20100816115707.1316"><vh>subbusd</vh></v>
<v t="ntallen.20100816115707.1317"><vh>syscon_usb</vh></v>
<v t="ntallen.20100816115707.1318"><vh>DACS</vh></v>
</v>
<v t="ntallen.20100816115707.1315"><vh>Syscon104</vh></v>
</v>
</v>
</v>
<v t="ntallen.20100827154528.1331"><vh>subbusd (here for visibility)</vh></v>
<v t="ntallen.20100907120439.1333"><vh>syscon_usb</vh></v>
</v>
<v t="ntallen.20100520123955.1247" a="E"><vh>Development Issues</vh>
<v t="ntallen.20100519134237.1503"><vh>12.1 Upgrade</vh></v>
<v t="ntallen.20100524120730.1249" a="E"><vh>ISE/XPS/SDK</vh>
<v t="ntallen.20100524120730.1250"><vh>Bit Stream</vh></v>
<v t="ntallen.20100524120730.1251"><vh>PROM</vh></v>
</v>
<v t="ntallen.20100524120730.1253"><vh>QNX</vh>
<v t="ntallen.20100602103230.1293"><vh>Library Strategy</vh></v>
<v t="ntallen.20100602103230.1294"><vh>Alternate Strategy</vh></v>
<v t="ntallen.20100602103230.1295"><vh>Driver? The winner!</vh></v>
<v t="ntallen.20100607110403.1299"><vh>sbtest</vh></v>
<v t="ntallen.20100610083250.1301"><vh>Simulation problem</vh></v>
</v>
<v t="ntallen.20101123111757.1383"><vh>Revision Control</vh>
<v t="ntallen.20101123111757.1384"><vh>HDS archive</vh></v>
<v t="ntallen.20101123111757.1385"><vh>SDK archive</vh></v>
<v t="ntallen.20101123111757.1386"><vh>ISE archive</vh></v>
</v>
<v t="ntallen.20101215085413.1391"><vh>12.3 Upgrade</vh>
<v t="ntallen.20101215085413.1392"><vh>ISE</vh></v>
<v t="ntallen.20101215085413.1393"><vh>XPS</vh></v>
<v t="ntallen.20101215085413.1394"><vh>SDK</vh></v>
</v>
</v>
<v t="ntallen.20100525090916.1257" a="E"><vh>Development Plan</vh>
<v t="ntallen.20100525090916.1259"><vh>Document Serial Protocol</vh>
<v t="ntallen.20110123092829.1413"><vh>Error Codes</vh></v>
</v>
<v t="ntallen.20100803111918.1303"><vh>IPC</vh></v>
<v t="ntallen.20101102122701.1377"><vh>Syscon Features</vh>
<v t="ntallen.20101102122701.1378"><vh>Tick</vh></v>
</v>
<v t="ntallen.20100525090916.1258"><vh>Done: Update Syscon</vh>
<v t="ntallen.20100525090916.1263"><vh>Read Operation</vh></v>
<v t="ntallen.20100525090916.1264"><vh>Write Operation</vh></v>
<v t="ntallen.20100527162821.1273"><vh>Implemented syscon VHDL module</vh>
<v t="ntallen.20100527162821.1274"><vh>Done: Update XPS Proj</vh></v>
<v t="ntallen.20100527162821.1275"><vh>Update SDK Proj</vh></v>
<v t="ntallen.20100527162821.1278"><vh>Update ISE Proj</vh>
<v t="ntallen.20100527162821.1277"><vh>Done: Create new top-level VHDL</vh></v>
<v t="ntallen.20100527162821.1279"><vh>Bring in syscon, indexer</vh></v>
<v t="ntallen.20100528083113.1287"><vh>Add reset pin to ctrl bus</vh></v>
<v t="ntallen.20100527162821.1276"><vh>Update ucf</vh></v>
</v>
</v>
</v>
<v t="ntallen.20100525090916.1260"><vh>Done: Implement Subbus Library</vh></v>
<v t="ntallen.20101102122701.1375"><vh>Implement Subbus/Syscon Library</vh></v>
<v t="ntallen.20100525090916.1261"><vh>Indexer: Simulated</vh></v>
<v t="ntallen.20100525090916.1262"><vh>A/D VHDL: Simulated</vh>
<v t="ntallen.20110331101033.1427"><vh>Rework 110331</vh></v>
<v t="ntallen.20101013150328.1339"><vh>Convert Clock</vh></v>
<v t="ntallen.20101013150328.1340"><vh>A/D =&gt; RAM</vh></v>
<v t="ntallen.20101013150328.1341"><vh>RAM =&gt; Front End</vh></v>
<v t="ntallen.20101013150328.1342"><vh>Subbus RW</vh></v>
<v t="ntallen.20101013150328.1343"><vh>RAM Configuration</vh>
<v t="ntallen.20101014082117.1355"><vh>Simple Dual-ported RAM</vh></v>
<v t="ntallen.20101014082117.1357"><vh>ana_ram</vh></v>
</v>
<v t="ntallen.20101013150328.1344"><vh>Basic Operation</vh></v>
<v t="ntallen.20101013150328.1345"><vh>Enhanced Operations</vh>
<v t="ntallen.20101013150328.1346"><vh>Configuration Readback</vh></v>
</v>
<v t="ntallen.20101019142341.1359"><vh>Design Hierarchy</vh>
<v t="ntallen.20110122074609.1411"><vh>ana_addr</vh></v>
<v t="ntallen.20101022104642.1372"><vh>ana_subbus</vh></v>
<v t="ntallen.20110118143100.1403"><vh>ana_data_ram</vh>
<v t="ntallen.20110118143100.1404"><vh>ana_data_rd</vh></v>
<v t="ntallen.20101019142341.1363"><vh>ana_ram</vh></v>
</v>
<v t="ntallen.20110118143100.1405"><vh>ana_cfg_ram</vh>
<v t="ntallen.20101019142341.1363"></v>
</v>
<v t="ntallen.20101022104642.1371"><vh>ana_hwside</vh>
<v t="ntallen.20101019142341.1364"><vh>ana_acquire</vh>
<v t="ntallen.20110118143100.1406"><vh>AI configuration and sub-muxing</vh></v>
</v>
<v t="ntallen.20101019142341.1362"><vh>ana_s16</vh></v>
<v t="ntallen.20101019142341.1360"><vh>ana_s5</vh>
<v t="ntallen.20101019142341.1361"><vh>ana_s5s</vh></v>
</v>
</v>
</v>
</v>
<v t="ntallen.20100920151402.1335"><vh>Digio VHDL: Simulated</vh>
<v t="ntallen.20100920151402.1336"><vh>Basic Specs</vh></v>
</v>
<v t="ntallen.20101102122701.1376"><vh>D/A VHDL</vh></v>
<v t="ntallen.20110203162516.1415"><vh>PTRH</vh>
<v t="ntallen.20110418174231.1430"><vh>I2C</vh></v>
<v t="ntallen.20110203162516.1416"><vh>SHT21</vh></v>
<v t="ntallen.20110203162516.1417"><vh>MS5607</vh></v>
<v t="ntallen.20110206160145.1421"><vh>Overall Sequence</vh></v>
<v t="ntallen.20110207112658.1424"><vh>Status Word</vh></v>
<v t="ntallen.20110419111719.1433"><vh>PTRH DPRAMS</vh></v>
<v t="ntallen.20111025151610.1437"><vh>I2C_SM</vh></v>
</v>
<v t="ntallen.20111024112337.1435"><vh>PTRH MUX</vh>
<v t="ntallen.20111114100408.1439"><vh>Register Map</vh></v>
<v t="ntallen.20111123115724.1441"><vh>Generics</vh></v>
</v>
<v t="ntallen.20110227134141.1425"><vh>Counters</vh></v>
<v t="ntallen.20110418174231.1429"><vh>VM: LTC4151</vh></v>
<v t="ntallen.20111212160628.1443"><vh>QCLI Serial Interface</vh>
<v t="ntallen.20111212160628.1444"><vh>Subbus Interface</vh>
<v t="ntallen.20111213091253.1453"><vh>Old Subbus Interface</vh></v>
<v t="ntallen.20111213091253.1451"><vh>Server Requirements</vh></v>
<v t="ntallen.20111213091253.1452"><vh>Programming Requirements</vh></v>
<v t="ntallen.20120104141216.1461"><vh>Verify (Read Block)</vh></v>
</v>
<v t="ntallen.20111212160628.1445"><vh>QCLI Interface</vh></v>
<v t="ntallen.20111212160628.1447"><vh>Engine Operation</vh>
<v t="ntallen.20111215085119.1458"><vh>Write to FIFO</vh></v>
<v t="ntallen.20111215085119.1457"><vh>Read FIFO</vh></v>
</v>
</v>
<v t="ntallen.20120816125014.1563" a="E"><vh>LK204-7T-1U Display</vh>
<v t="ntallen.20120816125014.1564" a="E"><vh>LK204 VHDL Driver</vh>
<v t="ntallen.20120910090627.1591"><vh>Hardware Features</vh></v>
<v t="ntallen.20120910090627.1592"><vh>Subbus Interface</vh></v>
<v t="ntallen.20120817130002.1569"><vh>Architecture</vh>
<v t="ntallen.20120817161609.1571"><vh>FIFO</vh></v>
<v t="ntallen.20120904164051.1587"><vh>LK204_I2C</vh></v>
<v t="ntallen.20120904164051.1588"><vh>LK204_SM</vh></v>
</v>
<v t="ntallen.20120823092853.1573"><vh>VHDL Alternatives</vh></v>
</v>
<v t="ntallen.20120816125014.1565"><vh>LK204 QNX Driver</vh></v>
</v>
<v t="ntallen.20120110154657.1467"><vh>DACS diagnostic generator</vh>
<v t="ntallen.20120111082754.1514"><vh>Zero Order generator</vh></v>
<v t="ntallen.20120110154657.1471"><vh>Organizational</vh>
<v t="ntallen.20120110154657.1468"><vh>VERSION</vh></v>
<v t="ntallen.20120110154657.1469"><vh>Experiment.config</vh></v>
<v t="ntallen.20120110154657.1476"><vh>types.tmc</vh></v>
<v t="ntallen.20120110154657.1470"><vh>$mnemonic.spec</vh></v>
<v t="ntallen.20120110154657.1472"><vh>interact</vh></v>
<v t="ntallen.20120110154657.1473"><vh>$mnemonic.doit</vh></v>
<v t="ntallen.20120110154657.1474"><vh>$mnemonic.tma</vh></v>
</v>
<v t="ntallen.20120110154657.1477"><vh>AI</vh>
<v t="ntallen.20120110154657.1482"><vh>Signal Defs</vh></v>
</v>
<v t="ntallen.20120110154657.1478"><vh>AO</vh>
<v t="ntallen.20120110154657.1483"><vh>Signal Defs</vh></v>
</v>
<v t="ntallen.20120110154657.1479"><vh>Counters</vh>
<v t="ntallen.20120110154657.1484"><vh>Signal Defs</vh></v>
</v>
<v t="ntallen.20120110154657.1480"><vh>DigIO</vh>
<v t="ntallen.20120110154657.1481"><vh>Processed Command</vh></v>
<v t="ntallen.20120110154657.1485"><vh>Unprocessed Command</vh></v>
<v t="ntallen.20120110154657.1486"><vh>Unaffiliated Status</vh></v>
<v t="ntallen.20120118103503.1551"><vh>First Pass</vh>
<v t="ntallen.20120118103503.1552"><vh>digio.tmc</vh></v>
<v t="ntallen.20120118103503.1553"><vh>digio_conv.tmc</vh></v>
<v t="ntallen.20120118103503.1554"><vh>digio.cmd</vh></v>
<v t="ntallen.20120118103503.1555"><vh>digio.tbl</vh></v>
<v t="ntallen.20120118103503.1556"><vh>digio.dccc</vh></v>
</v>
</v>
<v t="ntallen.20120111082754.1509"><vh>PTRHM</vh>
<v t="ntallen.20120111082754.1515"><vh>types.tmc</vh></v>
<v t="ntallen.20120111082754.1516"><vh>ptrh.tmc</vh></v>
<v t="ntallen.20120111082754.1520"><vh>ptrh_col.tmc</vh></v>
<v t="ntallen.20120111082754.1517"><vh>ptrh_conv.tmc</vh></v>
<v t="ntallen.20120111082754.1518"><vh>ptrh.tbl</vh></v>
<v t="ntallen.20120111082754.1519"><vh>spec</vh></v>
</v>
<v t="ntallen.20120111082754.1510"><vh>QCLI</vh>
<v t="ntallen.20120113132201.1535"><vh>wavesN.qcli</vh></v>
<v t="ntallen.20120113132201.1536"><vh>qcli.cmd</vh></v>
<v t="ntallen.20120113132201.1540"><vh>qcli.tmc</vh></v>
<v t="ntallen.20120113132201.1537"><vh>qclis.cmd</vh></v>
<v t="ntallen.20120113132201.1544"><vh>qcli_col.tmc</vh></v>
<v t="ntallen.20120113132201.1541"><vh>qcli_conv.tmc</vh></v>
<v t="ntallen.20120113132201.1542"><vh>qcli.tbl</vh></v>
<v t="ntallen.20120113132201.1543"><vh>interact</vh></v>
</v>
<v t="ntallen.20120111082754.1511"><vh>Indexer</vh></v>
<v t="ntallen.20120111082754.1512"><vh>Voltage Monitor</vh></v>
<v t="ntallen.20120111082754.1513"><vh>Syscon</vh></v>
<v t="ntallen.20120111082754.1505"><vh>NETS2</vh>
<v t="ntallen.20120111082754.1506"><vh>Affinity example</vh></v>
<v t="ntallen.20120111082754.1508"><vh>Command Model</vh></v>
</v>
</v>
</v>
<v t="ntallen.20100823102718.1327" a="E"><vh>Documentation</vh>
<v t="ntallen.20100525090916.1259"></v>
<v t="ntallen.20110118143100.1406"></v>
<v t="ntallen.20100824101804.1329"><vh>Document API</vh></v>
<v t="ntallen.20120109083521.1463"><vh>Laying out a new instrument</vh>
<v t="ntallen.20120109083521.1464"><vh>Digital Commands and Status</vh></v>
</v>
<v t="ntallen.20120824140516.1575"><vh>Interrupt Implementation</vh>
<v t="ntallen.20120824140516.1576"><vh>FPGA/VHDL: Card</vh></v>
<v t="ntallen.20120824140516.1577"><vh>FPGA/VHDL: Syscon</vh></v>
<v t="ntallen.20120824140516.1578"><vh>FPGA/CPU: subbus</vh></v>
<v t="ntallen.20120824140516.1579"><vh>Host/CPU: subbusd_serusb</vh></v>
<v t="ntallen.20120824140516.1580"><vh>Host/CPU: Card Driver</vh></v>
</v>
</v>
<v t="ntallen.20110115103957.1399"><vh>Revisions</vh>
<v t="ntallen.20110115103957.1400"><vh>DACS_V1_0_ISE</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ntallen.20100519134237.1501">@nocolor
</t>
<t tx="ntallen.20100519134237.1502"></t>
<t tx="ntallen.20100519134237.1503">Copied Syscon_rC from K

Performed the following steps several time (with clean copies from K)
Each time, I copied IP from the 11.1 distribution into the 12.1
Copying the old clock_generator 3.01.a did not work, but I just changed the
version to 4.00.a, since the ports never changed...

Opened in ISE 12.1 (upgraded)
Opened system.xmp (requires upgrade...)
  upgrading: microblaze, mdm
  upgrading xps_epc
  clock_generator can be updated from 3.01.a to 4.00.a (incompatible)
    CLK_IN sys_clk_s
    CLKOUT0 clk_60_0000MHz
    RST net_gnd
    LOCKED Dcm_all_locked
    Done
    
  cpu driver update 1.12.a to 1.12.b
  incompatible driver updates for bram, gpio and uartlite
    not done...

Tried to run "implement design"
  </t>
<t tx="ntallen.20100520123955.1247"></t>
<t tx="ntallen.20100524120730.1249">Xilinx provides multiple GUI frameworks for developing using processors.
ISE provides the most control over synthesis and routing.
XPS is a more high-level tool for piecing together IP
SDK is for software and can be invoked from either ISE or XPS.

It is possible to do entire designs in XPS/SDK. When working with a lot of VHDL, it may be easier to use ISE, including the XPS project as one component. That is the current strategy for this project. Hence we need to use all three GUI frameworks.

The ISE project is the root. (Syscon_rC)
The XPS project is found in the "system" subdirectory. XPS should be invoked from ISE by opening system.xmp, not directly.
SDK can be invoked directly or from either XPS or ISE. The SDK projects are under system/SDK.

</t>
<t tx="ntallen.20100524120730.1250">ISE will generate the bitstream for the FPGA. For this design, we expect all the software to bit within BRAM, and as such, initialization of the software can be done with a simple PROM initialization.

To include the program in the bitstream, we apparently need to create a software project in XPS. These seems counterintuitive as Xilinx has been steadily moving us away from XPS and toward the SDK for all software. As it happens, the only thing we need to do in XPS is to create an elf-only software project that points to the .elf file we want to include, and mark that project for inclusion in the bitstream. We don't need to generate the bitstream in XPS, just make that connection. (This is also odd: we don't use XPS to generate the bitstream or the software, but that's still the place we have to go to connect the two, even when the top level design is in ISE.)

Once the connection is made, the "Generate Programming File" option in ISE will create system_download.bit, which differs from system.bit in that it includes the software.
</t>
<t tx="ntallen.20100524120730.1251">We are using an SPI PROM to initialize the FPGA. The configuration is detailed in
http://www.xilinx.com/support/documentation/application_notes/xapp974.pdf

We are using the Indirect in-system programming (ISP) approach.

Note that the FTDI USB interface we are using also has its own connection to the SPI PROM, so we have the option to program it using iMPACT through the FPGA, or using FTDI's program and programming via USB.

To program the PROM, we need to reformat the bit file. The app note lists the command:
    promgen -spi -p mcs -o spi_prom.mcs -s 8192 -u 0 dacs_download.bit

In iMPACT, need to added SPI PROM to the design. The DACS board prom is M25P64 (width 1).
The part on the FTDI board is M25P20.
</t>
<t tx="ntallen.20100524120730.1253">The DLP board uses the FTDI FT2232D (0x0403,0x6010), but it is reportedly supported
by the devc-serusb driver, which is listed as supporting FT8U232AM (0x0403,0x6001)

I will try specifying the device ID on the devc-serusb command line

Apparently what I need is:
    /sbin/devc-serusb -d vid=0x0403,did=0x6010,module=ftdi

Some instability on removal, but insertion seemed to work fine.
Devices /dev/serusb1 and /dev/serusb2 show up.
</t>
<t tx="ntallen.20100525090916.1257"></t>
<t tx="ntallen.20100525090916.1258">I'm inclined to review the code for read and write and consider implementing some of it in VHDL.
The read logic is faulty, since it resets EXPRD before reading in the data (which is not latched in hardware)</t>
<t tx="ntallen.20100525090916.1259">&lt;hex16&gt; : [0-9A-F]{1,4}
&lt;addr&gt; : &lt;hex16&gt;
&lt;addr_list&gt; : &lt;addr_list_elt&gt;
            : &lt;addr_list&gt; ',' &lt;addr_list_elt&gt;
&lt;addr_list_elt&gt; : &lt;addr&gt; [ ':' &lt;hex16&gt; ':' &lt;addr&gt; ]
                : &lt;hex16&gt; '@' &lt;addr&gt;
&lt;data&gt; : &lt;hex16&gt;
&lt;cmdline&gt; : &lt;cmd&gt; '\n'
&lt;bit&gt; : '0' | '1'
&lt;multi_resp&gt; : ( ( 'M' | 'm' ) &lt;data&gt; )+ ['E' &lt;digit&gt;]
&lt;cmd&gt; :
    R &lt;addr&gt;    // Read: response codes: RrE
    W &lt;addr&gt; : &lt;data&gt;  // Write: response codes: WwE
    C &lt;bit&gt;    // CMDENBL: response codes: CE
    S &lt;bit&gt;    // CMDSTRB: response codes: SE
    V          // Board Revision: response codes VE
    B          // Board Logical Reset: response: 0? ###
    I &lt;digit&gt; : &lt;addr&gt; // Define and enable Interrupt: response: i &lt;digit&gt;
    I &lt;digit&gt;  // Undefine and disable Interrupt: response: i &lt;digit&gt;
    ''         // NOP: response code: 0
    M &lt;hex16&gt; '#' &lt;addr_list&gt;
    D          // Read switches: response: D&lt;data&gt; | E&lt;digit&gt; (no switches)
    F &lt;data&gt;   // Set failure: response: F | E
    F          // Read failure: response F &lt;data&gt; | E
    T          // Tick to reset 2-minute timeout: No response
    A          // Disarm reset timer

Responses:
    R &lt;data&gt; '\n'  // Read data with acknowledge asserted
    r &lt;data&gt; '\n'  // Read data without acknowledge asserted
    W '\n'         // Write with acknowledge
    w '\n'         // Write without acknowledge
    S &lt;bit&gt; '\n'   // CMDSTRB value
    C &lt;bit&gt; '\n'   // CMDENBL value
    V &lt;version&gt; '\n' // Version string
    I &lt;data&gt; '\n'  // Interrupt string
    i &lt;digit&gt; '\n' // Acknowledge Interrupt config command
    0 '\n'         // NOP
    D &lt;data&gt; '\n'  // Switch data
    E &lt;digit&gt; '\n' // Error--not obviously associated with a specific request
    F &lt;data&gt; '\n'  // Failure status
    &lt;multi_resp&gt; '\n'

B - Board Logical Reset: issue hardware reset to syscon, disable all interrupts.
    Does *not* reset the two-minute timer. (that's what "tick" does.) The reason for
    making the distinction is that the board reset will be issued when subbusd
    starts up, whereas tick will be issued by the actual data acquisition
    functions, indicating that the entire instrument is up and running. There
    is a lot that can go wrong between those two events, including spontaneous
    reboots, and we don't want the startup of subbusd to prematurely indicate
    that all is well.</t>
<t tx="ntallen.20100525090916.1260"></t>
<t tx="ntallen.20100525090916.1261"></t>
<t tx="ntallen.20100525090916.1262"></t>
<t tx="ntallen.20100525090916.1263">Make sure data bus is set for input
Set EXPADDR
Set EXPRD
&lt;wait for 1 usec&gt;&lt;could be a hardware test&gt;
Record value of EXPDATA and EXPACK
Reset EXPRD</t>
<t tx="ntallen.20100525090916.1264">Set EXPDATA direction to output
Set EXPADDR
Set EXPDATA
Set EXPWR
&lt;wait for 1usec&gt;&lt;could be hardware timer&gt;
Record value of EXPACK
Reset EXPWR
Reset EXPDATA direction to input
</t>
<t tx="ntallen.20100527162821.1273"></t>
<t tx="ntallen.20100527162821.1274">Reduced the number of GPIO instantiations by combining control and status bits.</t>
<t tx="ntallen.20100527162821.1275">Rewrite read/write operations to use the control and status ports and wait on the Done bit.
</t>
<t tx="ntallen.20100527162821.1276"></t>
<t tx="ntallen.20100527162821.1277"></t>
<t tx="ntallen.20100527162821.1278"></t>
<t tx="ntallen.20100527162821.1279">Brought in syscon_arch.vhd from HDS. Tried several ways to add to project. I want my vhdl to go in a subdirectory so it's separated from the mess of files in the root. "Add Copy of source file" does not allow you to say where you want to copy the source file. The approach that seems to work is to manually copy the source file into the vhdl directory, and then "Add source file" to link it into the project.

</t>
<t tx="ntallen.20100528083113.1287">and propogate through syscon and dacs and the subbus code
This could be handled via the processor reset: that's a discussion we need to have.

</t>
<t tx="ntallen.20100601150619.1289"></t>
<t tx="ntallen.20100602103230.1293">Shared objects:  oooo!

Original implementation loaded the single library that happened to be there, and then could query it to figure out what it was.

This approach might be more like asking for a particular library, perhaps by command-line option, and supporting multiple libraries.

Default behavior should be to load a single library, and perhaps by command-line option, and have the usual functions work

    driver
        Attempt to load some compile-time set of drivers, accepting the first found
    driver -s &lt;name&gt;
        Load the specified driver as the primary

After that, could provide APIs for loading multiple drivers

To support multiple drivers, we can't use the same function names in each driver, or they will be overwritten or otherwise conflicted.</t>
<t tx="ntallen.20100602103230.1294">Create apps linked separately against one or the other. Either:
    -l subbus
or
    -l subbus-usb

The executables could be segregated by hardware or by name

An alternate flavor of the subbus-usb library could use different names for the interface functions, which would allow for linking both into the same app. That would most likely be implemented by (optional) macros that recast the function names, so by recompiling, an app could use the same names, but access the alternate library.</t>
<t tx="ntallen.20100602103230.1295">I probably need a driver to arbitrate access to the serial device, though I can try to get away with the existing subbus library's arbitration scheme.

First implemented driver to arbitrate access to the serial device, but it also helps solve the interrupt problem clearly and also makes the linking of applications unambiguous without playing games. There is only one libsubbus which communicates with the subbus driver. There can be multiple subbus drivers (and will be at least two), but any application that addresses the subbus will be able to operate using either without recompilation.
</t>
<t tx="ntallen.20100607110403.1299">Currently I can control cmdenbl and direction, which suggests that addresses are working,
but I always read back zeros. Changing cmdenbl should produce a 0x8000 from the channel status

Driving in zero or out zero produces a change in direction, but driving out a non-zero
amount has not produced steps, leading me to believe the data value is coming through as zeros

Routing output data &lt;0&gt; to a pin to see if it is coming through
Then may try separating input and output into separate ports

output data bus bit order was wrong. Should have been [15:0], but was [0:15]

Input data is still not registering.

subbus_data_i (between system and syscon) shows non-zero data during ExpRd. It continues to the end of RdEn unless ExpAck is asserted (read_ack( 0, &amp;data ))
</t>
<t tx="ntallen.20100610083250.1301">Unexpected SEH</t>
<t tx="ntallen.20100803111918.1303">Four components:
    subbus_usb library
    subbusd driver
    serusb driver
    syscon_subbus

subbus_usb communicates with subbusd via IO_MSG messages:
    These have a standard _io_msg hdr with type _IO_MSG
    combine_len 0
    mgrid SUBBUSD_MGRID
    subtype 0
    Sent via MsgSend or MsgSendv

subbusd communicates with serusb driver via read/write
serusb communicates with syscon_subbus via USB
</t>
<t tx="ntallen.20100805085605.1305"></t>
<t tx="ntallen.20100805085605.1307">Need to figure out the whole architecture.
Now that I have a dedicated driver, implementation on the QNX side should be
pretty straightforward. Interrupt should cause syscon to issue an appropriate
"I\d\n" string.

QNX6 indexer code includes all the interrupt processing stuff that had been extracted
into intserv. I would like indexer driver to work on either subbus architecture, so
that means changes need to be pushed to the driver:
    Create subbusd for syscon104
        Copy subbusd, then copy in the libsubbus stuff to address the hardware
    Promote libsubbus_usb to be libsubbus, i.e. all programs will use it
    Incorporate intserv capabilities in both drivers

Old architecture:
    we did not know which boards would be plugged in when the interrupt circuit was laid out
    Any board that could produce an interrupt (indexer, mainly) could be programmed to:
        a) assert the interrupt
        b) respond on one of four INTA addresses
        c) respond by driving its status on one of 8 data bits
    The interrupt driver would:
        configure each board, given knowledge of the physical region
        attach the single subbus hardware interrupt
        respond to the interrupt with reads from any of the four INTA addresses in use
        check which bits request service and map those back to original requestor
    The regions were a way to support subbus expansion via a repeater where the
    strategy of driving single lines on the databus would break down. The software
    configuring the board had to know what region the board was in physically.
DACS architecture:
    we know going in exactly which components may request an interrupt, so we
    can wire them directly into the acknowledge without configuration.
    Move acknowledge responsibility into uBlaze. uBlaze will have a table
    of bits and base addresses. When service is requested, it will read
    from INTA address and report: IXXXX where XXXX is the board base address.
    Alternately, it could report IB where B is the bit number and we could
    pass the responsibility back to subbusd, but that would mean subbusd is
    tightly coupled with a specific FPGA configuration. Requiring the uBlaze
    code to be tightly coupled with the circuit makes more sense.
</t>
<t tx="ntallen.20100805085605.1308">Add another IO port to expose timing. 4 bits?
Show:
    start of receive to end of send
    start of addressing HW
    end of addressing HW

Might need to do the same with the parallel port on the PC end.
</t>
<t tx="ntallen.20100805085605.1309"></t>
<t tx="ntallen.20100816115707.1311">This API was actually handled by a separate driver in QNX4 known as IntSrv. Part of the idea was to support both "Experiment Interrupts" on the subbus and other interrupts to the processor itself, allowing unprivileged processes to receive proxies when interrupts arrived. I don't know if we'll need that capability going forward, but I plan to add the ExpInt stuff to the new subbus lib (currently named subbus_usb)

These were previously called "IntSrv_Int_attach/detach" but I will change the prefix.

int Subbus_Int_attach( char *cardID, unsigned short address,
    						int region, struct sigevent event );

  cardID is a application-selected name for the function that is being addressed.
  address is the subbus base address for the specified function
  region is reserved for a mechanism to support interrupts in disjoint bus segments.
    Should be zero for subbus_usb, may be non-zero for syscon104
    Wait, no, the application (e.g. idx64) should not need to know
    what library is in use, so this value should be compatible.
  event specifies how the application wants to be notified
  
  Returns 0 on success
  Errors include interrupt already attached (but may check...)

int Subbus_Int_detach( char *cardID );
</t>
<t tx="ntallen.20100816115707.1312">int Subbus_Int_attach( char *cardID, unsigned short address,
    						int region, struct sigevent event );
int Subbus_Int_detach( char *cardID );

The library will package these requests and forward them to subbusd. The library is not responsible for handling the resulting events, as they need to be worked into the applications event loop.
</t>
<t tx="ntallen.20100816115707.1313">The interrupt implementation in subbusd is necessarily hardware dependent.
I can reuse the bookkeeping code from QNX4/intserv</t>
<t tx="ntallen.20100816115707.1314"></t>
<t tx="ntallen.20100816115707.1315">The implementation here will match the existing implementation in intserv.</t>
<t tx="ntallen.20100816115707.1316">int Subbus_Int_attach( char *cardID, unsigned short address, int region, struct sigevent event );
int Subbus_Int_detach( char *cardID );

For USB, subbusd will maintain some bookkeeping to associate a specific interrupt code with a specific event, and will send the syscon_usb information to configure the interrupt. When the associated "I" code is returned, subbusd will trigger the specified event.

(Since subbusd_usb is tightly coupled with syscon_usb, we don't need to worry too much about making the protocol future-proof, anticipating all possible hardware implementations. For now, I think it should be sufficient
to specify that I want to configure the board at address A with interrupt code N.)

Functions required:
    configure function at address A to respond with interrupt code N
    disable interrupt N
    disable all interrupts
</t>
<t tx="ntallen.20100816115707.1317">Functions required:
    configure function at address A to respond with interrupt code N
    disable interrupt N
    disable all interrupts

The software running on syscon_usb will know what functions are defined.
"Interrupts" will actually be implemented via polling, since that is how
the software runs anyway. All functions that have interrupt capability
will have their interrupt status lines connected to a single interrupt
status register. The bits of the status register are or-ed together
to provide a single bit to signal interrupt activity to the processor.

On each poll cycle, the interrupt status bit will be read.
If it is non-zero, an INTA cycle will be produced, and the returned
value will be the interrupt status register. An "I" code will be
transmitted on the USB for each active bit in the status register.

The software will have
a table to map addresses to status bits. When a function is enabled,
the hardware will be programmed (as in the description of idx64
interrupt configuration) although the bit selection will not be
configurable, since it will be firm-wired. The hardware will still
respond to the specified INTA address (which should be 0x40 for all
functions--doesn't even need to be configurable, really)
</t>
<t tx="ntallen.20100816115707.1318">In the firmware:
    DACS:
        System:
            +Need ExpIntr Bit input: added to status
        Syscon:
            +Collect BdIntr outputs from boards, or them and deliver expintr bit as output
            +Respond to INTA by writing expintr vector
            +Provide INTA output
            +extend test bench
                +Test that reading from 0x40 generates INTA and Data_i shows BdIntr values
                +Test that non-zero value on BdIntr generates non-zero value on ExpIntr
            +Need to provide N_BOARDS generic and make ExpAck a vector
        extend test bench
    gxidx:
        +Add BdIntr output
        +Add INTA input, pass through to channels
        +extend test bench
        decode:
            +Add Interrupt enable logic
            +Add BdIntr output
            +Add Ireq Input vector
            +Add logic mapping Ireq vector to BdIntr
            +Eliminate INTA output/decoding
            +extend test bench
            +Make base address GENERIC
        channel:
            +Add INTA input
            +Add Ireq output
            +Add Running output
            +extend test bench
        Intr:
            Write test bench: HDS doesn't like that--do it at channel level instead</t>
<t tx="ntallen.20100823102718.1327"></t>
<t tx="ntallen.20100824101804.1329">Generating doxygen documentation in source code.</t>
<t tx="ntallen.20100827154528.1331">done: Make sure subbusd/serusb returns SBS_ACK and SBS_NACK status
done: Interrupt functions should have a way to return to client on error without enqueuing command to serusb.
done: Need to implement interrupt attach/detach functions
done: Need to implement timeout and error returns
    timer_create() to create a timer and associate it with a pulse</t>
<t tx="ntallen.20100907120439.1333">Implement all of the protocol defined in serusb/README
Done: Get subbus source into subversion
</t>
<t tx="ntallen.20100920151402.1335"></t>
<t tx="ntallen.20100920151402.1336">120 direction-selectable I/O channels in 15 banks of 8
  Half go to connector board, half to power board
  One 8-bit bank is split between the two boards, but still has
  a single direction select.
8 bidirectional channels to connector board
8 bidirectional channels to the power board

Indexer I/O needs to be carved out of this space

Looks like one "board" of two "connectors" in the Digio64 nomenclature
would do the trick, leaving 3 ports for indexer usage.

DIG_BASE_ADDR 0x800
DIG_CONN_OFFSET 0x20
DIG_CONN_PER_BD 2
DIG_BD_NUM 0
DIG_RESET_OFFSET 0x18

DIGIO_BASE_ADDR DIG_BASE_ADDR + (DIG_CONN_OFFSET*DIG_CONN_PER_BD*DIG_BD_NUM)


</t>
<t tx="ntallen.20101013150328.1339">Upper limit is determined by the time to transfer the data out of the converters.

Simulation give (.182 - .0867) ms = .095 ms between samples of a single channel.
That gives a conversion rate on the order of 10500 conversion/second.
Sub-muxed channels will be converted at only 1316 conversions/second.</t>
<t tx="ntallen.20101013150328.1340"></t>
<t tx="ntallen.20101013150328.1341"></t>
<t tx="ntallen.20101013150328.1342"></t>
<t tx="ntallen.20101013150328.1343">BRAM comes in 9Kb blocks which can be configured in various ways:
    As a simple memory, 512x16 where we provide all arbitration
    As a full dual-ported RAM 512x16 where we provide arbitration on the hardware side
    As a simple dual-ported RAM 512x16 or 256x32.
      We would need two 9kb BRAMs, but no additional arbitration.
      </t>
<t tx="ntallen.20101013150328.1344">There are 128 16-bit analog inputs.
Most recently recorded values for channel i can be read from subbus address:
    BASE_ADDRESS + 2*i
BASE_ADDRESS is probably 0x0C00, so read addresses run from 0x0C00 to 0x0CFE

The front end is configured with a 5-bit code. This is programmed by
writing to the same address as the input channel.</t>
<t tx="ntallen.20101013150328.1345"></t>
<t tx="ntallen.20101013150328.1346">For each channel, i, a second 16-bit word can be read from:
    BASE_ADDRESS + 2*i + 1
immediately after reading a channel.
This word includes the 5 bits of configuration and 11 bits of
frame counter. This value is latched when the channel is
read, so providing the next read is from the config address,
it will be correctly mated with the data. The address could
be checked against the latched address to make sure the
value matches.

The configuration value will be read back from the front-end
hardware so as to guarantee that we are reporting the
configuration that was actually in use when the data was
converted.
</t>
<t tx="ntallen.20101014082117.1355">Storage of A/D data (16 bits) and configuration readback (5 bits)
requires a total of 128 x 21 bits. This maps into a simple dual-
ported RAM at 256x32.

Storage of programmed configuration values (5 bits) requires
128x5 bits, which can map into lots of configurations, including
the simple dual-ported RAM at 256x32.

Reading the Spartan-6 BRAM data sheet, it appears that simultaneous
reads and writes to the same address are supported in SDP mode
providing the clocks are synchronous and the write mode is
READ_FIRST. The doc is slightly ambiguous because it defines
the SDP as having two ports with independent clocks, but then
says the collision rules are the same as for TDP, which supports
simultaneous reads when the clocks are synchronous. I guess
"independent" and "synchronous" are not mutually exclusive.</t>
<t tx="ntallen.20101014082117.1357">encapsulation of the RAMB8BWER primitive in SDP mode, 256 x 32

ENTITY ana_ram IS
  PORT (
    RD_ADDR : IN std_logic_vector(7 DOWNTO 0);
    WR_ADDR : IN std_logic_vector(7 DOWNTO 0);
    RD_DATA : OUT std_logic_vector(31 DOWNTO 0);
    WR_DATA : IN std_logic_vector(31 DOWNTO 0);
    WREN : IN std_ulogic;
    RDEN : IN std_ulogic;
    CLK : IN std_ulogic;
    RST : IN std_ulogic
  );
END ENTITY ana_ram;
</t>
<t tx="ntallen.20101019142341.1359">Using AD7687 in "Chain mode with busy indicator", Page 23 of the manual.
This requires that SDI and CNV are tied together. I will make that
association at the top level of this design.</t>
<t tx="ntallen.20101019142341.1360">Wrapper for ana_s5s state machine. Operates on the word level, so does not generate the CS output.
Note: whoever does generate the CS output must ensure the setup time requirements, specifically
 t3 = CS/ to SCK/ min 50 ns setup
 t7 = SCK to CS min 50 ns hold

ana_s5s stores the configuration data when it is read from the ana_cfg_ram.
I provide a 2-element FIFO here for two reasons:
    1: To make up the 2-column difference between read and write in ana_hwside
    2: To store up to two cfg values, since we need to store two at the end
       of each row.</t>
<t tx="ntallen.20101019142341.1361">State machine for clocking out configuration bits and generating the configuration clock.</t>
<t tx="ntallen.20101019142341.1362">State machine for clocking in data from A/D. Like ana_s5s, operates on the word level.</t>
<t tx="ntallen.20101019142341.1363">Encapsulation of BRAM block for use in simple dual ported RAM mode.
Using the BRAM_SDP_MACRO.

As noted elsewhere, the Spartan-6 BRAM does not support simultaneous
operations on both ports of a dual-ported RAM.

As currently written, the RDEN signal is delayed one clock cycle.
This was done to limit a read to a single clock cycle. I am
going to remove this, because that logic has moved up a level
into either ana_data_ram or ana_cfg_ram.

1/18/11: Switching BRAM_SIZE back to 36Kb (was 18Kb) just to make sure
I'm abiding by Xilinx's restrictions.

1/27/11: Odd: I think despite the comments in the BRAM_SDP_MACRO instantiation
template, the 36Kb option apparently failed. I'm going to try 9Kb, which
seems to make sense unless they need 2X as much storage for DP.
All this effort is pointed at getting initialization sorted out.

With BRAM_SIZE at 9Kb, we only need INIT_00-1F

Setting a non-zero INIT_ value does not seem to work during simulation. Probably I'm not using
the correct libraries.
</t>
<t tx="ntallen.20101019142341.1364">State machine generating control signals to drive ana_s5, ana_s16.
      CLK    : IN     std_logic; 30 MHz max. S5.SCK is CLK/6. S16.SCK is CLK/2
      RST    : IN     std_logic; Synch active high
      RdyIn  : IN     std_ulogic; Intended as logical and of Rdy signals from s5 and s16
      SDI    : IN     std_ulogic_vector (1 DOWNTO 0); SDI signals from each bank of A/D converters
      Addr   : OUT    std_ulogic_vector (7 DOWNTO 0); Address for our side of the two RAM banks
      Conv   : OUT    std_ulogic; Convert signal to A/D converters
      NxtRow : OUT    std_ulogic_vector (5 DOWNTO 0); Address lines for the mux
      RdWrEn : OUT    std_ulogic;
      RdyOut : OUT    std_ulogic;
      S5WE   : OUT    std_ulogic_vector (1 DOWNTO 0); Write Enable for the two S5 state machines
      RAM_BUSY : OUT  std_ulogic; Flag to avoid RAM collisions
      Start  : OUT    std_ulogic

NxtRow is so called because it represents the row of data that will
be retrieved during the next acquisition sequence. According to the
terminology in the AD7687 data sheet, acquisition comes after conversion,
and is the process of retrieving the converted value.

The low-order 3 bits of NxtRow go to the primary Muxes on the DACS
board. The higher-order bits can be used for external muxes. A
channel that is muxed will have extra bits set in the cfg_ram
flagging the fact that the channel is muxed and specifying 3 of
the bits of the address where the result will be stored.

RdWrEn is an enable line that goes to both banks of RAM. It is the
read enable on the configuration RAM and write enable on the data
RAM.

RdyOut goes high when the acquisition sequence is completed. This was intended
as a signal for external synchronization, but in the current configuration,
it is simply a flag that the next conversion/acquisition sequence will start.

Start is a signal to S5 and S16 machines to begin their sequences (or continue
their sequences).</t>
<t tx="ntallen.20101022104642.1371">This component encapsulates all the hardware interface timing.

This component caches channel configuration data between the
time it is read from the cfg_ram (as signaled by S5WE)
and when the converted data is read from the A/D and
written into the data_ram.
    Copy data from cfg cache when writing to data ram
        AcqData always reflects the cached configuration and
        latest converted data from the ana_s16(s), selecting
        based on the 'bank' bit (Addr(3))
    Set cfg cache from DO5 on S5WE</t>
<t tx="ntallen.20101022104642.1372"></t>
<t tx="ntallen.20101102122701.1375"></t>
<t tx="ntallen.20101102122701.1376"></t>
<t tx="ntallen.20101102122701.1377">Fail Lights/LEDs
I/O Switches
Tick tie in to Fail, CmdEnbl
</t>
<t tx="ntallen.20101102122701.1378">Two-second timeout should clear cmdenbl and ARM, which qualifies it
    In existing design, it is possible to set cmdenbl and then subsequently
    start ticking, which will enable cmdenbl output, or you can start
    ticking and then enable cmdenbl.
    DCCC takes advantage of this independence by setting cmdenbl independent
    of whether telemetry has started or not.
    
Two-minute timeout should light fail light (which can also be set manually)

Old behavior:
    Tick sets ARM
    ARM and cmdenbl_cmd produce CmdEnbl
    TwoSecond Timeout while ARMed
        produces Flt_CPU_Reset
        Clears ARM and CmdEnbl
        Subsequent tick will not reenable cmdenbl. An actual write to cmdenbl is required.
    Disarm command prevents Flt_CPU_Reset, disabled CmdEnbl, clears ARM

I will need a separate arm line in, plus some software logic. Will retain all of the below,
but require that Arm_in be true in order to recognize any ticks or produce reset.

I will not use a separate arm control line. I will count on CmdEnbl_cmd being reset before
a tick will be recognized, and will require a subsequent tick before CmdEnbl will be
asserted.

I will require that the software look monitor the TwoSecondTO bit of the status word
and clear CmdEnbl_cmd if it is observed. That will require the flight software to
explicitly set CmdEnbl before it will be recognized.

This does mean that a late tick could be recognized, but not before the reset is issued.
Even if it is recognized, cmdenbl will not be asserted without another explicit set.
</t>
<t tx="ntallen.20101123111757.1383">Due to the vagaries of the various tools involved, the source code
is separated into multiple modules under the arp-fpga subversion repository.</t>
<t tx="ntallen.20101123111757.1384">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/idx_fpga

This is tied into the HDL Designer Series software and represents the
VHDL code and graphical input formats (block diagrams, state machines)
within the HDS development environment.</t>
<t tx="ntallen.20101123111757.1385">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/fpga_sw/subbus

This is a project to be checked out into the XPS SDK:</t>
<t tx="ntallen.20101123111757.1386">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/DACS_V1_0_ISE

This is the necessary components of the ISE and XPS projects. The SDK project
needs to be set up separately.

Export Hardware project to SDK
In SDK: New Board Support Package:
    Standalone
    Set stdio to mdm
New Project from SVN
    https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/fpga_sw
    subbus
Edit project properties
    C/C++ General
      Paths and Properties
        Includes
          Fix up microblaze include path to match selection in BSP creation
        Library Paths
          Fix up microblaze library path to match selection in BSP creation

Back in XPS, double check path to executable.
</t>
<t tx="ntallen.20101215085413.1391">Rebuilding the design from the ground up (although all the VHDL should come in without modification)
I will summarize the salient features of the designs...</t>
<t tx="ntallen.20101215085413.1392">Spartan 6
xs6slx150
fgg484
-2

EEPROM is M25P64
</t>
<t tx="ntallen.20101215085413.1393">Single processor design
Reference Clock is 100 MHz
Reset Active Low (default)
No other IP in the BSB

IP:
    clock_generator: Need to add 8MHz and 25MHz outputs
    iic (later)
    rs232 (later)
    xps_epc (copy and paste from earlier design
    GPIOs: (copy and paste)
        data
        addr
        status
        ctrl
        Data_Rdy (FTDI/epc)
        FTDI_SI
        LEDs
        Switches

Instead of using util_vector_logic, I will implement the necessary inversion in
Dacsbd_beh.vhdl

Export to SDK:
    This design has instantiated in Project Navigator.
    After exporting to SDK, you must manually copy the
    bitstream and &lt;design&gt;_bd.bmm file from the Project
    Navigator directory to the export directory display below
    SDK\SDK_Export

I've tried this, but I cannot currently figure out how to tell the SDK what files to use to configure the FPGA
</t>
<t tx="ntallen.20101215085413.1394"></t>
<t tx="ntallen.20110115103957.1399"></t>
<t tx="ntallen.20110115103957.1400">This is the main branch for current development. Any directory created with suffixes is a temporary test.
DACS_V1_0A_ISE e.g.</t>
<t tx="ntallen.20110118143100.1403">Encapsulation of ana_ram to avoid simultaneous operations by
delaying the subbus read while RAM_BUSY is asserted.

Also will cache the configuration data read from an even address
to report on a subsequent read of the next higher address.</t>
<t tx="ntallen.20110118143100.1404"></t>
<t tx="ntallen.20110118143100.1405">Encapsulation of ana_ram to avoid simultaneous operations by
delaying the subbus write while RAM_BUSY is asserted.
</t>
<t tx="ntallen.20110118143100.1406">Basic analog input address run from C00 to CFE, so there are 8 significant bits.
Bit 0 is used simply to indicate whether the converted value or the configuration
value is being read. That leaves 7 address bits: Addr(7 downto 1). Of these:
    Addr(7 downto 5) is the Row
    Addr(4) is the Bank
    Addr(3 downto 1) is the Column

2^7 = 128 different channels, corresponding to 2 banks of 8 converters with 8-channel
muxes.

And 8 of these 128 channels may be further muxed off the DACS board.
The configuration word consists of 9 bits:
    Cfg(4 downto 0) is the channel gain configuration
    Cfg(8) is the remux bit
    Cfg(7 downto 5) is the remux addr: maddr
When a remuxed channel is read from the converter, the value is
stored at the normal location, then also at a mux address, which
is assembled as: X"D" &amp; maddr &amp; bank &amp; Row(5 downto 3)

#### Since the RAMaddr is generated by ana_acquire, it needs to have at least the
mux configuration bits that are cached by ana_hwside.</t>
<t tx="ntallen.20110122074609.1411">In order to make the hwside a little simpler, I permute the write address for
configuration data so it comes out one row and two columns before the data
converted data is recorded.</t>
<t tx="ntallen.20110123092829.1413">Produced by the hardware (DACS):
    E1: Unrecognized Command
    E2: Receive Timeout
    E3: Command Syntax Error
    E4: Invalid Interrupt Request
    E8: Serial request too long
    E10: Internal contradiction
    E11: No ACK on INTA
    
Produced by subbusd:
    E100: USB Timeout
    E101: Wrong number of readings returned
    E102: DACS reply syntax error

Produced by libsubbus:
    E200: Null request</t>
<t tx="ntallen.20110203162516.1415">This device will present a read-only interface to the subbus. On the back side
we will have an engine driving an I2C interface to poll the SHT21 (RH/T) and the
MS5607 (P/T)

0  0300	R	Status
1  0302	R	SHT21 Temperature
2  0304	R	SHT21 Relative Humidity
3  0306	R	MS5607 Coefficient 1
4  0308	R	MS5607 Coefficient 2
5  030A	R	MS5607 Coefficient 3
6  030C	R	MS5607 Coefficient 4
7  030E	R	MS5607 Coefficient 5
8  0310	R	MS5607 Coefficient 6
9  0312	R	MS5607 D1(15:0)
10 0314	R	MS5607 D1(23:16)
11 0316	R	MS5607 D2(15:0)
12 0318	R	MS5607 D2(23:16)

Why am I using the 25MHz clock on the back side? I2C is not fast, and timing issues might be much
easier without dealing with cross-clock stuff.</t>
<t tx="ntallen.20110203162516.1416">I2C Address is 1000000

We could issue a soft reset (11111110) on startup for good measure
Soft reset takes less that 15 ms

Present as two 16-bit words:

Trigger T measurement hold master (11100011)
  Read three bytes (MSB, LSB, Checksum)
  Store two
Trigger RH measurement hold master (11100101)
  Read three bytes (MSB, LSB, Checksum)
  Store two
</t>
<t tx="ntallen.20110203162516.1417">Device has 6 16-bit configuration words in ROM. We want to read these
once on startup, then just read the P and T values.

The Reset sequence (0x1E) shall be sent once after power-on to make sure that the
I2C Address is 0xEE

calibration PROM gets loaded into the internal register.

After requesting a conversion, there is no direct indication when the
conversion is complete. The data sheet says you have to wait for the
conversion to complete or you will corrupt the value, so presumably
we will just have to wait long enough by counting clocks.

Initialization:
    Wr Soft Reset (0x1E)
    Wait 2.8ms for reload
    Read configuration words and store
    Wr Prom Read 0 (0xA0)
    Rd Two bytes, store
    Wr Prom Read 1 (0xA2)
    Rd Two bytes, store
    ...
    Wr Prom Read 6 (0xAC)
    Rd Two bytes, store

Sampling:
    Wr Convert D1 (P) (OSR=4096) 0x48
    Wait 9.04 ms
    Wr ADC Read 0x00
    Rd Three bytes, store
    Wr Convert D2 (T) (OSR=4096) 0x58
    Wait 9.04 ms
    Wr ADC Read 0x00
    Rd Three bytes, store</t>
<t tx="ntallen.20110206160145.1421">Initialization:
    SHT21 Reset:
        Wr 1000000 0xFE Stop -- require 15 ms
    MS5607 Initialization:
        Wr Soft Reset (1110111 0x1E)
        Wait 2.8ms for reload
        Read configuration words and store
        Wr Prom Read 1 (0xA2)
        Rd Two bytes, store
        Wr Prom Read 2 (0xA4)
        Rd Two bytes, store
        ...
        Wr Prom Read 6 (0xAC)
        Rd Two bytes, store
        
        Each Write/Rd two byte sequence takes less than 500 us
        This entire read sequence takes 45*6*10us = 2.7ms
        Together with the reset delay we get 2.7 ms + 2.8 ms = 5.5 ms
        So we need to wait another 10 ms for the SHT21 to finish

Acquisition:
    SHT21:
        Trigger T measurement hold master (11100011)
        Read three bytes (MSB, LSB, Checksum) Store two
            Default T resolution is 14 bits
            Maximum conversion time for 14 bits is 85 ms
        Trigger RH measurement hold master (11100101)
        Read three bytes (MSB, LSB, Checksum) Store two
            Default RH resolution is 12 bits
            Maximum conversion time for 12 bits is 29 ms
        
    MS5607:
        Wr Convert D1 (P) (OSR=4096) 0x48
        Wait 9.04 ms
        Wr ADC Read 0x00
        Rd Three bytes, store
        
        Wr Convert D2 (T) (OSR=4096) 0x58
        Wait 9.04 ms
        Wr ADC Read 0x00
        Rd Three bytes, store</t>
<t tx="ntallen.20110207112658.1424">00: SHT21 Reset Acknowledge
01: MS5607 Reset Acknowledge
02: MS5607 Config 1
03: MS5607 Config 2
04: MS5607 Config 3
05: MS5607 Config 4
06: MS5607 Config 5
07: MS5607 Config 6
08: SHT21 T
09: SHT21 RH
10: MS5607 D1
11: MS5607 D2

12: Select Error

</t>
<t tx="ntallen.20110227134141.1425">Some are working great, others not.
Three counters:
    Ctr0: 4th input is reading lots of counts. Probably not terminated
    Ctr1: OK?
    Ctr2: Nothing reads right, not even status</t>
<t tx="ntallen.20110331101033.1427">March 31, 2011
AI circuit is freezing in flight. Instrumentation indicates ana_acquire is getting
stuck in acq_... (bit 4) indicating that there is a problem with the handshaking
between ana_acquire and the ana_s16 and/or ana_s5s state machines. I think this
may be tied into the possible timing variations introduced by the RAM arbitration
scheme which was left somewhat less than robust.

We need to sort out the arbitration with RAM and the handshaking between the different
state machines. The current design makes certain assumptions that apparently are false.
Specifically, ana_acquire assumes that if it gets a Rdy_In signal, it can set start
for one clock and it will 

April 2011

After the careful redesign, the engine no longer freezes up, but it does exhibit a
tendency to get into a mode where seemingly random data values are reported. This
has been shown to be due to the fact that the first word or two of data is not
being properly shifted out of the A/Ds, resulting in data from other columns
being reported with a bit shift.

Currently testing an implementation where I use the existing design but specify that
the FSM be implemented using one-hot encoding instead of the default (which was gray).

This seems to have improved performance on the bench with the HTW DACS. We will see
how it works in flight today on HWV.</t>
<t tx="ntallen.20110418174231.1429">Want to read Current and Voltage
Use "Read Page" to get 4 bytes from each of two chips on the bus.

CE Need to check these two addresses against Marco's pullups.
D0

Write register #(0) to address CE, then read 2 bytes
Write register #(2) to address CE, then read 2 bytes
Write register #(0) to address D0, then read 2 bytes
Write register #(2) to address D0, then read 2 bytes

Use PTRH DPRAM to store values relative to BASE_ADDRESS
0 Status
2 I1  CE:0,1
4 V1  CE:2,3
6 I2  D0:0,1
8 V2  D0:2,3

Status word

0: I1 valid
1: V1 valid
2: I2 valid
3: V2 valid
4: Timeout</t>
<t tx="ntallen.20110418174231.1430">I2C initialization requires programming the clock prescale register.
In the first implementation, I am writing out "002D" for a prescale value of 45.
According to the formula, that should give me an SCL frequency of around 109 KHz,
In simulation, it gives me something close to 99 KHz.
What does it measure?

If I switch to 8MHz, the prescale value should be "000E" (based on simulation ratios)
</t>
<t tx="ntallen.20110419111719.1433">This block serves as cache memory. Data is read from the PTRH devices
and written to the DPRAM, then read on the subbus side.
In the original design, it also served as a clock synchronization
barrier. I am investigating how it might need to be changed if
the clocks do not require synchronization.

Each DPRAM serves as a mini FIFO, and it's really independent of
clock rates. They can be independent or synchronous, and it
should still work and serve a useful function.</t>
<t tx="ntallen.20111024112337.1435">For Carbon, we are looking at muxing multiple PTRH modules using a
TI PCA9548A 8-channel I2C Switch. This has many implications:
    Since each PTRH currently reports 13 words of data, if we
    end up with 15 of them, that's a lot of address space.
    Half that data only needs to be read on startup.
In the interest of optimization, I want to rearrange the PTRH
    data so the acquisition data is contiguous
    
I'm looking at 32 addrs/PTRH and 8 PTRH boards total.
That's a round 100H. Could go up to 16 PTRH boards within
that same footprint if I adopted a paged architecture.
</t>
<t tx="ntallen.20111025151610.1437">Provides routines at a slightly higher level than the wishbone I2C.
It supports writes of addr and data and reads of 2 and 3 bytes from
a specified address.

I propose adding some of the looping constructs such as (De)SelectAll
and PTRH.Select. It would have to know about the PTRH definitions and
ESID definitions.</t>
<t tx="ntallen.20111114100408.1439">I am remapping the registers in order to optimize multi-word reads in the future:
    
0000	R	MS5607 Coefficient 1
0002	R	MS5607 Coefficient 2
0004	R	MS5607 Coefficient 3
0006	R	MS5607 Coefficient 4
0008	R	MS5607 Coefficient 5
000A	R	MS5607 Coefficient 6
000C	R	Status
000E	R	SHT21 Temperature
0010	R	SHT21 Relative Humidity
0012	R	MS5607 P D1(15:0)
0014	R	MS5607 P D1(23:16)
0016	R	MS5607 T D2(15:0)
0018	R	MS5607 T D2(23:16)
</t>
<t tx="ntallen.20111123115724.1441">The topology of the PTRH network is defined via Generics.
There is considerable flexibility in how PTRH boards can be connected.
Two PTRH boards cannot be directly connected to the same I2C bus,
but multiple PTRH boards can be connected through an external switch,
which produces multiple I2C buses on the other side.
Since the switches we are using have a programmable address, it is
possible to have multiple switches on the same I2C bus.
Each I2C bus can either have a single PTRH or one or more switches.
You cannot have both a PTRH and a switch on the same bus because
the PTRH's address would conflict with PTRHs on the switch.

In order to tell the firmware how to query all of these devices

N_ISBITS: The number of I2C buses leaving the FPGA
N_PTRH: The number of PTRH subsystems attached
N_ESWITCH: The number of external switch devices plus the
    number of I2C buses that have PTRHs attached directly.
    This will typically be equal to N_ISBITS, but not
    if there are multiple switches connected to one bus.
ESID: An array of N_PTRH elements in the range N_ESWITCH-1 downto 0
    Identifies which external switch or bus a particular
    PTRH is attached to
ISwitchBit: An array of N_ESWITCH elements in the range N_ISBITS-1 downto 0
    Identifies which I2C bus the PTRH or external switch is connected to
ESwitchAddr: An array of N_ESWITCH 7-bit I2C addresses
    If this ESID identifies an external switch, this address will be
    non-zero. If it is zero, it identifies a directly-connected PTRH.
ESwitchBit: An array of N_PTRH elements in the range 7 downto 0
    Identifies which bit on the external switch this PTRH is
    connected to. The setting is ignored if no external switch
    is involved.
</t>
<t tx="ntallen.20111212160628.1443">The idea is to reproduce the AnaI/O hi-res AD/DA interface to communicate with QCLIs. We have a suspicion that some of the current misbehavior of the QCLI may stem from a problem with the RS-232 interface. If true, using the quasi-spi interface might alleviate the problem.

We need to address multiple QCLIs. It is probably smart to keep the circuits independent, provided we have enough lines. As detailed elsewhere, it is possible to share clock and data lines, but that would require a more serialized architecture.

If we are careful and mimic the anaio interface, we could use the existing qcli utils to communicate with the QCLIs. Alternately, we could provide an enhanced interface that might make programming and/or verification more efficient.</t>
<t tx="ntallen.20111212160628.1444">0: R: Controller Status
    Used to report FIFO status and whether read block operation is complete
    0-7: 8 bits indicating number of words in FIFO (replacing other two FIFO bits)
    8: Read Block Operation Pending
    9: Read Block Operation Complete (cleared when FIFO is drained)
    10: Write Command Pending (set on write FIFO, clear when FIFO emptied and WriteStop is set)
    11: QCLI Responding (set whenever data is received. cleared on a timeout)
    12: FIFO Overflow
    13: Write during RB conflict (RWConflict)
    14: Reading from QCLI (block TOset)
2: R: QCLI Status
    Reports the most recently read QCLI status and triggers another status report.
    Status is read at some reasonably slow rate in the absence of subbus reads
4: R: ReadFIFO
    Reports next word from the ReadFIFO or zero if the FIFO is empty. The FIFO
    is big enough to store a full block (128 words).
6: W: Write
    Writes a word to the write FIFO expecting more to follow. An attempt to write
    to the QCLI during a block read operation will be ignored and will set the
    busy bit in the controller status word.
8: W: WriteStop
    Writes a word to the write FIFO and indicates that this transmission is complete.
    When the write FIFO is empty, if the WriteStop bit is set, a new sync is
    performed to obtain the current status.
A: W: ReadBlock
    Specifies the block address to be read. This command should only be issued
    when the write FIFO is empty and the QCLI is in idle mode. It will lock out
    commands except for ConrtollerReset. Read the controller Status to see when
    the block is ready for transfer.
C: W: ControllerReset
    This command will interrupt any partial block writes, reset the FIFO,
    and break out of a block read operation.</t>
<t tx="ntallen.20111212160628.1445">This interface was designed before the QCLI was conceived. It was intended to talk to a specific A/D or a specific D/A. The QCLI interface was designed to be compatible with those two capabilities. The result is an interface definition unlike any other.

There are 4 signals on the QCLI:
    QSCLK: INOUT: bi-directional data clock
    SDATA: INOUT: bi-directional data link
    QSYNC: IN: chip select and direction control
    QBUSY: OUT: status readback

QBUSY was originally a bi-directional LDAC/ and BUSY/ indicator, but the LDAC/ functionality was unnecessary on the QCLI, so we will consider this to be an output from the QCLI.

QSCLK is driven by the QCLI when we are reading from the QCLI and is driven by the DACS when we are writing to the QCLI. On read, the QCLI runs the clock at 62.5 KHz. On write, we probably have some latitude, with 62.5 KHz being a starting point. The important limitation is that we must provide enough time between words for the QSYNC to be properly observed and the command recorded. QSCLK is pulled down on the QCLI, so it will be low unless it is driven high.

SDATA is driven by the DACS when writing to the QCLI and driven by the QCLI when reading.

QSYNC serves as both chip select and direction control. If held high, the QCLI is deselected and the communication circuit remains idle.

For a read request, QSYNC is pulsed low while holding QSCLK low. When the QCLI observes QSYNC going high with no intervening QSCLK pulses, it drives QBUSY low, takes control of QSCLK and SDATA and shifts out 16 bits. SDATA should transition when QSCLK is low, so SDATA can be clocked in on either the rising or falling edge of QSCLK. [[I do not know what the bit order is]]

For a write, QSYNC is driven low, and then SDATA and QSCLK are driven to clock out 16 bits [[presumably in the same bit order used for read]]. After 16 bits are shifted, QSYNC is raised to mark the end of the data transfer. QSYNC must remain high for at least one microsecond before writing another value. There may be other constraints governing the writing speed.
</t>
<t tx="ntallen.20111212160628.1447">Details need to be filled in, but the ANAIO circuit continuously polled the QCLI for status information so a simple subbus read would give the current status. I still need to figure out how output and requests to read other data was handled. The speed of the polling is up for grabs. ANAIO did something like 400 Hz, but I think that is much faster than we require.</t>
<t tx="ntallen.20111213091253.1451">All of the commands issued during normal operations involve writing one to three words to the QCLI and then switching back to read mode to get the status. The server does not deal with the status at all, which is to say it does not need to actually report the status, just make sure that the status will be read.

A simple implementation would be to have two write addresses, one for basic writing and one for a final word that would switch back to read mode. I would also create a FIFO of at least 3 words for holding write data.

This would then benefit from a multi-write subbus interface:
    W&lt;addr&gt;:&lt;data&gt;,&lt;data&gt;;&lt;addr&gt;:&lt;data&gt;...
</t>
<t tx="ntallen.20111213091253.1452">Writing out a program involves writing multiple blocks
Writing out a block involves:
    QCLI_LOAD_MSB
    QCLI_WRITE_ADDRESS
    for blocklen
      QCLI_LOAD_MSB
      QCLI_WRITE_DATA
      chksum += value
    end
    QCLI_LOAD_MSB
    QCLI_WRITE_CHKSUM
    Read status to verify checksum and firmware OK
    QCLI_PROGRAM_SECTOR
    Monitor status to observe expected modes

Note that for a block of 128 words, this requires writing 260 words
before verifying the checksum. Controller's FIFO only holds 128, so
I'll need to do some batching.

Reading the controller status can tell us how many bytes are left
in the FIFO and whether the write is completed. The current design
goes directly from "Write Pending" to "Reading from QCLI", so if
you wait for both to be clear, it is OK to read the qcli status.
</t>
<t tx="ntallen.20111213091253.1453">Read /qclutil/qclisb.c to understand subbus interface.

#define ANAIO_STATUS_OFFSET 6
#define ANAIO_DAC_OFFSET 0x60
#define ANAIO_HRDAC_OFFSET 0x70
#define ANAIO_HRADC_OFFSET 0x78
#define DAC_MODE_BITS 0x0C

Reading from the read address (base+ANAIO_HRADC_OFFSET) puts the circuit in read mode
Writing to the write address (base+ANAIO_HRDAC_OFFSET) puts the circuit in write mode
After writing, we need to wait until the data is shifted out before writing again, which I implemented as a 3ms delay. 3ms appears to be overkill, since at 16KHz, it takes 1ms to shift out 16 bits.

After writing, we need to switch back to read mode. In read mode, ANAIO polls the QCLI at 400Hz for status. I think that's where the 3ms comes from. 400Hz = 2.5 ms, and if you add in the 1ms to transfer the data, you get 3.5 ms maximum delay before fresh status is available.

Whenever a sync pulse is sent to the QCLI, it responds with data, which is the status word unless the QCLI is in memory read mode. In memory read mode, an address has to be written for each word and then a read is performed. This is clearly a case where a hardware optimization would be very helpful</t>
<t tx="ntallen.20111215085119.1457">FIFO semantics
    FIFOhead is the address of the first word in the FIFO (next to be read)
    FIFOtail is the address where the next word will be written
    if FIFOhead = FIFOtail, the FIFO is either empty (FIFOnonempty = 0 AND FIFOfull = 0)
      or full (FIFOnonempty = 1 AND FIFOfull = 1)
    FIFO_rdata will always report the data at FIFOhead
if ! FIFOnonempty {
  FIFO_rdata &lt;= (others =&gt; '0')
} else {
  FIFOhead &lt;= FIFOhead+1
  if FIFOhead = FIFOtail {
    FIFOnonempty &lt;= '0';
    FIFO_rdata &lt;= (others =&gt; '0');
    FIFOcnt &lt;= 0;
  } else {
    FIFOfull &lt;= '0';
    FIFOcnt &lt;= FIFOcnt-1;
    raddr &lt;= FIFOhead;
    rRd &lt;= '1';
    FIFO_rdata &lt;= ram_rdata;
    rRd &lt;= '0';
  }
}
    
FIFO_rdata &lt;= ram_rdata(FIFOhead)</t>
<t tx="ntallen.20111215085119.1458">If FIFOfull = '1' {
  ctrlr_status(12) &lt;= '1';
} else {
  raddr &lt;= FIFOtail;
  ram_wdata &lt;= WDataC;
  rWr &lt;= '1';
  FIFOtail &lt;= FIFOtail+1;
  
  rWr &lt;= '0';
  FIFOnonempty &lt;= '1';
  FIFO_cnt &lt;= FIFO_cnt+1;
  if FIFOtail = FIFOhead {
    FIFOfull &lt;= '1';
  }
}
</t>
<t tx="ntallen.20120104141216.1461">
Verifying a program involves reading a sequence of blocks
Reading a block involves:
    QCLI_LOAD_MSB
    -- QCLI_WRITE_ADDRESS
    QCLI_READ_DATA
    for blocklen
        QCLI_WRITE_ADDRESS
        Read data
    end

The current read code keeps reading in case the serial transmission was flawed, which is possible, but my inclination is to provide a separate address to set write to read a block, then perform a multi-read command from a FIFO. I would probably want to provide a separate status address</t>
<t tx="ntallen.20120109083521.1463">Connector listings map instrument signals onto board signals
e.g. L2_On_Off (command output) is mapped to DIO[72]

The next step is to map those through the subbus architecture.</t>
<t tx="ntallen.20120109083521.1464">Digital commands are implemented using both DigIO and cmd_proc.
Each digital command is mapped to a cmd_proc output and then
implicitly to two DigIO outputs (on &amp; off).

Each digital status input is mapped to a DigIO port.

Step 1:
    On DIO sheet, Assign command outputs to Cmd&lt;n&gt;
    Be sure to assign all the power board commands and status
    By convention, start by numbering power board commands at Cmd&lt;0 to 23&gt;
    Assign other commands from Cmd&lt;24&gt; on up.
    Assign CmdProc digital status lines for these commands next
    Assign Power Board status lines next
    Subbus inputs (DIO[62:60]) get routed to DACS_Switches, but could go
      to spare DigIO inputs as well for diagnostic purposes. DIO[63] SPR_IN(1)
      was troublesome, as I recall.
    
    10 DigIO inputs
    4 SB inputs
    2 Indxr inputs</t>
<t tx="ntallen.20120110154657.1467">As we develop new instruments, the standalone DACSdiag does not really work.
Each instrument has a different combination of features.

I used to generate code with NETS. I could generate displays for each connector.
The difference with DACS is that all the internal stuff does not get input into
the database, but maybe it should. Ideally, I would extract that information
directly from the VHDL for e.g. PDACS_Carbon, but that is probably overkill.

This can be attacked in layers. The most urgent need is to get stuff running,
so I might need to manually create intermediate formats.</t>
<t tx="ntallen.20120110154657.1468">1.0 of course</t>
<t tx="ntallen.20120110154657.1469">Experiment=$mnemonic
HomeDir=/home/$mnemonic
RUNFILE=interact
SUBBUSD=serusb
RunType=ask
Extractions=
Analysis=</t>
<t tx="ntallen.20120110154657.1470"></t>
<t tx="ntallen.20120110154657.1471">Run with generic names
Then with specific names</t>
<t tx="ntallen.20120110154657.1472"></t>
<t tx="ntallen.20120110154657.1473"></t>
<t tx="ntallen.20120110154657.1474">Combine elements from other modules as necessary
</t>
<t tx="ntallen.20120110154657.1476">Generic type definitions
Synch, MFCtr definitions
</t>
<t tx="ntallen.20120110154657.1477">Need to configure the MUXed channels.
    Mux Input_Addr, Output_Addr
    Input_Addr is the address of the unmuxed channel
    Output_Addr is the address of the row
Could configure gains.
Need to generate:
    tmc, collection
    tbl display
    cmd for playing with controls</t>
<t tx="ntallen.20120110154657.1478">Specify N Chips
Generate:
    tmc, collection
    tbl display
    cmd commands</t>
<t tx="ntallen.20120110154657.1479">Specify number of ungated counters
Generate
    tmc collection
    tbl display
    Contribute to edf extraction
    </t>
<t tx="ntallen.20120110154657.1480">Requires considerably more configuration
DigIO consists of a number of connectors with 6 ports each
Each port can be configured for input or output
Outputs are generally controlled by DCCC
    Many outputs are routed to command processor and paired
    with internal digital status lines. May also have external
    status lines.
Inputs are read directly by telemetry, but may be associated with
specific command lines

May or may not assume that command outputs are contiguous</t>
<t tx="ntallen.20120110154657.1481">A full blown command has all this useful information
    Command Name
    DIO number
    DACS connector and pin
    CB connector and pin
    Command Number
    On dig_IO index
    Off dig_IO index
    DS dig_IO index
    S dig_IO index</t>
<t tx="ntallen.20120110154657.1482">The next level of configuration is to identify channels by name and connector:
    Signal Name
    Voltage Range
    DACS connector pin (maps to collection addr)
    Mux index (if collection addr is muxed: see mux definitions)
    CB connector pin</t>
<t tx="ntallen.20120110154657.1483">The next level of configuration is to identify channels by name and connector:
    Signal Name
    Voltage Range (fixed 0-10)
    DACS connector pin (maps to collection, cmd addr)
    CB connector pin</t>
<t tx="ntallen.20120110154657.1484">The next level of configuration is to identify channels by name and connector:
    Signal Name
    DACS connector pin (maps to collection, cmd addr)
    CB connector pin</t>
<t tx="ntallen.20120110154657.1485"></t>
<t tx="ntallen.20120110154657.1486"></t>
<t tx="ntallen.20120111082754.1505">NETS handled interconnection of wires.
Signals connected by a wire were equivalent
Sometimes that meant an address was associated with a signal

Given a rewrite, I would like to allow attributes to be associated with signals,
address being one such attribute.

Attributes:
    Address
    Mux Index
    Affinity with another signal
    Mux Configuration

From NETS, we know signals are associated with a list of Comp:Conn:Pin triples
This means a signal has associations with multiple components and multiple connectors
In practice, we don't always realize all of those associations on the screen,
but sometimes it is useful to see them during development.

I might want to see all the signals on the DACS, DACS connector or a connector board
connector during test. Ultimately, I am more interested in the 'leaf' components, not
the intermediate distribution panels.

In some cases I might want to provide a different grouping, perhaps involving multiple
components into a subsystem or a hierarchy of subsystems. Some of this organization
can take place at the signal level, and some of these can be determined automatically.

Currently we have associations with Comp, Comp:Conn and Comp:Conn:Pin
Suppose we allowed arbitrary new categories (e.g. CmdGroup)
These don't need to be named explicitly. They can be identified by association
(Cmd0S is in the CmdGroup of Cmd0.) The role within the group should also be defined,
perhaps both mnemonically and verbosely:
    Cmd0 CmdGroup CmdO Command Output
    Cmd0S CmdGroup(Cmd0) S Command Status
    Cmd0DS CmdGroup(Cmd0) DS Command Processor Status
    Cmd0On CmdGroup(Cmd0) On Command Processor On Input
    Cmd0Off CmdGroup(Cmd0) Off Command Processor Off Input
    Cmd0I CmdGroup(Cmd0) I Command Current

When a category is created, 
When displayed, signal names might be omitted in favor of column headings based on group mnemonics.
Only columns for channels reported in telemetry would appear

One-off groupings might also be useful. Again, the display would likely use the group title and
mnemonic labels.</t>
<t tx="ntallen.20120111082754.1506">AI Mux0V has address 0xC1E and mux_cfg 0x100
  From this we know it's muxed values will appear at addressess 0xD10 through 0xD1E

Mux0 has output Mux0V, inputs Mux0_nV

Mux0_0V Muxed=Mux0V MuxIdx=0
    From this and the definition of Mux0V, we know Mux0_0V has address 0xD10
    This could also be defined as an affinity:
        Mux0_0V has an affinity of type 'Mux' to Mux0V with MuxIdx=0

LMB_I is equated to Mux0_0V

In the end, the fact that LMB_I goes through a mux is irrelevant. The salient features are:
    LMB_I is:
        Analog Input
        Address 0xD10
        Located on DACS, PB, LMB
        Affinity to Cmd(0) of type 'Related' with Relation=Current

</t>
<t tx="ntallen.20120111082754.1508">The DACS is designed to be coupled to a power board (PB)
Internal to the DACS, commands are implemented using DigIO
and command processor (CP)
A command to the power board is associated with the following:
    1 Command output from CP to the PB
    2 Command inputs to the CP from DigIO
    1 Digital Status from the CP to DigIO (_DS)
    1 Digital Status from the PB to DigIO (_S)
    1 Analog input from PB* (current)

The Analog input association logically has to be made on the PB,
since the mux actually exists there. Of course we could consider
the DACS/PB to be a single combined system, but it is probably
worth considering the general case.

Currently</t>
<t tx="ntallen.20120111082754.1509">/* DACS PTRH */

</t>
<t tx="ntallen.20120111082754.1510"></t>
<t tx="ntallen.20120111082754.1511"></t>
<t tx="ntallen.20120111082754.1512"></t>
<t tx="ntallen.20120111082754.1513">Switches, Fail Lights</t>
<t tx="ntallen.20120111082754.1514">Script to read basic configuration file and generate a DACSdiag source directory:
    Experiment=DACS_CI
    HomeDir=/home/DACS_CI
    
    AI_MUX(0xC1E, 0x100) means we need to collect, display 0xD10 through 0xD1E
    AI_MUX(0xC5E, 0x120) 0xD30 through 0xD3E
    AI_MUX(0xC9E, 0x140) 0xD50 through 0xD5E
    
    DIGIO_N_CONNECTORS
    Need to know which DigIO ports are outputs
    Need to know which outputs go to CP
    Which inputs are associated with which commands and how
    
    N_PTRH
    N_AO_CHIPS
    IDX_N_CHANNELS
    N_QCLICTRL
    CTR_UG_N_BDS
</t>
<t tx="ntallen.20120111082754.1515">TM typedef unsigned char MS5607Db { text "%3d"; }
TM typedef UINT PTRH_S { text " %03x"; }
TM typedef double PTRHT_t { text "%5.1lf"; }
TM typedef double SHT21RH_t { text "%4.1lf"; }
TM typedef double PTRHP_t { text "%7.2lf"; }
</t>
<t tx="ntallen.20120111082754.1516">%{
  #include "ptrhm.h"
  ptrhm PTRH_0 = ptrhm("DACS",0x300,0xB177,0x9A58,0x6DBF,0x62BA,0x81BF,0x6C80);
  ptrhm PTRH_1 = ptrhm("SPV", 0x320,0xB4E4,0x9BD8,0x7383,0x6D36,0x7629,0x6C80);
%}

TM 1 Hz UINT DACS_T1;
TM 1 Hz UINT DACS_RH;
TM 1 Hz UINT DACS_T2a; collect DACS_T2a = PTRH_0.MS5607Ta();
TM 1 Hz MS5607Db DACS_T2b; collect DACS_T2b = PTRH_0.MS5607Tb(); 
TM 1 Hz UINT DACS_Pa; collect DACS_Pa = PTRH_0.MS5607Pa();
TM 1 Hz MS5607Db DACS_Pb; collect DACS_Pb = PTRH_0.MS5607Pb(); 
TM 1 Hz PTRH_S DACS_PTRHS; collect DACS_PTRHS = PTRH_0.Status();
Group PTRH_0 ( PTRH_0_T1, ... ) {
    PTRH_0.collect();
    PTRH_0_T1 = PTRH_0.SHT21T();
    PTRH_0_RH = PTRH_0.SHT21RH();
    PRTH_0_ ...
}

TM 1 Hz UINT SPV_T1; collect SPV_T1 = PTRH_1.SHT21T();
TM 1 Hz UINT SPV_RH; collect SPV_RH = PTRH_1.SHT21RH();
TM 1 Hz UINT SPV_T2a; collect SPV_T2a = PTRH_1.MS5607Ta();
TM 1 Hz MS5607Db SPV_T2b; collect SPV_T2b = PTRH_1.MS5607Tb(); 
TM 1 Hz UINT SPV_Pa; collect SPV_Pa = PTRH_1.MS5607Pa();
TM 1 Hz MS5607Db SPV_Pb; collect SPV_Pb = PTRH_1.MS5607Pb(); 
TM 1 Hz PTRH_S SPV_PTRHS; collect SPV_PTRHS = PTRH_1.Status();</t>
<t tx="ntallen.20120111082754.1517">PTRHT_t PTRH_0_T1C; invalidate PTRH_0_T1C;
{ PTRH_0_T1C = PTRH_0_ptrh.SHT21T(PTRH_0_T1); Validate PTRH_0_T1C; }
PTRHT_t PTRH_0_T2C; invalidate PTRH_0_T2C;
{ PTRH_0_T2C = PTRH_0_ptrh.MS5607T(PTRH_0_T2a, PTRH_0_T2b); Validate PTRH_0_T2C; }
SHT21RH_t PTRH_0_RHC; invalidate PTRH_0_RHC;
{ PTRH_0_RHC = PTRH_0_ptrh.SHT21RH(PTRH_0_RH); Validate PTRH_0_RHC; }
PTRHP_t PTRH_0_P; invalidate PTRH_0_P;
{ PTRH_0_P = PTRH_0_ptrh.MS5607P(PTRH_0_Pa, PTRH_0_Pb) * 760./1013.; Validate PTRH_0_P; }
</t>
<t tx="ntallen.20120111082754.1518">Display PTRH_0_PTRHS, PTRH_0_T1C, PTRH_0_RHC, PTRH_0_T2C, PTRH_0_P

PTRH
        RH_T P_T  RH    P 
         C    C    %   Torr Status
</t>
<t tx="ntallen.20120111082754.1519">copy in ptrhm.h ptrhm.cc ptrhm_col.cc
tmcbase gets ptrh.tmc ptrhm.cc
tbl gets ptrh.tbl
col gets ptrh_col.tmc ptrhm_col.cc
conv gets ptrh_conv.tmc
</t>
<t tx="ntallen.20120111082754.1520">TM INITFUNC DACS_ptrh.check_coeffs();
TM INITFUNC SPV_ptrh.check_coeffs();</t>
<t tx="ntallen.20120113132201.1535">Raw waveform definition. Could be copied from generic

</t>
<t tx="ntallen.20120113132201.1536">Generic, copied, combined with ssp.cmd</t>
<t tx="ntallen.20120113132201.1537">Contains interface definitions:
    %INTERFACE &lt;QCLI0&gt;
    ...
    &amp;QCLI &lt;cmdif_rd *&gt;
      : QCLI0 { $0 = &amp;if_QCLI0; }
      : ...
      ;
%INTERFACE &lt;SSP&gt;

%{

#ifdef SERVER
  #include "hsatod.h"
  #define QCLI_ICOS \
      (HSAD_OPT_A|HSAD_OPT_B|HSAD_OPT_C|HSAD_TRIG_3|HSAD_TRIG_RISING)

  hsatod_setup_t ssp_setup;

  static struct ssp_bd_s {
    hsatod_setup_t *setup;
    cmdif_rd *intf;
  } ssp_bd[1] = {
    { &amp;ssp_setup, &amp;if_SSP },
  };

#endif

%}

# &amp;SSP returns an index into ssp_bd[]
&amp;SSP &lt;int&gt;
  : SSP { $0 = 0; }
  ;

&amp;command
  : Select QCLI Waveform &amp;QCLI_Wave * {
      *ssp_bd[0].setup = QCLI_Waves[$4];
      if_QCLI.Turf( "SW:%d\n", $4 );
    }
  ;
</t>
<t tx="ntallen.20120113132201.1540">Generated

%QCLI%_Wave
%QCLI%_s
%QCLI%_Stale

%QCLI%_ctrl_s</t>
<t tx="ntallen.20120113132201.1541">Generated
</t>
<t tx="ntallen.20120113132201.1542">%QCLI%_Wave
%QCLI%_s broken out by bit
%QCLI%_Stale

%QCLI%_ctrl_s
%SSP% vars</t>
<t tx="ntallen.20120113132201.1543">need to start a qcli driver for each qcli, ssp driver for each ssp
</t>
<t tx="ntallen.20120113132201.1544">Generated

%{
  ssp_data_t SSP;
  qcli_data_t QCLI;
%}
</t>
<t tx="ntallen.20120118103503.1551">CP_NCMDS=50 --The number of command processor commands
CP_DS=104   --The index into the dig_IO&lt;&gt; vector of the first DS bit
PB_S=160    --The index into the dig_IO&lt;&gt; vector of the first power board status bit

PB_S must be divisible by 8
CP_DS must be divisible by 8

There are CP_NCMDS DS bits starting at dig_IO&lt;CP_DS&gt;
There are 24 S bits starting at dig_IO&lt;PB_S&gt;</t>
<t tx="ntallen.20120118103503.1552">Define status words

There are ceil(CP_NCMDS/8) DS status words and 3 S status words
These start at port CP_DS/8.

The DS for command i is dig_IO&lt;CP_DS+i&gt;, where 0 &lt;= i &lt; CP_NCMDS
The connport is floor((CP_DS+i)/8)
port is connport % 6
conn is floor(connport / 6)
bit is (CP_DS+i)%8

offset[port] = { 8, 17, 10, 19, 12, 21 }
addr = 0x800 + conn*0x20 + offset[port]
xaddr = sprintf( "%03X", addr );

TM typedef unsigned char DStat { text "%02x"; collect x = sbrba(x.address); }

for each connport, generate:
    TM 1 Hz DStat DS&lt;xaddr&gt;; Address DS&lt;xaddr&gt; 0x&lt;xaddr&gt;;
</t>
<t tx="ntallen.20120118103503.1553">For each DS, determine bit, conn, port, xaddr

on_off_t Cmd_&lt;n&gt;_DS; invalidate Cmd_&lt;n&gt;_DS;
{ Cmd_&lt;n&gt;_DS = (DS&lt;xaddr&gt; &gt;&gt; bit) &amp; 1; Validate Cmd_&lt;n&gt;_DS; }

For each S, determine bit, conn, port, xaddr

on_off_t Cmd_&lt;n&gt;_S; invalidate Cmd_&lt;n&gt;_S;
{ Cmd_&lt;n&gt;_S = (DS&lt;xaddr&gt; &gt;&gt; bit) &amp; 1; Validate Cmd_&lt;n&gt;_S; }
</t>
<t tx="ntallen.20120118103503.1554">Just a list of commands</t>
<t tx="ntallen.20120118103503.1555">3 columns with 8 rows of &lt;cmd&gt;: DS S
Additional columns with &lt;cmd&gt;: S</t>
<t tx="ntallen.20120118103503.1556">In this model, the first CP_NCMDS/8 ports are outputs, and all the rest are inputs.

### due to the experiment-specific nature of the DACS, we can assume that the
### input/output configuration is fixed, so nothing needs to be written by dccc.

Hence all we have to write out are the address value pairs for the command outputs.
We don't need to address all of the input ports.</t>
<t tx="ntallen.20120816125014.1563">I2C interface to display with attached keyboard:
    I2C Address: 80
    Write out text for display and control codes
    Write out a poll command to read key press data
    Read key press data:
        0 means no key press
        0x80 bit means more keys
    
Probably want to include an additional I2C peripheral to read
switch positions.</t>
<t tx="ntallen.20120816125014.1564">Initialize device:
    Configure Display:
        254 79: Auto transmit key presses off
        etc.? (or does software do the rest)
    Configure LK204 GPO (not necessary)
    Configure PCA9554 I/O
        Configure inputs/outputs
        Initialize outputs
Poll device for keyboard and switch status
    W80: 254 38: Poll for key press, then read. If non-zero,
        queue data. If MSB set, read another immediately
    RXX: Read switch status

Accept subbus writes for buffering directly to device
Produce interrupt on key press
Report key press data on subbus read
    Return 0 if no key press data is present
    Clear interrupt when buffer is empty
Report switch status on subbus read
Report I2C status</t>
<t tx="ntallen.20120816125014.1565">Accept writes of data to go directly to the device
    Send with mwrite
Monitor interrupt line for key press data
    Read key press data with mread
    Do something with the key press data:
        Write to TM
        </t>
<t tx="ntallen.20120817130002.1569">Similar to ptrhm_acquire
provide wqueue, rqueue and timeout_100msec blocks

LK204_engine
  LK204_sm:
    loop {
        if (!wqueue_empty) {
            wr_i2c( X"80", 0 );
            loop {
              read char
              read isempty
              wr_i2c( char, isempty );
            } while ! isempty;
        } else if (timeout_100msec) {
            read switch status
            if (!rqueue_full)
                read for data until no more data
            reset timeout
        }
    }
  LK204_i2c:
    i2c_init {
      set clock divisor, enable core and interrupts
        wr_i2ctop("000", X"0E"); -- LSB
        wr_i2ctop("001", X"00"); -- MSB
        wr_isctop("010", X"CO"); -- enable core and interrupts
      initialize switch interface
        TBD
    }
    wr_i2c( data, stop ) {
        write data to "011"
        write command to "100"
    }
    rd_i2c( addr ) {
    }</t>
<t tx="ntallen.20120817161609.1571">This is a dual-port FIFO that allows simultaneous reads and writes,

RData always reports the next value in the FIFO unless Empty is asserted
RE advances RData to the next value or sets Empty

WE copies WData to end of FIFO unless Full is asserted</t>
<t tx="ntallen.20120823092853.1573">Interconnect diagram is fairly concise, but it can combine unnecessary details.
It also makes all inputs and outputs to be of equivalent importance.
If we define the block as an object, then various interfaces to the object
can make clear which ports are used for which purposes.</t>
<t tx="ntallen.20120824140516.1575">Interrupt processing, like everything DACS, must be implemented at many layers:
    FPGA/VHDL: 'card'
    FPGA/VHDL: syscon
    FPGA/CPU: subbus
    Host/CPU: subbusd_serusb
    Host/CPU: card driver
</t>
<t tx="ntallen.20120824140516.1576">PORT (
    INTA        : IN     std_ulogic;
    BdIntr      : OUT    std_ulogic;
    RData       : OUT    std_logic_vector (15 DOWNTO 0);
    ExpAck      : OUT    std_ulogic;
    F8M         : IN     std_ulogic;
    rst         : IN     std_ulogic
);

To signal an interrupt, drive BdIntr to '1'.
Do not update BdIntr while INTA is high.
If BdIntr was asserted during INTA, clear it

Logic for this is in Intr state machine

Do not assert ExpAck When INTA is '1'. (syscon acknowledges)

The card must also support an interrupt control register at the base address.
On write, bit 5 of the interrupt control register is the interrupt enable bit.
It should default to disabled. The BdIntr should only be asserted if there

</t>
<t tx="ntallen.20120824140516.1577">If any board asserts their assigned BdIntr pin, asserts interrupt (status(2)) back to FPGA/CPU

Recognizes a subbus read on address X"0040" as an interrupt acknowledge cycle.
Asserts INTA for the same duration as ExpRd
Reports the BdIntr vector (which should be stable throughout INTA)</t>
<t tx="ntallen.20120824140516.1578">Static table mapping card base address to interrupt vector bit
Accepts interrupt attach requests mapping a card base address to an interrupt ID
Polls status port for interrupt pin (status(2))
On interrupt, reads from INTA address (X"0040")
For each bit that is set, report the interrupt code (I&lt;n&gt;) where '&lt;n&gt;' is the interrupt ID

</t>
<t tx="ntallen.20120824140516.1579">Accepts interrupt attach requests mapping a card base address with a struct sigevent,
allowing client to receive a signal or pulse when the interrupt arrives.
</t>
<t tx="ntallen.20120824140516.1580">Create a pulse
Call subbus_int_attach() to map card base address to this pulse
Service pulse to handle interrupt
</t>
<t tx="ntallen.20120904164051.1587">State Machine, handles:
    Configuration of I2C Master (set rate, enable interrupts, engine)
    Initialize switch interface? (or is that done at a higher level?)
Commands:
    WrI2C: Writes I2Cwdata out with or without stop. This is used to write address data as well,
      which means the r/w bit must be encoded with the address at a higher level.
      If no ACK is observed, a stop transition is output before Done is asserted.
    RdI2C: Read one byte with NACK. Address is on I2Cwdata.

    i2c_init {
      set clock divisor, enable core and interrupts
        wr_i2ctop("000", X"0E"); -- LSB
        wr_i2ctop("001", X"00"); -- MSB
        wr_i2ctop("010", X"CO"); -- enable core and interrupts
        set Done
    }
    loop {
      if (WrI2C) wr_i2c(I2Cwdata, WrStart, WrStop);
      elsif (RdI2C) rd_i2c(I2Cwdata);
      if (!Err) Done &lt;= 1;
    }
    
    wr_i2c( data, start, stop ) {
        wr_i2ctop("011", data);
        wr_i2ctop("100", start + stop + WR + IACK); // wait for Intr
        stat &lt;= rd_i2ctop("100");
        if ( stat(7) == 0 ) { // ACK
          //if ( stop ) Done &lt;= 1 // not here! at top level
        } else {
          if (stat(5)) { // Lost Arbitration (SDA stuck)
            delay(40msec); // and then what? try again?
          }
          wr_i2ctop("100", STO + IACK); // wait for Intr
          Err &lt;= 1;
        }
    }
    rd_i2c( addr ) {
        wr_i2c(addr(7:1) &amp; 1, 1, 0);
        if (Done || Err) return;
        wr_i2ctop("100", RD + NACK + STO + IACK); wait for Intr
        I2Crdata &lt;= rd_i2ctop("011");
        Done &lt;= 1;
    }
    // abstracting wr_i2ctop would save a couple states at the top
    // level and introduce more below, so inline it.
    wr_i2ctop(addr, data) {
      wb_adr_i &lt;= addr;
      wb_dat_i &lt;= data;
      wb_we_i &lt;= '1';
      wb_cyc_i &lt;= '1';
      wb_stb_i &lt;= '1';
      wait until wb_ack_o = '1';
      wb_cyc_i &lt;= '0';
      wb_stb_i &lt;= '0';
      if (addr = "100" AND data &amp; IACK) {
        wait until wb_ack_o = '0' and wb_inta_o = '0'
        wait until wb_inta_o = '1'
      } else {
        wait until wb_ack_o = '0'
      }
    }</t>
<t tx="ntallen.20120904164051.1588">Talks to LK204_I2C
    initialize devices {
      LK204
        Auto Keypress Off X"80" X"FE" X"4F"
      PCA9554
        Set Direction X"40" X"03" X"HH"
        Set Polarity  X"40" X"02" X"HH" (optional)
        Set Output    X"40" X"01" X"HH"
    loop {
        if (!wqueue_empty) {
            read(char, lk204, isempty);
            loop_1 {
              if (lk204) CurAddr &lt;= X"80";
              else CurAddr &lt;= X"40";
              LK204_I2C(Wr, STA, !STO, CurAddr);
              WData &lt;= char;
              loop_2 {
                LK204_I2C(Wr, !STA, isempty, char);
                if (isempty) break loop_1;
                read(char, new_lk204, isempty);
                if (new_lk204 != lk204) {
                  lk204 &lt;= new_lk204;
                  break loop_2;
                }
              }
            }
        } else if (timeout_100msec) {
            read switch status
              LK204_I2C(Wr, STA, !STO, X"40");
              LK204_I2C(Wr, 0, !STO, 0); // input port
              LK204_I2C(Rd, STA, !STO, X"41"); //read
            if (!rqueue_full) {
                read for data until no more data
              loop {
                LK204_I2C(Wr, STA, !STO, X"80");
                LK204_I2C(Wr, !STA, !STO, X"FE");
                LK204_I2C(Wr, !STA, !STO, X"26");
                rdkey = LK204_I2C(Rd, STA, !STO, X"81");
                if (rdkey == 0) break;
                write rdkey to keyfifo
                if (rdkey(7) == 0) break;
              }
            }
            reset timeout
        }
    }
</t>
<t tx="ntallen.20120910090627.1591">I2C Devices:
    LK204 Address 80:
        Write to send data to the display
        [Write GPO]
        [Read GPO State]
        [Read Customer Data]
        Read Version Number
        Read Module Type
        [Read One-Wire Devices]
        Poll Key Press (read char from keypad)
    PCA9554 I/O Expander Addres 4X:
        Set direction
        Set polarity
        Write byte
        Read byte
        </t>
<t tx="ntallen.20120910090627.1592">BA=Base Address
    BA: Interrupt Control Reg: Write-only
        D5: Interrupt Enable
    
    LK204
    BA+2: W: Data(7:0): Single char to display controller.
             Data(8): LkWrEn. Should be 1 on last byte, zero on earlier
                bytes in order to ensure accurate interpretation of
                escape sequences
             No response anticipated
    BA+2: R: Read keypress data
    
    PCA9554
        [Initialization of direction/polarity is hard coded]
    BA+4: W: Set GPIO output port
             Add bitwise set/reset
    BA+4: R: Read GPIO input port and/or status?

    Status (bits TBD):
        0: LK204 Initialized successfully
        1: PCA9554 Initialized successfully
        2: LK204 ACK
        3: PCA9554 ACK
        4: Key Pressed (RQueue NonEmpty)
        5: WQueue NonEmpty
        6: WQueue Full
        7: LKWrEn
        8-15: Switch Status
          8: Bat Purge Switch
          9: Land Switch
          12: Bat Purge LED \ 
          13: Land LED \

Change switch status to report just the two bits we are actually using as well as the state of the two outputs (LEDs) we are using.

Change the format of the write-to-gpio to be bitwise set/reset. In the polling loop, if a switch is closed, change desired state of output LEDs. In Wr, when reading commands from queue, update desired state, then whenever desired state is different from the current state, write out the desired state.

And do this all after testing with the current design to make sure I understand the switch status and LED output polarities, etc.</t>
</tnodes>
</leo_file>
