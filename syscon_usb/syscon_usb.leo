<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ntallen.20100519134237.1502"><vh>@chapters</vh></v>
<v t="ntallen.20100519134237.1501" a="E"><vh>Syscon USB</vh>
<v t="ntallen.20100601150619.1289"><vh>Todo</vh>
<v t="ntallen.20100805085605.1308"><vh>Diagnose Slowness</vh></v>
<v t="ntallen.20100805085605.1309"><vh>Implement timeout in subbusd</vh></v>
<v t="ntallen.20100805085605.1305"><vh>Indexer Features</vh>
<v t="ntallen.20100805085605.1307"><vh>Interrupts</vh>
<v t="ntallen.20100816115707.1311"><vh>API: subbuslib</vh></v>
<v t="ntallen.20100816115707.1312"><vh>Library implementation</vh></v>
<v t="ntallen.20100816115707.1313"><vh>subbusd implementation</vh>
<v t="ntallen.20100816115707.1314"><vh>USB</vh>
<v t="ntallen.20100816115707.1316"><vh>subbusd</vh></v>
<v t="ntallen.20100816115707.1317"><vh>syscon_usb</vh></v>
<v t="ntallen.20100816115707.1318"><vh>DACS</vh></v>
</v>
<v t="ntallen.20100816115707.1315"><vh>Syscon104</vh></v>
</v>
</v>
</v>
<v t="ntallen.20100827154528.1331"><vh>subbusd (here for visibility)</vh></v>
<v t="ntallen.20100907120439.1333"><vh>syscon_usb</vh></v>
</v>
<v t="ntallen.20100520123955.1247"><vh>Development Issues</vh>
<v t="ntallen.20100519134237.1503"><vh>12.1 Upgrade</vh></v>
<v t="ntallen.20100524120730.1249"><vh>ISE/XPS/SDK</vh>
<v t="ntallen.20100524120730.1250"><vh>Bit Stream</vh></v>
<v t="ntallen.20100524120730.1251"><vh>PROM</vh></v>
</v>
<v t="ntallen.20100524120730.1253"><vh>QNX</vh>
<v t="ntallen.20100602103230.1293"><vh>Library Strategy</vh></v>
<v t="ntallen.20100602103230.1294"><vh>Alternate Strategy</vh></v>
<v t="ntallen.20100602103230.1295"><vh>Driver? The winner!</vh></v>
<v t="ntallen.20100607110403.1299"><vh>sbtest</vh></v>
<v t="ntallen.20100610083250.1301"><vh>Simulation problem</vh></v>
</v>
<v t="ntallen.20101123111757.1383"><vh>Revision Control</vh>
<v t="ntallen.20101123111757.1384"><vh>HDS archive</vh></v>
<v t="ntallen.20101123111757.1385"><vh>SDK archive</vh></v>
<v t="ntallen.20101123111757.1386"><vh>ISE archive</vh></v>
</v>
<v t="ntallen.20101215085413.1391"><vh>12.3 Upgrade</vh>
<v t="ntallen.20101215085413.1392"><vh>ISE</vh></v>
<v t="ntallen.20101215085413.1393"><vh>XPS</vh></v>
<v t="ntallen.20101215085413.1394"><vh>SDK</vh></v>
</v>
</v>
<v t="ntallen.20100525090916.1257" a="E"><vh>Development Plan</vh>
<v t="ntallen.20100525090916.1259" a="E"><vh>Document Serial Protocol</vh>
<v t="ntallen.20110123092829.1413"><vh>Error Codes</vh></v>
</v>
<v t="ntallen.20100803111918.1303"><vh>IPC</vh></v>
<v t="ntallen.20101102122701.1377"><vh>Syscon Features</vh>
<v t="ntallen.20101102122701.1378"><vh>Tick</vh></v>
</v>
<v t="ntallen.20100525090916.1258"><vh>Done: Update Syscon</vh>
<v t="ntallen.20100525090916.1263"><vh>Read Operation</vh></v>
<v t="ntallen.20100525090916.1264"><vh>Write Operation</vh></v>
<v t="ntallen.20100527162821.1273"><vh>Implemented syscon VHDL module</vh>
<v t="ntallen.20100527162821.1274"><vh>Done: Update XPS Proj</vh></v>
<v t="ntallen.20100527162821.1275"><vh>Update SDK Proj</vh></v>
<v t="ntallen.20100527162821.1278"><vh>Update ISE Proj</vh>
<v t="ntallen.20100527162821.1277"><vh>Done: Create new top-level VHDL</vh></v>
<v t="ntallen.20100527162821.1279"><vh>Bring in syscon, indexer</vh></v>
<v t="ntallen.20100528083113.1287"><vh>Add reset pin to ctrl bus</vh></v>
<v t="ntallen.20100527162821.1276"><vh>Update ucf</vh></v>
</v>
</v>
</v>
<v t="ntallen.20100525090916.1260"><vh>Done: Implement Subbus Library</vh></v>
<v t="ntallen.20101102122701.1375"><vh>Implement Subbus/Syscon Library</vh></v>
<v t="ntallen.20100525090916.1261"><vh>Indexer: Simulated</vh></v>
<v t="ntallen.20100525090916.1262"><vh>A/D VHDL: Simulated</vh>
<v t="ntallen.20110331101033.1427"><vh>Rework 110331</vh></v>
<v t="ntallen.20101013150328.1339"><vh>Convert Clock</vh></v>
<v t="ntallen.20101013150328.1340"><vh>A/D =&gt; RAM</vh></v>
<v t="ntallen.20101013150328.1341"><vh>RAM =&gt; Front End</vh></v>
<v t="ntallen.20101013150328.1342"><vh>Subbus RW</vh></v>
<v t="ntallen.20101013150328.1343"><vh>RAM Configuration</vh>
<v t="ntallen.20101014082117.1355"><vh>Simple Dual-ported RAM</vh></v>
<v t="ntallen.20101014082117.1357"><vh>ana_ram</vh></v>
</v>
<v t="ntallen.20101013150328.1344"><vh>Basic Operation</vh></v>
<v t="ntallen.20101013150328.1345"><vh>Enhanced Operations</vh>
<v t="ntallen.20101013150328.1346"><vh>Configuration Readback</vh></v>
</v>
<v t="ntallen.20101019142341.1359"><vh>Design Hierarchy</vh>
<v t="ntallen.20110122074609.1411"><vh>ana_addr</vh></v>
<v t="ntallen.20101022104642.1372"><vh>ana_subbus</vh></v>
<v t="ntallen.20110118143100.1403"><vh>ana_data_ram</vh>
<v t="ntallen.20110118143100.1404"><vh>ana_data_rd</vh></v>
<v t="ntallen.20101019142341.1363"><vh>ana_ram</vh></v>
</v>
<v t="ntallen.20110118143100.1405"><vh>ana_cfg_ram</vh>
<v t="ntallen.20101019142341.1363"></v>
</v>
<v t="ntallen.20101022104642.1371"><vh>ana_hwside</vh>
<v t="ntallen.20101019142341.1364"><vh>ana_acquire</vh>
<v t="ntallen.20110118143100.1406"><vh>sub-muxing</vh></v>
</v>
<v t="ntallen.20101019142341.1362"><vh>ana_s16</vh></v>
<v t="ntallen.20101019142341.1360"><vh>ana_s5</vh>
<v t="ntallen.20101019142341.1361"><vh>ana_s5s</vh></v>
</v>
</v>
</v>
</v>
<v t="ntallen.20100920151402.1335"><vh>Digio VHDL: Simulated</vh>
<v t="ntallen.20100920151402.1336"><vh>Basic Specs</vh></v>
</v>
<v t="ntallen.20101102122701.1376"><vh>D/A VHDL</vh></v>
<v t="ntallen.20110203162516.1415"><vh>PTRH</vh>
<v t="ntallen.20110418174231.1430"><vh>I2C</vh></v>
<v t="ntallen.20110203162516.1416"><vh>SHT21</vh></v>
<v t="ntallen.20110203162516.1417"><vh>MS5607</vh></v>
<v t="ntallen.20110206160145.1421"><vh>Overall Sequence</vh></v>
<v t="ntallen.20110207112658.1424"><vh>Status Word</vh></v>
<v t="ntallen.20110419111719.1433"><vh>PTRH DPRAMS</vh></v>
<v t="ntallen.20111025151610.1437"><vh>I2C_SM</vh></v>
</v>
<v t="ntallen.20111024112337.1435"><vh>PTRH MUX</vh>
<v t="ntallen.20111114100408.1439"><vh>Register Map</vh></v>
<v t="ntallen.20111123115724.1441"><vh>Generics</vh></v>
</v>
<v t="ntallen.20110227134141.1425"><vh>Counters</vh></v>
<v t="ntallen.20110418174231.1429"><vh>LTC4151</vh></v>
<v t="ntallen.20111212160628.1443" a="E"><vh>QCLI Serial Interface</vh>
<v t="ntallen.20111212160628.1444"><vh>Subbus Interface</vh></v>
<v t="ntallen.20111212160628.1445"><vh>QCLI Interface</vh></v>
<v t="ntallen.20111212160628.1447"><vh>Engine Operation</vh></v>
</v>
</v>
<v t="ntallen.20100823102718.1327" a="E"><vh>Documentation</vh>
<v t="ntallen.20100525090916.1259" a="E"></v>
<v t="ntallen.20100824101804.1329"><vh>Document API</vh></v>
</v>
<v t="ntallen.20110115103957.1399"><vh>Revisions</vh>
<v t="ntallen.20110115103957.1400"><vh>DACS_V1_0_ISE</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ntallen.20100519134237.1501">@nocolor
</t>
<t tx="ntallen.20100519134237.1502"></t>
<t tx="ntallen.20100519134237.1503">Copied Syscon_rC from K

Performed the following steps several time (with clean copies from K)
Each time, I copied IP from the 11.1 distribution into the 12.1
Copying the old clock_generator 3.01.a did not work, but I just changed the
version to 4.00.a, since the ports never changed...

Opened in ISE 12.1 (upgraded)
Opened system.xmp (requires upgrade...)
  upgrading: microblaze, mdm
  upgrading xps_epc
  clock_generator can be updated from 3.01.a to 4.00.a (incompatible)
    CLK_IN sys_clk_s
    CLKOUT0 clk_60_0000MHz
    RST net_gnd
    LOCKED Dcm_all_locked
    Done
    
  cpu driver update 1.12.a to 1.12.b
  incompatible driver updates for bram, gpio and uartlite
    not done...

Tried to run "implement design"
  </t>
<t tx="ntallen.20100520123955.1247"></t>
<t tx="ntallen.20100524120730.1249">Xilinx provides multiple GUI frameworks for developing using processors.
ISE provides the most control over synthesis and routing.
XPS is a more high-level tool for piecing together IP
SDK is for software and can be invoked from either ISE or XPS.

It is possible to do entire designs in XPS/SDK. When working with a lot of VHDL, it may be easier to use ISE, including the XPS project as one component. That is the current strategy for this project. Hence we need to use all three GUI frameworks.

The ISE project is the root. (Syscon_rC)
The XPS project is found in the "system" subdirectory. XPS should be invoked from ISE by opening system.xmp, not directly.
SDK can be invoked directly or from either XPS or ISE. The SDK projects are under system/SDK.

</t>
<t tx="ntallen.20100524120730.1250">ISE will generate the bitstream for the FPGA. For this design, we expect all the software to bit within BRAM, and as such, initialization of the software can be done with a simple PROM initialization.

To include the program in the bitstream, we apparently need to create a software project in XPS. These seems counterintuitive as Xilinx has been steadily moving us away from XPS and toward the SDK for all software. As it happens, the only thing we need to do in XPS is to create an elf-only software project that points to the .elf file we want to include, and mark that project for inclusion in the bitstream. We don't need to generate the bitstream in XPS, just make that connection. (This is also odd: we don't use XPS to generate the bitstream or the software, but that's still the place we have to go to connect the two, even when the top level design is in ISE.)

Once the connection is made, the "Generate Programming File" option in ISE will create system_download.bit, which differs from system.bit in that it includes the software.
</t>
<t tx="ntallen.20100524120730.1251">We are using an SPI PROM to initialize the FPGA. The configuration is detailed in
http://www.xilinx.com/support/documentation/application_notes/xapp974.pdf

We are using the Indirect in-system programming (ISP) approach.

Note that the FTDI USB interface we are using also has its own connection to the SPI PROM, so we have the option to program it using iMPACT through the FPGA, or using FTDI's program and programming via USB.

To program the PROM, we need to reformat the bit file. The app note lists the command:
    promgen -spi -p mcs -o spi_prom.mcs -s 8192 -u 0 dacs_download.bit

In iMPACT, need to added SPI PROM to the design. The part on the FTDI board is M25P20.</t>
<t tx="ntallen.20100524120730.1253">The DLP board uses the FTDI FT2232D (0x0403,0x6010), but it is reportedly supported
by the devc-serusb driver, which is listed as supporting FT8U232AM (0x0403,0x6001)

I will try specifying the device ID on the devc-serusb command line

Apparently what I need is:
    /sbin/devc-serusb -d vid=0x0403,did=0x6010,module=ftdi

Some instability on removal, but insertion seemed to work fine.
Devices /dev/serusb1 and /dev/serusb2 show up.
</t>
<t tx="ntallen.20100525090916.1257"></t>
<t tx="ntallen.20100525090916.1258">I'm inclined to review the code for read and write and consider implementing some of it in VHDL.
The read logic is faulty, since it resets EXPRD before reading in the data (which is not latched in hardware)</t>
<t tx="ntallen.20100525090916.1259">&lt;hex16&gt; : [0-9A-F]{4}
&lt;addr&gt; : &lt;hex16&gt;
&lt;addr_list&gt; : &lt;addr_list_elt&gt;
            : &lt;addr_list&gt; ',' &lt;addr_list_elt&gt;
&lt;addr_list_elt&gt; : &lt;addr&gt; [ ':' &lt;addr&gt; ':' &lt;addr&gt; ]
&lt;data&gt; : &lt;hex16&gt;
&lt;cmdline&gt; : &lt;cmd&gt; '\n'
&lt;bit&gt; : '0' | '1'
&lt;multi_resp&gt; : ( ( 'M' | 'm' ) &lt;data&gt; )+ ['E' &lt;digit&gt;]
&lt;cmd&gt; :
    R &lt;addr&gt;    // Read: response codes: RrE
    W &lt;addr&gt; : &lt;data&gt;  // Write: response codes: WwE
    C &lt;bit&gt;    // CMDENBL: response codes: CE
    S &lt;bit&gt;    // CMDSTRB: response codes: SE
    V          // Board Revision: response codes VE
    B          // Board Logical Reset: response: 0? ###
    I &lt;digit&gt; : &lt;addr&gt; // Define and enable Interrupt: response: i &lt;digit&gt;
    I &lt;digit&gt;  // Undefine and disable Interrupt: response: i &lt;digit&gt;
    ''         // NOP: response code: 0
    M &lt;addr_list&gt;
    D          // Read switches: response: D&lt;data&gt; | E&lt;digit&gt; (no switches)
    F &lt;data&gt;   // Set failure: response: F | E
    F          // Read failure: response F &lt;data&gt; | E
    T          // Tick to reset 2-minute timeout: No response

Responses:
    R &lt;data&gt; '\n'  // Read data with acknowledge asserted
    r &lt;data&gt; '\n'  // Read data without acknowledge asserted
    W '\n'         // Write with acknowledge
    w '\n'         // Write without acknowledge
    S &lt;bit&gt; '\n'   // CMDSTRB value
    C &lt;bit&gt; '\n'   // CMDENBL value
    V &lt;version&gt; '\n' // Version string
    I &lt;data&gt; '\n'  // Interrupt string
    i &lt;digit&gt; '\n' // Acknowledge Interrupt config command
    0 '\n'         // NOP
    D &lt;data&gt; '\n'  // Switch data
    E &lt;digit&gt; '\n' // Error--not obviously associated with a specific request
    F &lt;data&gt; '\n'  // Failure status
    &lt;multi_resp&gt; '\n'

B - Board Logical Reset: issue hardware reset to syscon, disable all interrupts.
    Does *not* reset the two-minute timer. (that's what "tick" does.) The reason for
    making the distinction is that the board reset will be issued when subbusd
    starts up, whereas tick will be issued by the actual data acquisition
    functions, indicating that the entire instrument is up and running. There
    is a lot that can go wrong between those two events, including spontaneous
    reboots, and we don't want the startup of subbusd to prematurely indicate
    that all is well.</t>
<t tx="ntallen.20100525090916.1260"></t>
<t tx="ntallen.20100525090916.1261"></t>
<t tx="ntallen.20100525090916.1262"></t>
<t tx="ntallen.20100525090916.1263">Make sure data bus is set for input
Set EXPADDR
Set EXPRD
&lt;wait for 1 usec&gt;&lt;could be a hardware test&gt;
Record value of EXPDATA and EXPACK
Reset EXPRD</t>
<t tx="ntallen.20100525090916.1264">Set EXPDATA direction to output
Set EXPADDR
Set EXPDATA
Set EXPWR
&lt;wait for 1usec&gt;&lt;could be hardware timer&gt;
Record value of EXPACK
Reset EXPWR
Reset EXPDATA direction to input
</t>
<t tx="ntallen.20100527162821.1273"></t>
<t tx="ntallen.20100527162821.1274">Reduced the number of GPIO instantiations by combining control and status bits.</t>
<t tx="ntallen.20100527162821.1275">Rewrite read/write operations to use the control and status ports and wait on the Done bit.
</t>
<t tx="ntallen.20100527162821.1276"></t>
<t tx="ntallen.20100527162821.1277"></t>
<t tx="ntallen.20100527162821.1278"></t>
<t tx="ntallen.20100527162821.1279">Brought in syscon_arch.vhd from HDS. Tried several ways to add to project. I want my vhdl to go in a subdirectory so it's separated from the mess of files in the root. "Add Copy of source file" does not allow you to say where you want to copy the source file. The approach that seems to work is to manually copy the source file into the vhdl directory, and then "Add source file" to link it into the project.

</t>
<t tx="ntallen.20100528083113.1287">and propogate through syscon and dacs and the subbus code
This could be handled via the processor reset: that's a discussion we need to have.

</t>
<t tx="ntallen.20100601150619.1289"></t>
<t tx="ntallen.20100602103230.1293">Shared objects:  oooo!

Original implementation loaded the single library that happened to be there, and then could query it to figure out what it was.

This approach might be more like asking for a particular library, perhaps by command-line option, and supporting multiple libraries.

Default behavior should be to load a single library, and perhaps by command-line option, and have the usual functions work

    driver
        Attempt to load some compile-time set of drivers, accepting the first found
    driver -s &lt;name&gt;
        Load the specified driver as the primary

After that, could provide APIs for loading multiple drivers

To support multiple drivers, we can't use the same function names in each driver, or they will be overwritten or otherwise conflicted.</t>
<t tx="ntallen.20100602103230.1294">Create apps linked separately against one or the other. Either:
    -l subbus
or
    -l subbus-usb

The executables could be segregated by hardware or by name

An alternate flavor of the subbus-usb library could use different names for the interface functions, which would allow for linking both into the same app. That would most likely be implemented by (optional) macros that recast the function names, so by recompiling, an app could use the same names, but access the alternate library.</t>
<t tx="ntallen.20100602103230.1295">I probably need a driver to arbitrate access to the serial device, though I can try to get away with the existing subbus library's arbitration scheme.

First implemented driver to arbitrate access to the serial device, but it also helps solve the interrupt problem clearly and also makes the linking of applications unambiguous without playing games. There is only one libsubbus which communicates with the subbus driver. There can be multiple subbus drivers (and will be at least two), but any application that addresses the subbus will be able to operate using either without recompilation.
</t>
<t tx="ntallen.20100607110403.1299">Currently I can control cmdenbl and direction, which suggests that addresses are working,
but I always read back zeros. Changing cmdenbl should produce a 0x8000 from the channel status

Driving in zero or out zero produces a change in direction, but driving out a non-zero
amount has not produced steps, leading me to believe the data value is coming through as zeros

Routing output data &lt;0&gt; to a pin to see if it is coming through
Then may try separating input and output into separate ports

output data bus bit order was wrong. Should have been [15:0], but was [0:15]

Input data is still not registering.

subbus_data_i (between system and syscon) shows non-zero data during ExpRd. It continues to the end of RdEn unless ExpAck is asserted (read_ack( 0, &amp;data ))
</t>
<t tx="ntallen.20100610083250.1301">Unexpected SEH</t>
<t tx="ntallen.20100803111918.1303">Four components:
    subbus_usb library
    subbusd driver
    serusb driver
    syscon_subbus

subbus_usb communicates with subbusd via IO_MSG messages:
    These have a standard _io_msg hdr with type _IO_MSG
    combine_len 0
    mgrid SUBBUSD_MGRID
    subtype 0
    Sent via MsgSend or MsgSendv

subbusd communicates with serusb driver via read/write
serusb communicates with syscon_subbus via USB
</t>
<t tx="ntallen.20100805085605.1305"></t>
<t tx="ntallen.20100805085605.1307">Need to figure out the whole architecture.
Now that I have a dedicated driver, implementation on the QNX side should be
pretty straightforward. Interrupt should cause syscon to issue an appropriate
"I\d\n" string.

QNX6 indexer code includes all the interrupt processing stuff that had been extracted
into intserv. I would like indexer driver to work on either subbus architecture, so
that means changes need to be pushed to the driver:
    Create subbusd for syscon104
        Copy subbusd, then copy in the libsubbus stuff to address the hardware
    Promote libsubbus_usb to be libsubbus, i.e. all programs will use it
    Incorporate intserv capabilities in both drivers

Old architecture:
    we did not know which boards would be plugged in when the interrupt circuit was laid out
    Any board that could produce an interrupt (indexer, mainly) could be programmed to:
        a) assert the interrupt
        b) respond on one of four INTA addresses
        c) respond by driving its status on one of 8 data bits
    The interrupt driver would:
        configure each board, given knowledge of the physical region
        attach the single subbus hardware interrupt
        respond to the interrupt with reads from any of the four INTA addresses in use
        check which bits request service and map those back to original requestor
    The regions were a way to support subbus expansion via a repeater where the
    strategy of driving single lines on the databus would break down. The software
    configuring the board had to know what region the board was in physically.
DACS architecture:
    we know going in exactly which components may request an interrupt, so we
    can wire them directly into the acknowledge without configuration.
    Move acknowledge responsibility into uBlaze. uBlaze will have a table
    of bits and base addresses. When service is requested, it will read
    from INTA address and report: IXXXX where XXXX is the board base address.
    Alternately, it could report IB where B is the bit number and we could
    pass the responsibility back to subbusd, but that would mean subbusd is
    tightly coupled with a specific FPGA configuration. Requiring the uBlaze
    code to be tightly coupled with the circuit makes more sense.
</t>
<t tx="ntallen.20100805085605.1308">Add another IO port to expose timing. 4 bits?
Show:
    start of receive to end of send
    start of addressing HW
    end of addressing HW

Might need to do the same with the parallel port on the PC end.
</t>
<t tx="ntallen.20100805085605.1309"></t>
<t tx="ntallen.20100816115707.1311">This API was actually handled by a separate driver in QNX4 known as IntSrv. Part of the idea was to support both "Experiment Interrupts" on the subbus and other interrupts to the processor itself, allowing unprivileged processes to receive proxies when interrupts arrived. I don't know if we'll need that capability going forward, but I plan to add the ExpInt stuff to the new subbus lib (currently named subbus_usb)

These were previously called "IntSrv_Int_attach/detach" but I will change the prefix.

int Subbus_Int_attach( char *cardID, unsigned short address,
    						int region, struct sigevent event );

  cardID is a application-selected name for the function that is being addressed.
  address is the subbus base address for the specified function
  region is reserved for a mechanism to support interrupts in disjoint bus segments.
    Should be zero for subbus_usb, may be non-zero for syscon104
    Wait, no, the application (e.g. idx64) should not need to know
    what library is in use, so this value should be compatible.
  event specifies how the application wants to be notified
  
  Returns 0 on success
  Errors include interrupt already attached (but may check...)

int Subbus_Int_detach( char *cardID );
</t>
<t tx="ntallen.20100816115707.1312">int Subbus_Int_attach( char *cardID, unsigned short address,
    						int region, struct sigevent event );
int Subbus_Int_detach( char *cardID );

The library will package these requests and forward them to subbusd. The library is not responsible for handling the resulting events, as they need to be worked into the applications event loop.
</t>
<t tx="ntallen.20100816115707.1313">The interrupt implementation in subbusd is necessarily hardware dependent.
I can reuse the bookkeeping code from QNX4/intserv</t>
<t tx="ntallen.20100816115707.1314"></t>
<t tx="ntallen.20100816115707.1315">The implementation here will match the existing implementation in intserv.</t>
<t tx="ntallen.20100816115707.1316">int Subbus_Int_attach( char *cardID, unsigned short address, int region, struct sigevent event );
int Subbus_Int_detach( char *cardID );

For USB, subbusd will maintain some bookkeeping to associate a specific interrupt code with a specific event, and will send the syscon_usb information to configure the interrupt. When the associated "I" code is returned, subbusd will trigger the specified event.

(Since subbusd_usb is tightly coupled with syscon_usb, we don't need to worry too much about making the protocol future-proof, anticipating all possible hardware implementations. For now, I think it should be sufficient
to specify that I want to configure the board at address A with interrupt code N.)

Functions required:
    configure function at address A to respond with interrupt code N
    disable interrupt N
    disable all interrupts
</t>
<t tx="ntallen.20100816115707.1317">Functions required:
    configure function at address A to respond with interrupt code N
    disable interrupt N
    disable all interrupts

The software running on syscon_usb will know what functions are defined.
"Interrupts" will actually be implemented via polling, since that is how
the software runs anyway. All functions that have interrupt capability
will have their interrupt status lines connected to a single interrupt
status register. The bits of the status register are or-ed together
to provide a single bit to signal interrupt activity to the processor.

On each poll cycle, the interrupt status bit will be read.
If it is non-zero, an INTA cycle will be produced, and the returned
value will be the interrupt status register. An "I" code will be
transmitted on the USB for each active bit in the status register.

The software will have
a table to map addresses to status bits. When a function is enabled,
the hardware will be programmed (as in the description of idx64
interrupt configuration) although the bit selection will not be
configurable, since it will be firm-wired. The hardware will still
respond to the specified INTA address (which should be 0x40 for all
functions--doesn't even need to be configurable, really)
</t>
<t tx="ntallen.20100816115707.1318">In the firmware:
    DACS:
        System:
            +Need ExpIntr Bit input: added to status
        Syscon:
            +Collect BdIntr outputs from boards, or them and deliver expintr bit as output
            +Respond to INTA by writing expintr vector
            +Provide INTA output
            +extend test bench
                +Test that reading from 0x40 generates INTA and Data_i shows BdIntr values
                +Test that non-zero value on BdIntr generates non-zero value on ExpIntr
            +Need to provide N_BOARDS generic and make ExpAck a vector
        extend test bench
    gxidx:
        +Add BdIntr output
        +Add INTA input, pass through to channels
        +extend test bench
        decode:
            +Add Interrupt enable logic
            +Add BdIntr output
            +Add Ireq Input vector
            +Add logic mapping Ireq vector to BdIntr
            +Eliminate INTA output/decoding
            +extend test bench
            +Make base address GENERIC
        channel:
            +Add INTA input
            +Add Ireq output
            +Add Running output
            +extend test bench
        Intr:
            Write test bench: HDS doesn't like that--do it at channel level instead</t>
<t tx="ntallen.20100823102718.1327"></t>
<t tx="ntallen.20100824101804.1329">Generating doxygen documentation in source code.</t>
<t tx="ntallen.20100827154528.1331">done: Make sure subbusd/serusb returns SBS_ACK and SBS_NACK status
done: Interrupt functions should have a way to return to client on error without enqueuing command to serusb.
done: Need to implement interrupt attach/detach functions
done: Need to implement timeout and error returns
    timer_create() to create a timer and associate it with a pulse</t>
<t tx="ntallen.20100907120439.1333">Implement all of the protocol defined in serusb/README
Done: Get subbus source into subversion
</t>
<t tx="ntallen.20100920151402.1335"></t>
<t tx="ntallen.20100920151402.1336">120 direction-selectable I/O channels in 15 banks of 8
  Half go to connector board, half to power board
  One 8-bit bank is split between the two boards, but still has
  a single direction select.
8 bidirectional channels to connector board
8 bidirectional channels to the power board

Indexer I/O needs to be carved out of this space

Looks like one "board" of two "connectors" in the Digio64 nomenclature
would do the trick, leaving 3 ports for indexer usage.

DIG_BASE_ADDR 0x800
DIG_CONN_OFFSET 0x20
DIG_CONN_PER_BD 2
DIG_BD_NUM 0
DIG_RESET_OFFSET 0x18

DIGIO_BASE_ADDR DIG_BASE_ADDR + (DIG_CONN_OFFSET*DIG_CONN_PER_BD*DIG_BD_NUM)


</t>
<t tx="ntallen.20101013150328.1339">Upper limit is determined by the time to transfer the data out of the converters.

Simulation give (.182 - .0867) ms = .095 ms between samples of a single channel.
That gives a conversion rate on the order of 10500 conversion/second.
Sub-muxed channels will be converted at only 1316 conversions/second.</t>
<t tx="ntallen.20101013150328.1340"></t>
<t tx="ntallen.20101013150328.1341"></t>
<t tx="ntallen.20101013150328.1342"></t>
<t tx="ntallen.20101013150328.1343">BRAM comes in 9Kb blocks which can be configured in various ways:
    As a simple memory, 512x16 where we provide all arbitration
    As a full dual-ported RAM 512x16 where we provide arbitration on the hardware side
    As a simple dual-ported RAM 512x16 or 256x32.
      We would need two 9kb BRAMs, but no additional arbitration.
      </t>
<t tx="ntallen.20101013150328.1344">There are 128 16-bit analog inputs.
Most recently recorded values for channel i can be read from subbus address:
    BASE_ADDRESS + 2*i
BASE_ADDRESS is probably 0x0C00, so read addresses run from 0x0C00 to 0x0CFE

The front end is configured with a 5-bit code. This is programmed by
writing to the same address as the input channel.</t>
<t tx="ntallen.20101013150328.1345"></t>
<t tx="ntallen.20101013150328.1346">For each channel, i, a second 16-bit word can be read from:
    BASE_ADDRESS + 2*i + 1
immediately after reading a channel.
This word includes the 5 bits of configuration and 11 bits of
frame counter. This value is latched when the channel is
read, so providing the next read is from the config address,
it will be correctly mated with the data. The address could
be checked against the latched address to make sure the
value matches.

The configuration value will be read back from the front-end
hardware so as to guarantee that we are reporting the
configuration that was actually in use when the data was
converted.
</t>
<t tx="ntallen.20101014082117.1355">Storage of A/D data (16 bits) and configuration readback (5 bits)
requires a total of 128 x 21 bits. This maps into a simple dual-
ported RAM at 256x32.

Storage of programmed configuration values (5 bits) requires
128x5 bits, which can map into lots of configurations, including
the simple dual-ported RAM at 256x32.

Reading the Spartan-6 BRAM data sheet, it appears that simultaneous
reads and writes to the same address are supported in SDP mode
providing the clocks are synchronous and the write mode is
READ_FIRST. The doc is slightly ambiguous because it defines
the SDP as having two ports with independent clocks, but then
says the collision rules are the same as for TDP, which supports
simultaneous reads when the clocks are synchronous. I guess
"independent" and "synchronous" are not mutually exclusive.</t>
<t tx="ntallen.20101014082117.1357">encapsulation of the RAMB8BWER primitive in SDP mode, 256 x 32

ENTITY ana_ram IS
  PORT (
    RD_ADDR : IN std_logic_vector(7 DOWNTO 0);
    WR_ADDR : IN std_logic_vector(7 DOWNTO 0);
    RD_DATA : OUT std_logic_vector(31 DOWNTO 0);
    WR_DATA : IN std_logic_vector(31 DOWNTO 0);
    WREN : IN std_ulogic;
    RDEN : IN std_ulogic;
    CLK : IN std_ulogic;
    RST : IN std_ulogic
  );
END ENTITY ana_ram;
</t>
<t tx="ntallen.20101019142341.1359">Using AD7687 in "Chain mode with busy indicator", Page 23 of the manual.
This requires that SDI and CNV are tied together. I will make that
association at the top level of this design.</t>
<t tx="ntallen.20101019142341.1360">Wrapper for ana_s5s state machine. Operates on the word level, so does not generate the CS output.
Note: whoever does generate the CS output must ensure the setup time requirements, specifically
 t3 = CS/ to SCK/ min 50 ns setup
 t7 = SCK to CS min 50 ns hold

ana_s5s stores the configuration data when it is read from the ana_cfg_ram.
I provide a 2-element FIFO here for two reasons:
    1: To make up the 2-column difference between read and write in ana_hwside
    2: To store up to two cfg values, since we need to store two at the end
       of each row.</t>
<t tx="ntallen.20101019142341.1361">State machine for clocking out configuration bits and generating the configuration clock.</t>
<t tx="ntallen.20101019142341.1362">State machine for clocking in data from A/D. Like ana_s5s, operates on the word level.</t>
<t tx="ntallen.20101019142341.1363">Encapsulation of BRAM block for use in simple dual ported RAM mode.
Using the BRAM_SDP_MACRO.

As noted elsewhere, the Spartan-6 BRAM does not support simultaneous
operations on both ports of a dual-ported RAM.

As currently written, the RDEN signal is delayed one clock cycle.
This was done to limit a read to a single clock cycle. I am
going to remove this, because that logic has moved up a level
into either ana_data_ram or ana_cfg_ram.

1/18/11: Switching BRAM_SIZE back to 36Kb (was 18Kb) just to make sure
I'm abiding by Xilinx's restrictions.

1/27/11: Odd: I think despite the comments in the BRAM_SDP_MACRO instantiation
template, the 36Kb option apparently failed. I'm going to try 9Kb, which
seems to make sense unless they need 2X as much storage for DP.
All this effort is pointed at getting initialization sorted out.

With BRAM_SIZE at 9Kb, we only need INIT_00-1F

Setting a non-zero INIT_ value does not seem to work during simulation. Probably I'm not using
the correct libraries.
</t>
<t tx="ntallen.20101019142341.1364">State machine generating control signals to drive ana_s5, ana_s16.
      CLK    : IN     std_logic; 30 MHz max. S5.SCK is CLK/6. S16.SCK is CLK/2
      RST    : IN     std_logic; Synch active high
      RdyIn  : IN     std_ulogic; Intended as logical and of Rdy signals from s5 and s16
      SDI    : IN     std_ulogic_vector (1 DOWNTO 0); SDI signals from each bank of A/D converters
      Addr   : OUT    std_ulogic_vector (7 DOWNTO 0); Address for our side of the two RAM banks
      Conv   : OUT    std_ulogic; Convert signal to A/D converters
      NxtRow : OUT    std_ulogic_vector (5 DOWNTO 0); Address lines for the mux
      RdWrEn : OUT    std_ulogic;
      RdyOut : OUT    std_ulogic;
      S5WE   : OUT    std_ulogic_vector (1 DOWNTO 0); Write Enable for the two S5 state machines
      RAM_BUSY : OUT  std_ulogic; Flag to avoid RAM collisions
      Start  : OUT    std_ulogic

NxtRow is so called because it represents the row of data that will
be retrieved during the next acquisition sequence. According to the
terminology in the AD7687 data sheet, acquisition comes after conversion,
and is the process of retrieving the converted value.

The low-order 3 bits of NxtRow go to the primary Muxes on the DACS
board. The higher-order bits can be used for external muxes. A
channel that is muxed will have extra bits set in the cfg_ram
flagging the fact that the channel is muxed and specifying 3 of
the bits of the address where the result will be stored.

RdWrEn is an enable line that goes to both banks of RAM. It is the
read enable on the configuration RAM and write enable on the data
RAM.

RdyOut goes high when the acquisition sequence is completed. This was intended
as a signal for external synchronization, but in the current configuration,
it is simply a flag that the next conversion/acquisition sequence will start.

Start is a signal to S5 and S16 machines to begin their sequences (or continue
their sequences).</t>
<t tx="ntallen.20101022104642.1371">This component encapsulates all the hardware interface timing.

This component caches channel configuration data between the
time it is read from the cfg_ram (as signaled by S5WE)
and when the converted data is read from the A/D and
written into the data_ram.
    Copy data from cfg cache when writing to data ram
        AcqData always reflects the cached configuration and
        latest converted data from the ana_s16(s), selecting
        based on the 'bank' bit (Addr(3))
    Set cfg cache from DO5 on S5WE</t>
<t tx="ntallen.20101022104642.1372"></t>
<t tx="ntallen.20101102122701.1375"></t>
<t tx="ntallen.20101102122701.1376"></t>
<t tx="ntallen.20101102122701.1377">Fail Lights/LEDs
I/O Switches
Tick tie in to Fail, CmdEnbl
</t>
<t tx="ntallen.20101102122701.1378">Two-second timeout should clear cmdenbl and ARM, which qualifies it
    In existing design, it is possible to set cmdenbl and then subsequently
    start ticking, which will enable cmdenbl output, or you can start
    ticking and then enable cmdenbl.
    DCCC takes advantage of this independence by setting cmdenbl independent
    of whether telemetry has started or not.
    
Two-minute timeout should light fail light (which can also be set manually)

Old behavior:
    Tick sets ARM
    ARM and cmdenbl_cmd produce CmdEnbl
    TwoSecond Timeout while ARMed
        produces Flt_CPU_Reset
        Clears ARM and CmdEnbl
        Subsequent tick will not reenable cmdenbl. An actual write to cmdenbl is required.
    Disarm command prevents Flt_CPU_Reset, disabled CmdEnbl, clears ARM

I will need a separate arm line in, plus some software logic. Will retain all of the below,
but require that Arm_in be true in order to recognize any ticks or produce reset.

I will not use a separate arm control line. I will count on CmdEnbl_cmd being reset before
a tick will be recognized, and will require a subsequent tick before CmdEnbl will be
asserted.

I will require that the software look monitor the TwoSecondTO bit of the status word
and clear CmdEnbl_cmd if it is observed. That will require the flight software to
explicitly set CmdEnbl before it will be recognized.

This does mean that a late tick could be recognized, but not before the reset is issued.
Even if it is recognized, cmdenbl will not be asserted without another explicit set.
</t>
<t tx="ntallen.20101123111757.1383">Due to the vagaries of the various tools involved, the source code
is separated into multiple modules under the arp-fpga subversion repository.</t>
<t tx="ntallen.20101123111757.1384">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/idx_fpga

This is tied into the HDL Designer Series software and represents the
VHDL code and graphical input formats (block diagrams, state machines)
within the HDS development environment.</t>
<t tx="ntallen.20101123111757.1385">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/fpga_sw/subbus

This is a project to be checked out into the XPS SDK:</t>
<t tx="ntallen.20101123111757.1386">https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/DACS_V1_0_ISE

This is the necessary components of the ISE and XPS projects. The SDK project
needs to be set up separately.

Export Hardware project to SDK
In SDK: New Board Support Package:
    Standalone
    Set stdio to mdm
New Project from SVN
    https://forge.abcd.harvard.edu/svn/arp-fpga/trunk/syscon_usb/fpga_sw
    subbus
Edit project properties
    C/C++ General
      Paths and Properties
        Includes
          Fix up microblaze include path to match selection in BSP creation
        Library Paths
          Fix up microblaze library path to match selection in BSP creation

Back in XPS, double check path to executable.
</t>
<t tx="ntallen.20101215085413.1391">Rebuilding the design from the ground up (although all the VHDL should come in without modification)
I will summarize the salient features of the designs...</t>
<t tx="ntallen.20101215085413.1392">Spartan 6
xs6slx150
fgg484
-2

EEPROM is M25P64
</t>
<t tx="ntallen.20101215085413.1393">Single processor design
Reference Clock is 100 MHz
Reset Active Low (default)
No other IP in the BSB

IP:
    clock_generator: Need to add 8MHz and 25MHz outputs
    iic (later)
    rs232 (later)
    xps_epc (copy and paste from earlier design
    GPIOs: (copy and paste)
        data
        addr
        status
        ctrl
        Data_Rdy (FTDI/epc)
        FTDI_SI
        LEDs
        Switches

Instead of using util_vector_logic, I will implement the necessary inversion in
Dacsbd_beh.vhdl

Export to SDK:
    This design has instantiated in Project Navigator.
    After exporting to SDK, you must manually copy the
    bitstream and &lt;design&gt;_bd.bmm file from the Project
    Navigator directory to the export directory display below
    SDK\SDK_Export

I've tried this, but I cannot currently figure out how to tell the SDK what files to use to configure the FPGA
</t>
<t tx="ntallen.20101215085413.1394"></t>
<t tx="ntallen.20110115103957.1399"></t>
<t tx="ntallen.20110115103957.1400">This is the main branch for current development. Any directory created with suffixes is a temporary test.
DACS_V1_0A_ISE e.g.</t>
<t tx="ntallen.20110118143100.1403">Encapsulation of ana_ram to avoid simultaneous operations by
delaying the subbus read while RAM_BUSY is asserted.

Also will cache the configuration data read from an even address
to report on a subsequent read of the next higher address.</t>
<t tx="ntallen.20110118143100.1404"></t>
<t tx="ntallen.20110118143100.1405">Encapsulation of ana_ram to avoid simultaneous operations by
delaying the subbus write while RAM_BUSY is asserted.
</t>
<t tx="ntallen.20110118143100.1406">Basic analog input address run from C00 to CFE, so there are 8 significant bits.
Bit 0 is used simply to indicate whether the converted value or the configuration
value is being read. That leaves 7 address bits: Addr(7 downto 1). Of these:
    Addr(7 downto 5) is the Row
    Addr(4) is the Bank
    Addr(3 downto 1) is the Column

2^7 = 128 different channels, corresponding to 2 banks of 8 converters with 8-channel
muxes.

And 8 of these 128 channels may be further muxed off the DACS board.
The configuration word consists of 9 bits:
    Cfg(4 downto 0) is the channel gain configuration
    Cfg(8) is the remux bit
    Cfg(7 downto 5) is the remux addr: maddr
When a remuxed channel is read from the converter, the value is
stored at the normal location, then also at a mux address, which
is assembled as: X"D" &amp; maddr &amp; bank &amp; Row(5 downto 3)

#### Since the RAMaddr is generated by ana_acquire, it needs to have at least the
mux configuration bits that are cached by ana_hwside.</t>
<t tx="ntallen.20110122074609.1411">In order to make the hwside a little simpler, I permute the write address for
configuration data so it comes out one row and two columns before the data
converted data is recorded.</t>
<t tx="ntallen.20110123092829.1413">Produced by the hardware (DACS):
    E1: Unrecognized Command
    E2: Receive Timeout
    E3: Command Syntax Error
    E4: Invalid Interrupt Request
    E8: Serial request too long
    E10: Internal contradiction
    E11: No ACK on INTA
    
Produced by subbusd:
    E100: USB Timeout
    E101: Wrong number of readings returned
    E102: DACS reply syntax error

Produced by libsubbus:
    E200: Null request</t>
<t tx="ntallen.20110203162516.1415">This device will present a read-only interface to the subbus. On the back side
we will have an engine driving an I2C interface to poll the SHT21 (RH/T) and the
MS5607 (P/T)

0  0300	R	Status
1  0302	R	SHT21 Temperature
2  0304	R	SHT21 Relative Humidity
3  0306	R	MS5607 Coefficient 1
4  0308	R	MS5607 Coefficient 2
5  030A	R	MS5607 Coefficient 3
6  030C	R	MS5607 Coefficient 4
7  030E	R	MS5607 Coefficient 5
8  0310	R	MS5607 Coefficient 6
9  0312	R	MS5607 D1(15:0)
10 0314	R	MS5607 D1(23:16)
11 0316	R	MS5607 D2(15:0)
12 0318	R	MS5607 D2(23:16)

Why am I using the 25MHz clock on the back side? I2C is not fast, and timing issues might be much
easier without dealing with cross-clock stuff.</t>
<t tx="ntallen.20110203162516.1416">I2C Address is 1000000

We could issue a soft reset (11111110) on startup for good measure
Soft reset takes less that 15 ms

Present as two 16-bit words:

Trigger T measurement hold master (11100011)
  Read three bytes (MSB, LSB, Checksum)
  Store two
Trigger RH measurement hold master (11100101)
  Read three bytes (MSB, LSB, Checksum)
  Store two
</t>
<t tx="ntallen.20110203162516.1417">Device has 6 16-bit configuration words in ROM. We want to read these
once on startup, then just read the P and T values.

The Reset sequence (0x1E) shall be sent once after power-on to make sure that the
I2C Address is 0xEE

calibration PROM gets loaded into the internal register.

After requesting a conversion, there is no direct indication when the
conversion is complete. The data sheet says you have to wait for the
conversion to complete or you will corrupt the value, so presumably
we will just have to wait long enough by counting clocks.

Initialization:
    Wr Soft Reset (0x1E)
    Wait 2.8ms for reload
    Read configuration words and store
    Wr Prom Read 0 (0xA0)
    Rd Two bytes, store
    Wr Prom Read 1 (0xA2)
    Rd Two bytes, store
    ...
    Wr Prom Read 6 (0xAC)
    Rd Two bytes, store

Sampling:
    Wr Convert D1 (P) (OSR=4096) 0x48
    Wait 9.04 ms
    Wr ADC Read 0x00
    Rd Three bytes, store
    Wr Convert D2 (T) (OSR=4096) 0x58
    Wait 9.04 ms
    Wr ADC Read 0x00
    Rd Three bytes, store</t>
<t tx="ntallen.20110206160145.1421">Initialization:
    SHT21 Reset:
        Wr 1000000 0xFE Stop -- require 15 ms
    MS5607 Initialization:
        Wr Soft Reset (1110111 0x1E)
        Wait 2.8ms for reload
        Read configuration words and store
        Wr Prom Read 1 (0xA2)
        Rd Two bytes, store
        Wr Prom Read 2 (0xA4)
        Rd Two bytes, store
        ...
        Wr Prom Read 6 (0xAC)
        Rd Two bytes, store
        
        Each Write/Rd two byte sequence takes less than 500 us
        This entire read sequence takes 45*6*10us = 2.7ms
        Together with the reset delay we get 2.7 ms + 2.8 ms = 5.5 ms
        So we need to wait another 10 ms for the SHT21 to finish

Acquisition:
    SHT21:
        Trigger T measurement hold master (11100011)
        Read three bytes (MSB, LSB, Checksum) Store two
            Default T resolution is 14 bits
            Maximum conversion time for 14 bits is 85 ms
        Trigger RH measurement hold master (11100101)
        Read three bytes (MSB, LSB, Checksum) Store two
            Default RH resolution is 12 bits
            Maximum conversion time for 12 bits is 29 ms
        
    MS5607:
        Wr Convert D1 (P) (OSR=4096) 0x48
        Wait 9.04 ms
        Wr ADC Read 0x00
        Rd Three bytes, store
        
        Wr Convert D2 (T) (OSR=4096) 0x58
        Wait 9.04 ms
        Wr ADC Read 0x00
        Rd Three bytes, store</t>
<t tx="ntallen.20110207112658.1424">00: SHT21 Reset Acknowledge
01: MS5607 Reset Acknowledge
02: MS5607 Config 1
03: MS5607 Config 2
04: MS5607 Config 3
05: MS5607 Config 4
06: MS5607 Config 5
07: MS5607 Config 6
08: SHT21 T
09: SHT21 RH
10: MS5607 D1
11: MS5607 D2

12: Select Error

</t>
<t tx="ntallen.20110227134141.1425">Some are working great, others not.
Three counters:
    Ctr0: 4th input is reading lots of counts. Probably not terminated
    Ctr1: OK?
    Ctr2: Nothing reads right, not even status</t>
<t tx="ntallen.20110331101033.1427">March 31, 2011
AI circuit is freezing in flight. Instrumentation indicates ana_acquire is getting
stuck in acq_... (bit 4) indicating that there is a problem with the handshaking
between ana_acquire and the ana_s16 and/or ana_s5s state machines. I think this
may be tied into the possible timing variations introduced by the RAM arbitration
scheme which was left somewhat less than robust.

We need to sort out the arbitration with RAM and the handshaking between the different
state machines. The current design makes certain assumptions that apparently are false.
Specifically, ana_acquire assumes that if it gets a Rdy_In signal, it can set start
for one clock and it will 

April 2011

After the careful redesign, the engine no longer freezes up, but it does exhibit a
tendency to get into a mode where seemingly random data values are reported. This
has been shown to be due to the fact that the first word or two of data is not
being properly shifted out of the A/Ds, resulting in data from other columns
being reported with a bit shift.

Currently testing an implementation where I use the existing design but specify that
the FSM be implemented using one-hot encoding instead of the default (which was gray).

This seems to have improved performance on the bench with the HTW DACS. We will see
how it works in flight today on HWV.</t>
<t tx="ntallen.20110418174231.1429">Want to read Current and Voltage
Use "Read Page" to get 4 bytes from each of two chips on the bus.

CE Need to check these two addresses against Marco's pullups.
D0

Write register #(0) to address CE, then read 2 bytes
Write register #(2) to address CE, then read 2 bytes
Write register #(0) to address D0, then read 2 bytes
Write register #(2) to address D0, then read 2 bytes

Use PTRH DPRAM to store values relative to BASE_ADDRESS
0 Status
2 I1  CE:0,1
4 V1  CE:2,3
6 I2  D0:0,1
8 V2  D0:2,3

Status word

0: I1 valid
1: V1 valid
2: I2 valid
3: V2 valid
4: Timeout</t>
<t tx="ntallen.20110418174231.1430">I2C initialization requires programming the clock prescale register.
In the first implementation, I am writing out "002D" for a prescale value of 45.
According to the formula, that should give me an SCL frequency of around 109 KHz,
In simulation, it gives me something close to 99 KHz.
What does it measure?

If I switch to 8MHz, the prescale value should be "000E" (based on simulation ratios)
</t>
<t tx="ntallen.20110419111719.1433">This block serves as cache memory. Data is read from the PTRH devices
and written to the DPRAM, then read on the subbus side.
In the original design, it also served as a clock synchronization
barrier. I am investigating how it might need to be changed if
the clocks do not require synchronization.

Each DPRAM serves as a mini FIFO, and it's really independent of
clock rates. They can be independent or synchronous, and it
should still work and serve a useful function.</t>
<t tx="ntallen.20111024112337.1435">For Carbon, we are looking at muxing multiple PTRH modules using a
TI PCA9548A 8-channel I2C Switch. This has many implications:
    Since each PTRH currently reports 13 words of data, if we
    end up with 15 of them, that's a lot of address space.
    Half that data only needs to be read on startup.
In the interest of optimization, I want to rearrange the PTRH
    data so the acquisition data is contiguous
    
I'm looking at 32 addrs/PTRH and 8 PTRH boards total.
That's a round 100H. Could go up to 16 PTRH boards within
that same footprint if I adopted a paged architecture.
</t>
<t tx="ntallen.20111025151610.1437">Provides routines at a slightly higher level than the wishbone I2C.
It supports writes of addr and data and reads of 2 and 3 bytes from
a specified address.

I propose adding some of the looping constructs such as (De)SelectAll
and PTRH.Select. It would have to know about the PTRH definitions and
ESID definitions.</t>
<t tx="ntallen.20111114100408.1439">I am remapping the registers in order to optimize multi-word reads in the future:
    
0000	R	MS5607 Coefficient 1
0002	R	MS5607 Coefficient 2
0004	R	MS5607 Coefficient 3
0006	R	MS5607 Coefficient 4
0008	R	MS5607 Coefficient 5
000A	R	MS5607 Coefficient 6
000C	R	Status
000E	R	SHT21 Temperature
0010	R	SHT21 Relative Humidity
0012	R	MS5607 P D1(15:0)
0014	R	MS5607 P D1(23:16)
0016	R	MS5607 T D2(15:0)
0018	R	MS5607 T D2(23:16)
</t>
<t tx="ntallen.20111123115724.1441">The topology of the PTRH network is defined via Generics.
There is considerable flexibility in how PTRH boards can be connected.
Two PTRH boards cannot be directly connected to the same I2C bus,
but multiple PTRH boards can be connected through an external switch,
which produces multiple I2C buses on the other side.
Since the switches we are using have a programmable address, it is
possible to have multiple switches on the same I2C bus.
Each I2C bus can either have a single PTRH or one or more switches.
You cannot have both a PTRH and a switch on the same bus because
the PTRH's address would conflict with PTRHs on the switch.

In order to tell the firmware how to query all of these devices

N_ISBITS: The number of I2C buses leaving the FPGA
N_PTRH: The number of PTRH subsystems attached
N_ESWITCH: The number of external switch devices plus the
    number of I2C buses that have PTRHs attached directly.
    This will typically be equal to N_ISBITS, but not
    if there are multiple switches connected to one bus.
ESID: An array of N_PTRH elements in the range N_ESWITCH-1 downto 0
    Identifies which external switch or bus a particular
    PTRH is attached to
ISwitchBit: An array of N_ESWITCH elements in the range N_ISBITS-1 downto 0
    Identifies which I2C bus the PTRH or external switch is connected to
ESwitchAddr: An array of N_ESWITCH 7-bit I2C addresses
    If this ESID identifies an external switch, this address will be
    non-zero. If it is zero, it identifies a directly-connected PTRH.
ESwitchBit: An array of N_PTRH elements in the range 7 downto 0
    Identifies which bit on the external switch this PTRH is
    connected to. The setting is ignored if no external switch
    is involved.
</t>
<t tx="ntallen.20111212160628.1443">The idea is to reproduce the AnaI/O hi-res AD/DA interface to communicate with QCLIs. We have a suspicion that some of the current misbehavior of the QCLI may stem from a problem with the RS-232 interface. If true, using the quasi-spi interface might alleviate the problem.

We need to address multiple QCLIs. It is probably smart to keep the circuits independent, provided we have enough lines. As detailed elsewhere, it is possible to share clock and data lines, but that would require a more serialized architecture.

If we are careful and mimic the anaio interface, we could use the existing qcli utils to communicate with the QCLIs. Alternately, we could provide an enhanced interface that might make programming and/or verification more efficient.</t>
<t tx="ntallen.20111212160628.1444">Read /qclutil/qclisb.c to understand subbus interface.
</t>
<t tx="ntallen.20111212160628.1445">This interface was designed before the QCLI was conceived. It was intended to talk to a specific A/D or a specific D/A. The QCLI interface was designed to be compatible with those two capabilities. The result is an interface definition unlike any other.

There are 4 signals on the QCLI:
    QSCLK: INOUT: bi-directional data clock
    SDATA: INOUT: bi-directional data link
    QSYNC: IN: chip select and direction control
    QBUSY: OUT: status readback

QBUSY was originally a bi-directional LDAC/ and BUSY/ indicator, but the LDAC/ functionality was unnecessary on the QCLI, so we will consider this to be an output from the QCLI.

QSCLK is driven by the QCLI when we are reading from the QCLI and is driven by the DACS when we are writing to the QCLI. On read, the QCLI runs the clock at 62.5 KHz. On write, we probably have some latitude, with 62.5 KHz being a starting point. The important limitation is that we must provide enough time between words for the QSYNC to be properly observed and the command recorded. QSCLK is pulled down on the QCLI, so it will be low unless it is driven high.

SDATA is driven by the DACS when writing to the QCLI and driven by the QCLI when reading.

QSYNC serves as both chip select and direction control. If held high, the QCLI is deselected and the communication circuit remains idle.

For a read request, QSYNC is pulsed low while holding QSCLK low. When the QCLI observes QSYNC going high with no intervening QSCLK pulses, it drives QBUSY low, takes control of QSCLK and SDATA and shifts out 16 bits. SDATA should transition when QSCLK is low, so SDATA can be clocked in on either the rising or falling edge of QSCLK. [[I do not know what the bit order is]]

For a write, QSYNC is driven low, and then SDATA and QSCLK are driven to clock out 16 bits [[presumably in the same bit order used for read]]. After 16 bits are shifted, QSYNC is raised to mark the end of the data transfer. QSYNC must remain high for at least one microsecond before writing another value. There may be other constraints governing the writing speed.
</t>
<t tx="ntallen.20111212160628.1447">Details need to be filled in, but the ANAIO circuit continuously polled the QCLI for status information so a simple subbus read would give the current status. I still need to figure out how output and requests to read other data was handled. The speed of the polling is up for grabs. ANAIO did something like 400 Hz, but I think that is much faster than we require.</t>
</tnodes>
</leo_file>
