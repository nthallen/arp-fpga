-- VHDL Entity idx_fpga_lib.temp_avg.interface
--
-- Created:
--          by - nort.Domain Users (EASWHLPT3425080)
--          at - 11:20:57 05/07/15
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2018.2 (Build 19)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY temp_avg IS
   PORT( 
      F8M       : IN     std_logic;
      RdEn      : IN     std_ulogic;
      Sensor    : IN     std_logic_vector (2 DOWNTO 0);
      Word      : IN     std_logic_vector (1 DOWNTO 0);
      brd_num   : IN     std_logic_vector (2 DOWNTO 0);
      rd_data_o : IN     std_logic_vector (31 DOWNTO 0);
      rdy       : IN     std_logic;
      rst       : IN     std_logic;                       -- sync high
      RData     : OUT    std_logic_vector (15 DOWNTO 0);
      ack       : OUT    std_logic
   );

-- Declarations

END temp_avg ;

--
-- VHDL Architecture idx_fpga_lib.temp_avg.fsm
--
-- Created:
--          by - nort.Domain Users (EASWHLPT3425080)
--          at - 13:25:12 05/09/15
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2018.2 (Build 19)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
 
ARCHITECTURE fsm OF temp_avg IS

   -- Architecture Declarations
   TYPE AccArray_t is array (5 downto 0)
    of unsigned (31 downto 0);
   SIGNAL AccArray : AccArray_t;
   TYPE CntArray_t is array (5 downto 0)
    of unsigned(15 downto 0);
   SIGNAL CntArray : CntArray_t;
   SIGNAL OutCache : std_logic_vector(31 DOWNTO 0);  
   SIGNAL RdProcessed : std_logic;  

   TYPE STATE_TYPE IS (
      s0,
      s1,
      s2,
      s3,
      s4
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare any pre-registered internal signals
   SIGNAL RData_cld : std_logic_vector (15 DOWNTO 0);
   SIGNAL ack_cld : std_logic ;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      F8M
   )
   -----------------------------------------------------------------
   Variable brd_num_i : integer range 5 DOWNTO 0;
   Variable AccBits : unsigned(1 DOWNTO 0);
   BEGIN
      IF (F8M'EVENT AND F8M = '1') THEN
         IF (rst = '1') THEN
            current_state <= s0;
            -- Default Reset Values
            RData_cld <= (others => '0');
            ack_cld <= '0';
            AccArray <= (others => X"00000000");
            CntArray <= (others => X"0000");
            OutCache <= (others => '0');
            RdProcessed <= '0';
         ELSE
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
               WHEN s0 => 
                  IF (RdEn = '1' AND
                      Word = "00" AND
                      RdProcessed = '0') THEN 
                  ELSIF (RdEn = '1' AND
                         Word = "01" AND
                         RdProcessed = '0') THEN 
                  ELSIF (RdEn = '1' AND
                         Word = "10" AND
                         RdProcessed = '0') THEN 
                  ELSIF (rdy = '1' AND
                         ack_cld = '0') THEN 
                  ELSIF (RdProcessed = '1'
                         AND RdEn = '0') THEN 
                     RdProcessed <= '0';
                  ELSIF (ack_cld = '1'
                         AND rdy = '0') THEN 
                     ack_cld <= '0';
                  END IF;
               WHEN s1 => 
                  IF Sensor <= "101" THEN
                    brd_num_i := conv_integer(unsigned(Sensor));
                    RData_cld <= std_logic_vector(CntArray(brd_num_i));
                    CntArray(brd_num_i) <= (others => '0');
                    OutCache <= std_logic_vector(AccArray(brd_num_i));
                    AccArray(brd_num_i) <= (others => '0');
                  END IF;
                  RdProcessed <= '1';
               WHEN s2 => 
                  IF brd_num <= "101" THEN
                    brd_num_i := conv_integer(unsigned(brd_num));
                    CntArray(brd_num_i) <=
                      CntArray(brd_num_i) + 1;
                    AccBits := AccArray(brd_num_i)(31 DOWNTO 30);
                    IF AccBits(1) = '0' OR AccBits(0) = '0' THEN
                      IF rd_data_o(31 downto 30) = "11" THEN
                        AccArray(brd_num_i) <= (others => '1');
                      ELSIF rd_data_o(31 downto 29) = "001" THEN
                        AccArray(brd_num_i) <= X"FFFFFFFE";
                      ELSIF rd_data_o(30) = '1' THEN
                        AccArray(brd_num_i) <=
                          AccArray(brd_num_i) +
                             unsigned(X"FF" & rd_data_o(30 downto 7));
                      ELSE
                        AccArray(brd_num_i) <=
                          AccArray(brd_num_i) +
                             unsigned(X"00" & rd_data_o(30 downto 7));
                      END IF;
                    END IF;
                  END IF;
                  ack_cld <= '1';
               WHEN s3 => 
                  RData_cld <= OutCache(15 DOWNTO 0);
                  RdProcessed <= '1';
               WHEN s4 => 
                  RData_cld <= OutCache(31 DOWNTO 16);
                  RdProcessed <= '1';
               WHEN OTHERS =>
                  NULL;
            END CASE;
         END IF;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      RdEn,
      RdProcessed,
      Word,
      ack_cld,
      current_state,
      rdy
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN s0 => 
            IF (RdEn = '1' AND
                Word = "00" AND
                RdProcessed = '0') THEN 
               next_state <= s1;
            ELSIF (RdEn = '1' AND
                   Word = "01" AND
                   RdProcessed = '0') THEN 
               next_state <= s3;
            ELSIF (RdEn = '1' AND
                   Word = "10" AND
                   RdProcessed = '0') THEN 
               next_state <= s4;
            ELSIF (rdy = '1' AND
                   ack_cld = '0') THEN 
               next_state <= s2;
            ELSIF (RdProcessed = '1'
                   AND RdEn = '0') THEN 
               next_state <= s0;
            ELSIF (ack_cld = '1'
                   AND rdy = '0') THEN 
               next_state <= s0;
            ELSE
               next_state <= s0;
            END IF;
         WHEN s1 => 
            next_state <= s0;
         WHEN s2 => 
            next_state <= s0;
         WHEN s3 => 
            next_state <= s0;
         WHEN s4 => 
            next_state <= s0;
         WHEN OTHERS =>
            next_state <= s0;
      END CASE;
   END PROCESS nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   RData <= RData_cld;
   ack <= ack_cld;
END fsm;
