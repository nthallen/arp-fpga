-- VHDL Entity idx_fpga_lib.pm_acq.symbol
--
-- Created:
--          by - nort.UNKNOWN (NORT-XPS14)
--          at - 06:38:45 07/24/2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY pm_acq IS
  GENERIC( 
    I2C_ADDR1 : std_logic_vector(6 DOWNTO 0) := "1101000";
    I2C_ADDR2 : std_logic_vector(6 DOWNTO 0) := "1101001"
  );
  PORT( 
    Done      : IN     std_logic;
    Err       : IN     std_logic;
    F8M       : IN     std_ulogic;
    i2c_rdata : IN     std_logic_vector (23 DOWNTO 0);
    rst       : IN     std_ulogic;
    Rd        : OUT    std_logic;
    Rd3       : OUT    std_logic;
    Wr        : OUT    std_logic;
    WrEn      : OUT    std_ulogic_vector (4 DOWNTO 0);
    WrStop    : OUT    std_logic;
    i2c_addr  : OUT    std_logic_vector (6 DOWNTO 0);
    i2c_wdata : OUT    std_logic_vector (7 DOWNTO 0);
    wData     : OUT    std_logic_vector (15 DOWNTO 0)
  );

-- Declarations

END ENTITY pm_acq ;

--
-- VHDL Architecture idx_fpga_lib.pm_acq.fsm
--
-- Created:
--          by - nort.UNKNOWN (NORT-XPS14)
--          at - 06:38:45 07/24/2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
--  Machine             :  "csm", synchronous
--  Encoding            :  none
--  Style               :  case, 3 processes
--  Clock               :  "F8M", rising 
--  Synchronous Reset   :  "rst", synchronous, active high
--  State variable type :  [auto]
--  Default state assignment disabled
--  State actions registered on current state
--  
--   SIGNAL      MODE    DEFAULT  RESET      SCHEME 
--   Rd          OUT              '0'        CLKD   
--   Rd3         OUT              '0'        CLKD   
--   Wr          OUT              '0'        CLKD   
--   WrEn        OUT              "00000"    CLKD   
--   WrStop      OUT              '0'        CLKD   
--   i2c_addr    OUT              "0000000"  CLKD   
--   i2c_wdata   OUT              X"00"      CLKD   
--   wData       OUT              X"0000"    CLKD   
--   Status      LOCAL            X"0000"    CLKD   
--   addr_i      LOCAL            0          CLKD   
--   reg_i       LOCAL            0          CLKD   
--   addrRegOff  LOCAL            0          CLKD   
--   
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.STD_LOGIC_UNSIGNED.ALL;
 
ARCHITECTURE fsm OF pm_acq IS

  -- Architecture Declarations
    type pmAddrs_t is array (0 TO 8) of std_logic_vector(6 DOWNTO 0);
    CONSTANT pmAddr : pmAddrs_t := (
      "1100111",
      "1101000",
      "1101001",
      "1101010",
      "1101011",
      "1101100",
      "1101101",
      "1101110",
      "1101111");
  
  type pmRegs_t is array(0 TO 2) of std_logic_vector(7 DOWNTO 0);
  CONSTANT  pmReg : pmRegs_t := ( X"00", X"02", X"06");
  
  type pmRegOffset_t is array(0 TO 2) of integer;
  CONSTANT pmRegOffset : pmRegOffset_t := (0, 1, 5);
  
  type pmAddrOffset_t is array(0 TO 8) of integer;
  CONSTANT pmAddrOffset : pmAddrOffset_t := (5, 0, 2, 5, 5, 5, 5, 5, 5);
  SIGNAL Status : std_logic_vector(15 DOWNTO 0);  
  SIGNAL addrRegOff : integer RANGE 10 DOWNTO 0;  
  SIGNAL addr_i : integer RANGE 8 DOWNTO 0;  
  SIGNAL reg_i : integer RANGE 2 DOWNTO 0;  

  TYPE STATE_TYPE IS (
    vm_reset,
    vm_rst1,
    vm_I1_a,
    vm_I1_b,
    vm_I1_c,
    vm_I1_d,
    vm_I1_e,
    vm_I1_f,
    vm_I1_g,
    vm_to,
    vm_to1,
    vm_to2,
    vm_I1_h,
    vm_I1_j,
    nxt_step,
    nxt_addr,
    vm_I1_k,
    nxt_reg
  );
 
  -- Declare current and next state signals
  SIGNAL current_state : STATE_TYPE;
  SIGNAL next_state : STATE_TYPE;

  -- Declare Wait State internal signals
  SIGNAL csm_timer : std_logic_vector(16 DOWNTO 0);
  SIGNAL csm_next_timer : std_logic_vector(16 DOWNTO 0);
  SIGNAL csm_timeout : std_logic;
  SIGNAL csm_to_vm_I1_b : std_logic;
  SIGNAL csm_to_vm_I1_e : std_logic;

  -- Declare any pre-registered internal signals
  SIGNAL Rd_cld : std_logic ;
  SIGNAL Rd3_cld : std_logic ;
  SIGNAL Wr_cld : std_logic ;
  SIGNAL WrEn_cld : std_ulogic_vector (4 DOWNTO 0);
  SIGNAL WrStop_cld : std_logic ;
  SIGNAL i2c_addr_cld : std_logic_vector (6 DOWNTO 0);
  SIGNAL i2c_wdata_cld : std_logic_vector (7 DOWNTO 0);
  SIGNAL wData_cld : std_logic_vector (15 DOWNTO 0);

BEGIN

  -----------------------------------------------------------------
  clocked_proc : PROCESS ( 
    F8M
  )
  -----------------------------------------------------------------
  BEGIN
    IF (F8M'EVENT AND F8M = '1') THEN
      IF (rst = '1') THEN
        current_state <= vm_reset;
        csm_timer <= (OTHERS => '0');
        -- Default Reset Values
        Rd_cld <= '0';
        Rd3_cld <= '0';
        Wr_cld <= '0';
        WrEn_cld <= "00000";
        WrStop_cld <= '0';
        i2c_addr_cld <= "0000000";
        i2c_wdata_cld <= X"00";
        wData_cld <= X"0000";
        Status <= X"0000";
        addrRegOff <= 0;
        addr_i <= 0;
        reg_i <= 0;
      ELSE
        current_state <= next_state;
        csm_timer <= csm_next_timer;

        -- Combined Actions
        CASE current_state IS
          WHEN vm_reset => 
            Status <= (others => '0');
            wData_cld <= (others => '0');
            WrEn_cld <= "11111";
            Rd_cld <= '0';
            Rd3_cld <= '0';
            Wr_cld <= '0';
            WrStop_cld <= '0';
            addr_i <= 0;
            reg_i <= 0;
          WHEN vm_rst1 => 
            WrEn_cld <= "00000";
          WHEN vm_I1_a => 
            i2c_addr_cld <= pmAddr(addr_i);
            i2c_wdata_cld <= pmReg(reg_i);
            Wr_cld <= '1';
            WrStop_cld <= '0';
            addrRegOff <= pmAddrOffset(addr_i)
               + pmRegOffset(reg_i);
          WHEN vm_I1_b => 
            Wr_cld <= '0';
          WHEN vm_I1_c => 
            Rd_cld <= '1';
          WHEN vm_I1_e => 
            Rd_cld <= '0';
          WHEN vm_I1_f => 
            wData_cld <=
              i2c_rdata(15 DOWNTO 0);
            WrEn_cld(addrRegOff+1) <= '1';
            Status(addrRegOff) <= '1';
          WHEN vm_I1_g => 
            wData_cld <= Status;
            WrEn_cld(0) <= '1';
            WrEn_cld(1) <= '0';
          WHEN vm_to => 
            Status <= X"0010";
          WHEN vm_to1 => 
            wData_cld <= Status;
            WrEn_cld(0) <= '1';
          WHEN vm_to2 => 
            WrEn_cld(0) <= '0';
          WHEN vm_I1_h => 
            WrEn_cld(0) <= '0';
          WHEN nxt_addr => 
            if addr_i < 8 then
              addr_i <= addr_i + 1;
            else
              addr_i <= 0;
            end if;
            reg_i <= 0;
          WHEN vm_I1_k => 
            Status(addrRegOff) <= '0';
          WHEN nxt_reg => 
            reg_i <= reg_i + 1;
          WHEN OTHERS =>
            NULL;
        END CASE;
      END IF;
    END IF;
  END PROCESS clocked_proc;
 
  -----------------------------------------------------------------
  nextstate_proc : PROCESS ( 
    Done,
    Err,
    addrRegOff,
    csm_timeout,
    current_state,
    reg_i
  )
  -----------------------------------------------------------------
  BEGIN
    -- Default assignments to Wait State entry flags
    csm_to_vm_I1_b <= '0';
    csm_to_vm_I1_e <= '0';
    CASE current_state IS
      WHEN vm_reset => 
        next_state <= vm_rst1;
      WHEN vm_rst1 => 
        IF (Done = '1'
              OR
            Err = '1') THEN 
          next_state <= vm_I1_a;
        ELSE
          next_state <= vm_rst1;
        END IF;
      WHEN vm_I1_a => 
        IF (Done = '0'
              AND
            Err = '0') THEN 
          next_state <= vm_I1_b;
          csm_to_vm_I1_b <= '1';
        ELSE
          next_state <= vm_I1_a;
        END IF;
      WHEN vm_I1_b => 
        IF (Done = '1') THEN 
          next_state <= vm_I1_c;
        ELSIF (Err = '1') THEN 
          next_state <= vm_I1_d;
        ELSIF (csm_timeout = '1') THEN 
          next_state <= vm_to;
        ELSE
          next_state <= vm_I1_b;
        END IF;
      WHEN vm_I1_c => 
        IF (Done = '0') THEN 
          next_state <= vm_I1_e;
          csm_to_vm_I1_e <= '1';
        ELSE
          next_state <= vm_I1_c;
        END IF;
      WHEN vm_I1_d => 
        IF (addrRegOff < 5) THEN 
          next_state <= vm_I1_k;
        ELSE
          next_state <= nxt_step;
        END IF;
      WHEN vm_I1_e => 
        IF (Done = '1') THEN 
          next_state <= vm_I1_j;
        ELSIF (Err = '1') THEN 
          next_state <= vm_I1_d;
        ELSIF (csm_timeout = '1') THEN 
          next_state <= vm_to;
        ELSE
          next_state <= vm_I1_e;
        END IF;
      WHEN vm_I1_f => 
        next_state <= vm_I1_g;
      WHEN vm_I1_g => 
        next_state <= vm_I1_h;
      WHEN vm_to => 
        next_state <= vm_to1;
      WHEN vm_to1 => 
        next_state <= vm_to2;
      WHEN vm_to2 => 
        IF (Done = '1'
              OR
            Err = '1') THEN 
          next_state <= vm_I1_a;
        ELSE
          next_state <= vm_to2;
        END IF;
      WHEN vm_I1_h => 
        next_state <= nxt_step;
      WHEN vm_I1_j => 
        IF (addrRegOff < 5) THEN 
          next_state <= vm_I1_f;
        ELSE
          next_state <= nxt_step;
        END IF;
      WHEN nxt_step => 
        IF (reg_i >= 2) THEN 
          next_state <= nxt_addr;
        ELSE
          next_state <= nxt_reg;
        END IF;
      WHEN nxt_addr => 
        next_state <= vm_I1_a;
      WHEN vm_I1_k => 
        next_state <= vm_I1_g;
      WHEN nxt_reg => 
        next_state <= vm_I1_a;
      WHEN OTHERS =>
        next_state <= vm_reset;
    END CASE;
  END PROCESS nextstate_proc;
 
  -----------------------------------------------------------------
  csm_wait_combo_proc: PROCESS (
    csm_timer,
    csm_to_vm_I1_b,
    csm_to_vm_I1_e
  )
  -----------------------------------------------------------------
  VARIABLE csm_temp_timeout : std_logic;
  BEGIN
    IF (unsigned(csm_timer) = 0) THEN
      csm_temp_timeout := '1';
    ELSE
      csm_temp_timeout := '0';
    END IF;

    IF (csm_to_vm_I1_b = '1') THEN
      csm_next_timer <= "10011100001111111"; -- no cycles(80000)-1=79999
    ELSIF (csm_to_vm_I1_e = '1') THEN
      csm_next_timer <= "10011100001111111"; -- no cycles(80000)-1=79999
    ELSE
      IF (csm_temp_timeout = '1') THEN
        csm_next_timer <= (OTHERS=>'0');
      ELSE
        csm_next_timer <= std_logic_vector(unsigned(csm_timer) - 1);
      END IF;
    END IF;
    csm_timeout <= csm_temp_timeout;
  END PROCESS csm_wait_combo_proc;

  -- Concurrent Statements
  -- Clocked output assignments
  Rd <= Rd_cld;
  Rd3 <= Rd3_cld;
  Wr <= Wr_cld;
  WrEn <= WrEn_cld;
  WrStop <= WrStop_cld;
  i2c_addr <= i2c_addr_cld;
  i2c_wdata <= i2c_wdata_cld;
  wData <= wData_cld;
END ARCHITECTURE fsm;
