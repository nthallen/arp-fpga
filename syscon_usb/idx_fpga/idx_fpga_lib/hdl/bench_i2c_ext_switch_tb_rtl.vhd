--
-- VHDL Test Bench idx_fpga_lib.bench_i2c_ext_switch.i2c_ext_switch_tester
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 15:54:07 11/28/2011
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2010.3 (Build 21)
--
LIBRARY idx_fpga_lib;
USE idx_fpga_lib.ptrhm.all;
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_arith.all;


ENTITY bench_i2c_ext_switch IS
   GENERIC (
      N_SWBITS : NATURAL range 8 downto 2     := 8;
      I2C_ADDR : std_logic_vector(6 downto 0) := "1110000"
   );
END bench_i2c_ext_switch;


LIBRARY idx_fpga_lib;
USE idx_fpga_lib.ALL;


ARCHITECTURE rtl OF bench_i2c_ext_switch IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL clk   : std_ulogic;
   SIGNAL m_scl : std_logic_vector(N_SWBITS DOWNTO 0);
   SIGNAL m_sda : std_logic_vector(N_SWBITS DOWNTO 0);
   SIGNAL rst   : std_ulogic;
   SIGNAL scl   : std_logic;
   SIGNAL sda   : std_logic;
   SIGNAL ClkDone : std_logic;


   -- Component declarations
   COMPONENT i2c_ext_switch
      GENERIC (
         N_SWBITS : NATURAL range 8 downto 2     := 8;
         I2C_ADDR : std_logic_vector(6 downto 0) := "1110000"
      );
      PORT (
         clk   : IN     std_ulogic;
         m_scl : INOUT  std_logic_vector(N_SWBITS DOWNTO 0);
         m_sda : INOUT  std_logic_vector(N_SWBITS DOWNTO 0);
         rst   : IN     std_ulogic;
         scl   : INOUT  std_logic;
         sda   : INOUT  std_logic
      );
   END COMPONENT;

   -- embedded configurations
   -- pragma synthesis_off
   FOR DUT_i2c_ext_switch : i2c_ext_switch USE ENTITY idx_fpga_lib.i2c_ext_switch;
   -- pragma synthesis_on

BEGIN

  DUT_i2c_ext_switch : i2c_ext_switch
    GENERIC MAP (
       N_SWBITS => N_SWBITS,
       I2C_ADDR => I2C_ADDR
    )
    PORT MAP (
       clk   => clk,
       m_scl => m_scl,
       m_sda => m_sda,
       rst   => rst,
       scl   => scl,
       sda   => sda
    );


  clock : Process
  Begin
    clk <= '0';
    -- pragma synthesis_off
    wait for 40 ns;
    while ClkDone = '0' loop
      clk <= '0';
      wait for 62 ns;
      clk <= '1';
      wait for 63 ns;
    end loop;
    wait;
    -- pragma synthesis_on
  End Process;
  
  testproc : process
      procedure wait_a_bit is
      begin
        -- pragma synthesis_off
        for i in 9 downto 0 loop
          wait until clk'Event AND clk = '1';
        end loop;
      end procedure;
  Begin
    ClkDone <= '0';
    rst <= '1';
    scl <= 'H';
    sda <= 'H';
    m_scl <= (others => 'H');
    m_sda <= (others => 'H');
    -- pragma synthesis_off
    wait until clk'event and clk = '1';
    wait until clk'event and clk = '1';
    rst <= '0';
    wait_a_bit;
    sda <= '0';    
    wait_a_bit;
    scl <= '0';
    wait_a_bit;
    scl <= 'H';
    wait_a_bit;
    sda <= 'H';
    wait_a_bit;
    m_sda(0) <= '0';
    wait_a_bit;
    m_sda(0) <= 'H';
    wait_a_bit;
    
    ClkDone <= '1';
    wait;
    -- pragma synthesis_on
  End Process;

END rtl;