-- VHDL Entity idx_fpga_lib.ana_acquire.symbol
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 18:43:18 04/ 1/2011
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY ana_acquire IS
   PORT( 
      AICtrl    : IN     std_logic_vector (9 DOWNTO 0);
      CLK       : IN     std_ulogic;
      CurMuxCfg : IN     std_logic_vector (3 DOWNTO 0);
      NewMuxCfg : IN     std_logic_vector (3 DOWNTO 0);
      RAM_BUSY  : IN     std_ulogic;
      RST       : IN     std_ulogic;
      RdyIn     : IN     std_ulogic_vector (3 DOWNTO 0);
      SDI       : IN     std_ulogic_vector (1 DOWNTO 0);
      CS5       : OUT    std_ulogic;
      Col_Addr  : OUT    std_logic_vector (3 DOWNTO 0);
      Conv      : OUT    std_ulogic;
      NxtRow    : OUT    std_ulogic_vector (5 DOWNTO 0);
      RD_Addr   : OUT    std_logic_vector (7 DOWNTO 0);
      RdEn      : OUT    std_ulogic;
      RdyOut    : OUT    std_ulogic;
      Restart   : OUT    std_ulogic;
      S5WE      : OUT    std_ulogic_vector (1 DOWNTO 0);
      Start     : OUT    std_ulogic;
      Status    : OUT    std_ulogic_vector (11 DOWNTO 0);
      WR_Addr   : OUT    std_logic_vector (7 DOWNTO 0);
      WrEn      : OUT    std_ulogic
   );

-- Declarations

END ana_acquire ;

--
-- VHDL Architecture idx_fpga_lib.ana_acquire.fsm
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 18:43:18 04/ 1/2011
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
 
ARCHITECTURE fsm OF ana_acquire IS

   -- Architecture Declarations
   function mkaddr(
     row : in std_logic_vector(5 DOWNTO 0);
     bank : in std_logic_vector(0 DOWNTO 0);
     col : in std_logic_vector(2 DOWNTO 0) 
   ) return std_logic_vector is
   begin
     return '0' & row(2 DOWNTO 0) &
       bank & col;
   end mkaddr;
   
   function muxaddr(
     cfg : in std_logic_vector(3 DOWNTO 0);
     bank : in std_logic_vector(0 DOWNTO 0);
     row : in std_logic_vector(5 DOWNTO 0)
   ) return std_logic_vector is
   begin
     return std_logic_vector( cfg & bank &
         row(5 DOWNTO 3));
   end muxaddr;
   
   function rmuxaddr(
     cfg : in std_logic_vector(3 DOWNTO 0);
     bank : in std_logic_vector(0 DOWNTO 0);
     col : in std_logic_vector(2 DOWNTO 0);
     rown : in std_logic_vector(5 DOWNTO 0);
     rownn : in std_logic_vector(5 DOWNTO 0)
   ) return std_logic_vector is
     Variable mrow : std_logic_vector(5 DOWNTO 0);
   begin
     if unsigned(col) < 2 then
       mrow := rown;
     else
       mrow := rownn;
     end if;
     return std_logic_vector( cfg & bank &
         mrow(5 DOWNTO 3));
   end rmuxaddr;
   
   function permute(
     row : in std_logic_vector(5 DOWNTO 0);
     rowN : in std_logic_vector(5 DOWNTO 0);
     bank : in std_logic_vector(0 DOWNTO 0);
     col : in std_logic_vector(2 DOWNTO 0) 
   ) return std_logic_vector is
       Variable permute : unsigned(3 DOWNTO 0);
       Variable mapped : unsigned(3 DOWNTO 0);
       Variable mrow : std_logic_vector(5 DOWNTO 0);
   begin
     permute(2 DOWNTO 0) := unsigned(col);
     permute(3) := '0';
     mapped := permute + 6;
     if mapped(3) = '0' then
       mrow := rowN;
     else
       mrow := row;
     end if;
     return '0' & mrow(2 DOWNTO 0) & bank &
       std_logic_vector(mapped(2 DOWNTO 0));
   end permute;
   SIGNAL AIEn : std_logic;  
   SIGNAL Col : std_logic_vector(2 DOWNTO 0);  
   SIGNAL FixRow : std_logic;  
   SIGNAL Fixed : std_logic_vector(5 DOWNTO 0);  
   SIGNAL IncRow : std_logic;  
   SIGNAL NStat : std_ulogic_vector(3 DOWNTO 0);  
   SIGNAL RowN : std_logic_vector(5 DOWNTO 0);  
   SIGNAL RowNN : std_logic_vector(5 DOWNTO 0);  
   SIGNAL RowU : std_logic_vector(5 DOWNTO 0);  
   SIGNAL TOStat : std_ulogic_vector(1 DOWNTO 0);  
   SIGNAL XtraSettle : std_logic;  

   TYPE STATE_TYPE IS (
      acq_init_row,
      acq_idle,
      acq_start,
      acq_1,
      acq_2,
      acq_loop,
      acq_row_end,
      acq_conv,
      acq_b0d,
      acq_b0a,
      acq_b0f,
      acq_b1a,
      acq_b1d,
      acq_b1e,
      acq_b1f,
      acq_b0b,
      acq_b1c,
      acq_settle,
      acq_col_end,
      acq_settle1,
      acq_row,
      acq_b0c,
      acq_b0e,
      acq_b1b,
      acq_rst,
      acq_3
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare Wait State internal signals
   SIGNAL csm_timer : std_logic_vector(14 DOWNTO 0);
   SIGNAL csm_next_timer : std_logic_vector(14 DOWNTO 0);
   SIGNAL csm_timeout : std_logic;
   SIGNAL csm_to_acq_idle : std_logic;
   SIGNAL csm_to_acq_conv : std_logic;
   SIGNAL csm_to_acq_settle : std_logic;
   SIGNAL csm_to_acq_settle1 : std_logic;

   -- Declare any pre-registered internal signals
   SIGNAL CS5_cld : std_ulogic ;
   SIGNAL Col_Addr_cld : std_logic_vector (3 DOWNTO 0);
   SIGNAL Conv_cld : std_ulogic ;
   SIGNAL NxtRow_cld : std_ulogic_vector (5 DOWNTO 0);
   SIGNAL RD_Addr_cld : std_logic_vector (7 DOWNTO 0);
   SIGNAL RdEn_cld : std_ulogic ;
   SIGNAL RdyOut_cld : std_ulogic ;
   SIGNAL Restart_cld : std_ulogic ;
   SIGNAL S5WE_cld : std_ulogic_vector (1 DOWNTO 0);
   SIGNAL Start_cld : std_ulogic ;
   SIGNAL Status_cld : std_ulogic_vector (11 DOWNTO 0);
   SIGNAL WR_Addr_cld : std_logic_vector (7 DOWNTO 0);
   SIGNAL WrEn_cld : std_ulogic ;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      CLK
   )
   -----------------------------------------------------------------
   BEGIN
      IF (CLK'EVENT AND CLK = '1') THEN
         IF (RST = '1') THEN
            current_state <= acq_rst;
            csm_timer <= (OTHERS => '0');
            -- Default Reset Values
            CS5_cld <= '1';
            Col_Addr_cld <= (others => '0');
            Conv_cld <= '1';
            NxtRow_cld <= (others => '0');
            RD_Addr_cld <= (others => '0');
            RdEn_cld <= '0';
            RdyOut_cld <= '0';
            Restart_cld <= '0';
            S5WE_cld <= "00";
            Start_cld <= '0';
            Status_cld <= (others => '0');
            WR_Addr_cld <= (others => '0');
            WrEn_cld <= '0';
            Col <= (others => '1');
            RowN <= "000000";
            RowNN <= "000001";
            RowU <= (others => '0');
            TOStat <= (others => '0');
         ELSE
            current_state <= next_state;
            csm_timer <= csm_next_timer;
            -- Default Assignment To Internals
            Conv_cld <= '1';

            -- Combined Actions
            CASE current_state IS
               WHEN acq_init_row => 
                  Col <= "111";
                  Conv_cld <= '1';
                  Start_cld <= '0';
                  Restart_cld <= '0';
                  WrEn_cld <= '0';
                  RdEn_cld <= '0';
                  S5WE_cld <= "00";
               WHEN acq_idle => 
                  Conv_cld <= '0';
                  IF (csm_timeout = '1' AND (SDI = "00"
                       AND AIEn = '1')) THEN 
                  ELSIF (csm_timeout = '1') THEN 
                     TOStat(0) <= '1';
                  END IF;
               WHEN acq_start => 
                  Start_cld <= '1' ;
                  CS5_cld <= '0';
                  RdyOut_cld <= '0';
                  RowU <= RowN;
                  RowN <= RowNN;
               WHEN acq_1 => 
                  Restart_cld <= '1';
               WHEN acq_2 => 
                  Restart_cld <= '0';
               WHEN acq_loop => 
                  Col_Addr_cld <=
                     '0' & Col;
               WHEN acq_row_end => 
                  RdyOut_cld <= '1';
               WHEN acq_conv => 
                  Conv_cld <= '1' ;
                  IF (RdyIn = "1111"
                       AND SDI = "11") THEN 
                  ELSIF (csm_timeout = '1') THEN 
                     TOStat(1) <= '1';
                  END IF;
               WHEN acq_b0d => 
                  WrEn_cld <= '0';
                  RdEn_cld <= '0';
                  Col_Addr_cld <=
                     '1' & Col;
               WHEN acq_b0a => 
                  RD_Addr_cld <=
                    permute(RowN, RowNN, "0", Col);
                  WR_Addr_cld <=
                   mkaddr(RowU,"0",Col);
                  WrEn_cld <= '1';
                  RdEn_cld <= '1';
               WHEN acq_b0f => 
                  S5WE_cld(0) <= '1';
                  RdEn_cld <= '0';
               WHEN acq_b1a => 
                  S5WE_cld(0) <= '0';
                  RD_Addr_cld <=
                    permute(RowN,RowNN,"1",Col);
                  WR_Addr_cld <=
                    mkaddr(RowU,"1",Col);
                  WrEn_cld <= '1';
                  RdEn_cld <= '1';
               WHEN acq_b1d => 
                  WrEn_cld <= '0';
                  RdEn_cld <= '0';
               WHEN acq_b1e => 
                  RD_Addr_cld <=
                    rmuxaddr(NewMuxCfg,"1",Col,RowN,RowNN);
                  RdEn_cld <= '1';
               WHEN acq_b1f => 
                  S5WE_cld(1) <= '1';
                  RdEn_cld <= '0';
               WHEN acq_b0b => 
                  WrEn_cld <= '0';
                  RdEn_cld <= '0';
               WHEN acq_b1c => 
                  WrEn_cld <= '1';
                  RdEn_cld <= '0';
                  WR_Addr_cld <=
                    muxaddr(CurMuxCfg,"1",RowU);
               WHEN acq_col_end => 
                  S5WE_cld(1) <= '0';
               WHEN acq_row => 
                  Start_cld <= '0';
                  NxtRow_cld <=
                   std_ulogic_vector(RowN);
                  if FixRow = '1' then
                    RowNN <= Fixed;
                  elsif IncRow = '1' then
                    RowNN <=
                      unsigned(RowN) +
                       unsigned(Fixed);
                  else
                    RowNN <= RowN+1;
                  end if;
               WHEN acq_b0c => 
                  WR_Addr_cld <=
                    muxaddr(CurMuxCfg,"0",RowU);
                  WrEn_cld <= '1';
                  RdEn_cld <= '0';
               WHEN acq_b0e => 
                  RD_Addr_cld <=
                    rmuxaddr(NewMuxCfg,"0",Col,RowN,RowNN);
                  RdEn_cld <= '1';
               WHEN acq_b1b => 
                  WrEn_cld <= '0';
                  RdEn_cld <= '0';
               WHEN acq_rst => 
                  Col <= "111";
                  Conv_cld <= '1';
                  Start_cld <= '0';
                  Restart_cld <= '0';
                  WrEn_cld <= '0';
                  RdEn_cld <= '0';
                  S5WE_cld <= "00";
                  RowN <= "000000";
                  NxtRow_cld <= "000000";
                  CS5_cld <= '1';
               WHEN acq_3 => 
                  CS5_cld <= '1';
               WHEN OTHERS =>
                  NULL;
            END CASE;
         END IF;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      AIEn,
      Col,
      CurMuxCfg,
      NewMuxCfg,
      RAM_BUSY,
      RdyIn,
      SDI,
      XtraSettle,
      csm_timeout,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default assignments to Wait State entry flags
      csm_to_acq_idle <= '0';
      csm_to_acq_conv <= '0';
      csm_to_acq_settle <= '0';
      csm_to_acq_settle1 <= '0';
      CASE current_state IS
         WHEN acq_init_row => 
            IF (RdyIn = "1111") THEN 
               next_state <= acq_idle;
               csm_to_acq_idle <= '1';
            ELSE
               next_state <= acq_init_row;
            END IF;
         WHEN acq_idle => 
            IF (csm_timeout = '1' AND (SDI = "00"
                 AND AIEn = '1')) THEN 
               next_state <= acq_conv;
               csm_to_acq_conv <= '1';
            ELSIF (csm_timeout = '1') THEN 
               next_state <= acq_idle;
            ELSE
               next_state <= acq_idle;
            END IF;
         WHEN acq_start => 
            IF (RdyIn = "0000") THEN 
               next_state <= acq_row;
            ELSE
               next_state <= acq_start;
            END IF;
         WHEN acq_1 => 
            IF (RdyIn = "0000") THEN 
               next_state <= acq_2;
            ELSE
               next_state <= acq_1;
            END IF;
         WHEN acq_2 => 
            IF (RAM_BUSY ='0') THEN 
               next_state <= acq_b0a;
            ELSE
               next_state <= acq_2;
            END IF;
         WHEN acq_loop => 
            IF (Col = 0 AND
                RdyIn = "1111") THEN 
               next_state <= acq_3;
            ELSIF (RdyIn = "1111") THEN 
               next_state <= acq_1;
            END IF;
         WHEN acq_row_end => 
            next_state <= acq_init_row;
         WHEN acq_conv => 
            IF (RdyIn = "1111"
                 AND SDI = "11") THEN 
               next_state <= acq_start;
            ELSIF (csm_timeout = '1') THEN 
               next_state <= acq_idle;
               csm_to_acq_idle <= '1';
            ELSE
               next_state <= acq_conv;
            END IF;
         WHEN acq_b0d => 
            IF (NewMuxCfg(3) = '1' AND
                 RAM_BUSY = '0') THEN 
               next_state <= acq_b0e;
            ELSIF (NewMuxCfg(3) = '1'
                   AND RAM_BUSY /= '0') THEN 
               next_state <= acq_b0d;
            ELSE
               next_state <= acq_b0f;
            END IF;
         WHEN acq_b0a => 
            IF (CurMuxCfg(3) = '0') THEN 
               next_state <= acq_b0d;
            ELSIF (RAM_BUSY = '1') THEN 
               next_state <= acq_b0b;
            ELSE
               next_state <= acq_b0c;
            END IF;
         WHEN acq_b0f => 
            next_state <= acq_b1a;
         WHEN acq_b1a => 
            IF (CurMuxCfg(3) = '0') THEN 
               next_state <= acq_b1d;
            ELSIF (RAM_BUSY = '1') THEN 
               next_state <= acq_b1b;
            ELSE
               next_state <= acq_b1c;
            END IF;
         WHEN acq_b1d => 
            IF (NewMuxCfg(3) = '1' AND
                 RAM_BUSY = '0') THEN 
               next_state <= acq_b1e;
            ELSIF (NewMuxCfg(3) = '1'
                   AND RAM_BUSY /= '0') THEN 
               next_state <= acq_b1d;
            ELSE
               next_state <= acq_b1f;
            END IF;
         WHEN acq_b1e => 
            next_state <= acq_b1f;
         WHEN acq_b1f => 
            next_state <= acq_col_end;
         WHEN acq_b0b => 
            IF (RAM_BUSY = '0') THEN 
               next_state <= acq_b0c;
            ELSE
               next_state <= acq_b0b;
            END IF;
         WHEN acq_b1c => 
            next_state <= acq_b1d;
         WHEN acq_settle => 
            IF (csm_timeout = '1') THEN 
               next_state <= acq_row_end;
            ELSE
               next_state <= acq_settle;
            END IF;
         WHEN acq_col_end => 
            IF (Col /= 7) THEN 
               next_state <= acq_loop;
            ELSIF (XtraSettle = '1') THEN 
               next_state <= acq_settle1;
               csm_to_acq_settle1 <= '1';
            ELSE
               next_state <= acq_settle;
               csm_to_acq_settle <= '1';
            END IF;
         WHEN acq_settle1 => 
            IF (csm_timeout = '1') THEN 
               next_state <= acq_settle;
               csm_to_acq_settle <= '1';
            ELSE
               next_state <= acq_settle1;
            END IF;
         WHEN acq_row => 
            next_state <= acq_loop;
         WHEN acq_b0c => 
            next_state <= acq_b0d;
         WHEN acq_b0e => 
            next_state <= acq_b0f;
         WHEN acq_b1b => 
            IF (RAM_BUSY = '0') THEN 
               next_state <= acq_b1c;
            ELSE
               next_state <= acq_b1b;
            END IF;
         WHEN acq_rst => 
            next_state <= acq_init_row;
         WHEN acq_3 => 
            IF (RAM_BUSY = '1') THEN 
               next_state <= acq_2;
            ELSE
               next_state <= acq_b0a;
            END IF;
         WHEN OTHERS =>
            next_state <= acq_rst;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      AICtrl,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment To Internals
      AIEn <= not AICtrl(7);
      FixRow <= AICtrl(6);
      Fixed <= AICtrl(5 DOWNTO 0);
      IncRow <= AICtrl(8);
      NStat <= (others => '0');
      XtraSettle <= AICtrl(9);

      -- Combined Actions
      CASE current_state IS
         WHEN acq_init_row => 
            NStat <= X"1";
         WHEN acq_idle => 
            NStat <= X"2";
         WHEN acq_start => 
            NStat <= X"4";
         WHEN acq_1 => 
            NStat <= X"6";
         WHEN acq_2 => 
            NStat <= X"7";
         WHEN acq_loop => 
            NStat <= X"5";
         WHEN acq_conv => 
            NStat <= X"3";
         WHEN acq_b0d => 
            NStat <= X"9";
         WHEN acq_b1d => 
            NStat <= X"C";
         WHEN acq_b0b => 
            NStat <= X"8";
         WHEN acq_b1b => 
            NStat <= X"B";
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
   -----------------------------------------------------------------
   csm_wait_combo_proc: PROCESS (
      csm_timer,
      csm_to_acq_idle,
      csm_to_acq_conv,
      csm_to_acq_settle,
      csm_to_acq_settle1
   )
   -----------------------------------------------------------------
   VARIABLE csm_temp_timeout : std_logic;
   BEGIN
      IF (unsigned(csm_timer) = 0) THEN
         csm_temp_timeout := '1';
      ELSE
         csm_temp_timeout := '0';
      END IF;

      IF (csm_to_acq_idle = '1') THEN
         csm_next_timer <= "000000000001001"; -- no cycles(10)-1=9
      ELSIF (csm_to_acq_conv = '1') THEN
         csm_next_timer <= "000000001100011"; -- no cycles(100)-1=99
      ELSIF (csm_to_acq_settle = '1') THEN
         csm_next_timer <= "000111010100101"; -- no cycles(3750)-1=3749
      ELSIF (csm_to_acq_settle1 = '1') THEN
         csm_next_timer <= "101001100000001"; -- no cycles(21250)-1=21249
      ELSE
         IF (csm_temp_timeout = '1') THEN
            csm_next_timer <= (OTHERS=>'0');
         ELSE
            csm_next_timer <= unsigned(csm_timer) - '1';
         END IF;
      END IF;
      csm_timeout <= csm_temp_timeout;
   END PROCESS csm_wait_combo_proc;

   -- Concurrent Statements
   -- Clocked output assignments
   CS5 <= CS5_cld;
   Col_Addr <= Col_Addr_cld;
   Conv <= Conv_cld;
   NxtRow <= NxtRow_cld;
   RD_Addr <= RD_Addr_cld;
   RdEn <= RdEn_cld;
   RdyOut <= RdyOut_cld;
   Restart <= Restart_cld;
   S5WE <= S5WE_cld;
   Start <= Start_cld;
   Status <= Status_cld;
   WR_Addr <= WR_Addr_cld;
   WrEn <= WrEn_cld;
   Status_cld(1 downto 0) <= TOStat;
   Status_cld(3 downto 2) <= "00";
   Status_cld(7 downto 4) <= NStat;
   Status_cld(11 downto 8) <= "0000";
END fsm;
