-- VHDL Entity idx_fpga_lib.ana_acquire.symbol
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 16:10:18 10/19/2010
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY ana_acquire IS
   PORT( 
      CLK    : IN     std_logic;
      Conv   : IN     std_ulogic;
      RST    : IN     std_logic;
      RdyIn  : IN     std_ulogic;
      Addr   : OUT    std_ulogic_vector (7 DOWNTO 0);
      NxtRow : OUT    std_ulogic_vector (2 DOWNTO 0);
      RdWrEn : OUT    std_ulogic;
      RdyOut : OUT    std_ulogic;
      S5WE   : OUT    std_ulogic_vector (1 DOWNTO 0);
      Start  : OUT    std_ulogic
   );

-- Declarations

END ana_acquire ;

--
-- VHDL Architecture idx_fpga_lib.ana_acquire.fsm
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 16:10:19 10/19/2010
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
 
ARCHITECTURE fsm OF ana_acquire IS

   -- Architecture Declarations
   SIGNAL Col : unsigned(2 DOWNTO 0);  
   SIGNAL RowN : unsigned(2 DOWNTO 0);  
   SIGNAL RowU : unsigned(2 DOWNTO 0);  

   TYPE STATE_TYPE IS (
      acq_init,
      acq_idle,
      acq_start,
      acq_1,
      acq_2,
      acq_3,
      acq_4,
      acq_5,
      acq_6,
      acq_7,
      acq_1a,
      acq_end
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare any pre-registered internal signals
   SIGNAL Addr_cld : std_ulogic_vector (7 DOWNTO 0);
   SIGNAL NxtRow_cld : std_ulogic_vector (2 DOWNTO 0);
   SIGNAL RdWrEn_cld : std_ulogic ;
   SIGNAL RdyOut_cld : std_ulogic ;
   SIGNAL S5WE_cld : std_ulogic_vector (1 DOWNTO 0);
   SIGNAL Start_cld : std_ulogic ;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      CLK
   )
   -----------------------------------------------------------------
   BEGIN
      IF (CLK'EVENT AND CLK = '1') THEN
         IF (RST = '1') THEN
            current_state <= acq_init;
            -- Default Reset Values
            Addr_cld <= (others => '0');
            NxtRow_cld <= (others => '0');
            RdWrEn_cld <= '0';
            RdyOut_cld <= '1';
            S5WE_cld <= (others => '0');
            Start_cld <= '0';
            Col <= (others => '0');
            RowN <= "001";
            RowU <= (others => '0');
         ELSE
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
               WHEN acq_idle => 
                  IF (Conv = '0') THEN 
                     Start_cld <= '1' ;
                     RdyOut_cld <= '0';
                     RowN <= RowU+1;
                  END IF;
               WHEN acq_start => 
                  IF (RdyIn = '0') THEN 
                     Start_cld <= '0';
                     NxtRow_cld <=
                      std_ulogic_vector(RowN);
                  END IF;
               WHEN acq_1 => 
                  IF (RdyIn = '1') THEN 
                     Start_cld <= '1';
                  END IF;
               WHEN acq_2 => 
                  Start_cld <= '0';
                  Addr_cld <= '0'
                     & std_ulogic_vector(RowU) & '0'
                     & std_ulogic_vector(Col);
                  RdWrEn_cld <= '1';
               WHEN acq_3 => 
                  RdWrEn_cld <= '0';
                  S5WE_cld(0) <= '1';
               WHEN acq_4 => 
                  S5WE_cld(0) <= '0';
                  Addr_cld <= '0'
                    & std_ulogic_vector(RowU)
                    & '1'
                    & std_ulogic_vector(Col);
                  RdWrEn_cld <= '1';
               WHEN acq_5 => 
                  RdWrEn_cld <= '0';
                  S5WE_cld(1) <= '1';
               WHEN acq_6 => 
                  S5WE_cld(1) <= '0';
                  Col <= Col+1;
               WHEN acq_7 => 
                  IF (Col = 0) THEN 
                     RowU <= RowN;
                     RdyOut_cld <= '1';
                  END IF;
               WHEN OTHERS =>
                  NULL;
            END CASE;
         END IF;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      Col,
      Conv,
      RdyIn,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN acq_init => 
            IF (Conv = '1') THEN 
               next_state <= acq_idle;
            ELSE
               next_state <= acq_init;
            END IF;
         WHEN acq_idle => 
            IF (Conv = '0') THEN 
               next_state <= acq_start;
            ELSE
               next_state <= acq_idle;
            END IF;
         WHEN acq_start => 
            IF (RdyIn = '0') THEN 
               next_state <= acq_1;
            ELSE
               next_state <= acq_start;
            END IF;
         WHEN acq_1 => 
            IF (RdyIn = '1') THEN 
               next_state <= acq_2;
            ELSE
               next_state <= acq_1;
            END IF;
         WHEN acq_2 => 
            next_state <= acq_3;
         WHEN acq_3 => 
            next_state <= acq_4;
         WHEN acq_4 => 
            next_state <= acq_5;
         WHEN acq_5 => 
            next_state <= acq_6;
         WHEN acq_6 => 
            next_state <= acq_7;
         WHEN acq_7 => 
            IF (Col = 0) THEN 
               next_state <= acq_end;
            ELSIF (Col = 7) THEN 
               next_state <= acq_1a;
            ELSE
               next_state <= acq_1;
            END IF;
         WHEN acq_1a => 
            IF (RdyIn = '1') THEN 
               next_state <= acq_2;
            ELSE
               next_state <= acq_1a;
            END IF;
         WHEN acq_end => 
            IF (Conv = '1') THEN 
               next_state <= acq_idle;
            ELSE
               next_state <= acq_end;
            END IF;
         WHEN OTHERS =>
            next_state <= acq_init;
      END CASE;
   END PROCESS nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   Addr <= Addr_cld;
   NxtRow <= NxtRow_cld;
   RdWrEn <= RdWrEn_cld;
   RdyOut <= RdyOut_cld;
   S5WE <= S5WE_cld;
   Start <= Start_cld;
END fsm;
