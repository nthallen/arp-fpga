-- VHDL Entity idx_fpga_lib.ana_acquire.symbol
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 13:01:29 01/20/2011
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY ana_acquire IS
   PORT( 
      CLK       : IN     std_ulogic;
      CurMuxCfg : IN     std_logic_vector (3 DOWNTO 0);
      NewMuxCfg : IN     std_logic_vector (3 DOWNTO 0);
      RST       : IN     std_ulogic;
      RdyIn     : IN     std_ulogic;
      SDI       : IN     std_ulogic_vector (1 DOWNTO 0);
      CS5       : OUT    std_ulogic;
      Col_Addr  : OUT    std_logic_vector (3 DOWNTO 0);
      Conv      : OUT    std_ulogic;
      NxtRow    : OUT    std_ulogic_vector (5 DOWNTO 0);
      RAM_BUSY  : OUT    std_ulogic;
      RD_Addr   : OUT    std_logic_vector (7 DOWNTO 0);
      RdEn      : OUT    std_ulogic;
      RdyOut    : OUT    std_ulogic;
      S5WE      : OUT    std_ulogic_vector (1 DOWNTO 0);
      Start     : OUT    std_ulogic;
      WR_Addr   : OUT    std_logic_vector (7 DOWNTO 0);
      WrEn      : OUT    std_ulogic
   );

-- Declarations

END ana_acquire ;

--
-- VHDL Architecture idx_fpga_lib.ana_acquire.fsm
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 13:01:29 01/20/2011
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
 
ARCHITECTURE fsm OF ana_acquire IS

   -- Architecture Declarations
   function mkaddr(
     row : in std_logic_vector(5 DOWNTO 0);
     bank : in std_logic_vector(0 DOWNTO 0);
     col : in std_logic_vector(2 DOWNTO 0) 
   ) return std_logic_vector is
   begin
     return '0' & row(2 DOWNTO 0) &
       bank & col;
   end mkaddr;
   
   function muxaddr(
     cfg : in std_logic_vector(3 DOWNTO 0);
     bank : in std_logic_vector(0 DOWNTO 0);
     row : in std_logic_vector(5 DOWNTO 0)
   ) return std_logic_vector is
   begin
     return std_logic_vector( cfg & bank &
         row(5 DOWNTO 3));
   end muxaddr;
   SIGNAL Col : std_logic_vector(2 DOWNTO 0);  
   SIGNAL RowN : std_logic_vector(5 DOWNTO 0);  
   SIGNAL RowU : std_logic_vector(5 DOWNTO 0);  

   TYPE STATE_TYPE IS (
      acq_init,
      acq_idle,
      acq_start,
      acq_1,
      acq_2,
      acq_14,
      acq_1a,
      acq_end,
      acq_conv,
      acq_6,
      acq_3,
      acq_5,
      acq_4,
      acq_7,
      acq_8,
      acq_9,
      acq_10,
      acq_11,
      acq_12,
      acq_13
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

   -- Declare any pre-registered internal signals
   SIGNAL CS5_cld : std_ulogic ;
   SIGNAL Col_Addr_cld : std_logic_vector (3 DOWNTO 0);
   SIGNAL Conv_cld : std_ulogic ;
   SIGNAL NxtRow_cld : std_ulogic_vector (5 DOWNTO 0);
   SIGNAL RAM_BUSY_cld : std_ulogic ;
   SIGNAL RD_Addr_cld : std_logic_vector (7 DOWNTO 0);
   SIGNAL RdEn_cld : std_ulogic ;
   SIGNAL RdyOut_cld : std_ulogic ;
   SIGNAL S5WE_cld : std_ulogic_vector (1 DOWNTO 0);
   SIGNAL Start_cld : std_ulogic ;
   SIGNAL WR_Addr_cld : std_logic_vector (7 DOWNTO 0);
   SIGNAL WrEn_cld : std_ulogic ;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      CLK
   )
   -----------------------------------------------------------------
   BEGIN
      IF (CLK'EVENT AND CLK = '1') THEN
         IF (RST = '1') THEN
            current_state <= acq_init;
            -- Default Reset Values
            CS5_cld <= '1';
            Col_Addr_cld <= (others => '0');
            Conv_cld <= '0';
            NxtRow_cld <= (others => '0');
            RAM_BUSY_cld <= '0';
            RD_Addr_cld <= (others => '0');
            RdEn_cld <= '0';
            RdyOut_cld <= '1';
            S5WE_cld <= (others => '0');
            Start_cld <= '0';
            WR_Addr_cld <= (others => '0');
            WrEn_cld <= '0';
            Col <= (others => '0');
            RowN <= "000001";
            RowU <= (others => '0');
         ELSE
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
               WHEN acq_init => 
                  Conv_cld <= '0';
               WHEN acq_idle => 
                  IF (SDI = "00") THEN 
                     Conv_cld <= '1' ;
                  END IF;
               WHEN acq_start => 
                  IF (RdyIn = '0') THEN 
                     Start_cld <= '0';
                     NxtRow_cld <=
                      std_ulogic_vector(RowN);
                  END IF;
               WHEN acq_1 => 
                  IF (RdyIn = '1') THEN 
                     Start_cld <= '1';
                     RAM_BUSY_cld <= '1' ;
                  END IF;
               WHEN acq_2 => 
                  Start_cld <= '0';
                  Col_Addr_cld <= '0' & Col;
               WHEN acq_14 => 
                  IF (Col = 0) THEN 
                     RowU <= RowN;
                     RdyOut_cld <= '1';
                     CS5_cld <= '1';
                  END IF;
               WHEN acq_1a => 
                  IF (RdyIn = '1') THEN 
                     RAM_BUSY_cld <= '1' ;
                  END IF;
               WHEN acq_end => 
                  Conv_cld <= '0';
               WHEN acq_conv => 
                  IF (RdyIn = '1' AND SDI = "11") THEN 
                     Start_cld <= '1' ;
                     CS5_cld <= '0';
                     RdyOut_cld <= '0';
                     RowN <= RowU+1;
                  END IF;
               WHEN acq_6 => 
                  WrEn_cld <= '0';
                  RdEn_cld <= '0';
                  Col_Addr_cld <= '1' & Col;
               WHEN acq_5 => 
                  RD_Addr_cld <=
                     mkaddr(RowU,"0",Col);
                  WrEn_cld <= '1';
                  RdEn_cld <= '1';
                  IF (CurMuxCfg(3) = '0') THEN 
                  ELSIF (CurMuxCfg(3) /='0') THEN 
                     WR_Addr_cld <=
                       muxaddr(CurMuxCfg,"0",RowU);
                  END IF;
               WHEN acq_4 => 
                  WR_Addr_cld <=
                   mkaddr(RowU,"0",Col);
               WHEN acq_7 => 
                  IF (NewMuxCfg(3) = '1') THEN 
                     RD_Addr_cld <=
                       muxaddr(NewMuxCfg,"0",RowN);
                     RdEn_cld <= '1';
                  ELSIF (NewMuxCfg(3) /= '1') THEN 
                     S5WE_cld(0) <= '1';
                     WR_Addr_cld <=
                       mkaddr(RowU,"1",Col);
                  END IF;
               WHEN acq_8 => 
                  S5WE_cld(0) <= '1';
                  RdEn_cld <= '0';
                  WR_Addr_cld <=
                    mkaddr(RowU,"1",Col);
               WHEN acq_9 => 
                  S5WE_cld(0) <= '0';
                  WrEn_cld <= '1';
                  RdEn_cld <= '1';
                  RD_Addr_cld <=
                    mkaddr(RowU,"1",Col);
                  IF (CurMuxCfg(3) = '0') THEN 
                  ELSIF (CurMuxCfg(3) /= '0') THEN 
                     WR_Addr_cld <=
                       muxaddr(CurMuxCfg,"1",RowU);
                  END IF;
               WHEN acq_10 => 
                  WrEn_cld <= '0';
                  RdEn_cld <= '0';
               WHEN acq_11 => 
                  IF (NewMuxCfg(3) = '1') THEN 
                     RD_Addr_cld <=
                       muxaddr(NewMuxCfg,"1",RowN);
                     RdEn_cld <= '1';
                  ELSIF (NewMuxCfg(3) /= '1') THEN 
                     S5WE_cld(1) <= '1';
                     RAM_BUSY_cld <= '0';
                  END IF;
               WHEN acq_12 => 
                  S5WE_cld(1) <= '1';
                  RdEn_cld <= '0';
                  RAM_BUSY_cld <= '0';
               WHEN acq_13 => 
                  S5WE_cld(1) <= '0';
                  Col <= Col+1;
               WHEN OTHERS =>
                  NULL;
            END CASE;
         END IF;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      Col,
      CurMuxCfg,
      NewMuxCfg,
      RdyIn,
      SDI,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN acq_init => 
            next_state <= acq_idle;
         WHEN acq_idle => 
            IF (SDI = "00") THEN 
               next_state <= acq_conv;
            ELSE
               next_state <= acq_idle;
            END IF;
         WHEN acq_start => 
            IF (RdyIn = '0') THEN 
               next_state <= acq_1;
            ELSE
               next_state <= acq_start;
            END IF;
         WHEN acq_1 => 
            IF (RdyIn = '1') THEN 
               next_state <= acq_2;
            ELSE
               next_state <= acq_1;
            END IF;
         WHEN acq_2 => 
            next_state <= acq_3;
         WHEN acq_14 => 
            IF (Col = 0) THEN 
               next_state <= acq_end;
            ELSIF (Col = 7) THEN 
               next_state <= acq_1a;
            ELSE
               next_state <= acq_1;
            END IF;
         WHEN acq_1a => 
            IF (RdyIn = '1') THEN 
               next_state <= acq_2;
            ELSE
               next_state <= acq_1a;
            END IF;
         WHEN acq_end => 
            next_state <= acq_idle;
         WHEN acq_conv => 
            IF (RdyIn = '1' AND SDI = "11") THEN 
               next_state <= acq_start;
            ELSE
               next_state <= acq_conv;
            END IF;
         WHEN acq_6 => 
            next_state <= acq_7;
         WHEN acq_3 => 
            next_state <= acq_4;
         WHEN acq_5 => 
            IF (CurMuxCfg(3) = '0') THEN 
               next_state <= acq_6;
            ELSIF (CurMuxCfg(3) /='0') THEN 
               next_state <= acq_6;
            END IF;
         WHEN acq_4 => 
            next_state <= acq_5;
         WHEN acq_7 => 
            IF (NewMuxCfg(3) = '1') THEN 
               next_state <= acq_8;
            ELSIF (NewMuxCfg(3) /= '1') THEN 
               next_state <= acq_9;
            END IF;
         WHEN acq_8 => 
            next_state <= acq_9;
         WHEN acq_9 => 
            IF (CurMuxCfg(3) = '0') THEN 
               next_state <= acq_10;
            ELSIF (CurMuxCfg(3) /= '0') THEN 
               next_state <= acq_10;
            END IF;
         WHEN acq_10 => 
            next_state <= acq_11;
         WHEN acq_11 => 
            IF (NewMuxCfg(3) = '1') THEN 
               next_state <= acq_12;
            ELSIF (NewMuxCfg(3) /= '1') THEN 
               next_state <= acq_13;
            END IF;
         WHEN acq_12 => 
            next_state <= acq_13;
         WHEN acq_13 => 
            next_state <= acq_14;
         WHEN OTHERS =>
            next_state <= acq_init;
      END CASE;
   END PROCESS nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   CS5 <= CS5_cld;
   Col_Addr <= Col_Addr_cld;
   Conv <= Conv_cld;
   NxtRow <= NxtRow_cld;
   RAM_BUSY <= RAM_BUSY_cld;
   RD_Addr <= RD_Addr_cld;
   RdEn <= RdEn_cld;
   RdyOut <= RdyOut_cld;
   S5WE <= S5WE_cld;
   Start <= Start_cld;
   WR_Addr <= WR_Addr_cld;
   WrEn <= WrEn_cld;
END fsm;
