--
-- VHDL Test Bench idx_fpga_lib.bench_DigIO.DigIO_tester
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 13:22:58 09/23/2010
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;


ENTITY bench_DigIO IS
   GENERIC (
      DIGIO_BASE_ADDRESS : std_logic_vector (15 DOWNTO 0) := X"0800";
      DIGIO_N_CONNECTORS : integer range 4 DOWNTO 1       := 2;
      DIGIO_FORCE_DIR : std_ulogic_vector := "100000000000";
      DIGIO_FORCE_DIR_VAL : std_ulogic_vector := "000000000000"
   );
END bench_DigIO;


LIBRARY idx_fpga_lib;


ARCHITECTURE rtl OF bench_DigIO IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL Addr   : std_logic_vector(15 DOWNTO 0);
   SIGNAL WData  : std_logic_vector(15 DOWNTO 0);
   SIGNAL RData  : std_logic_vector(15 DOWNTO 0);
   SIGNAL ExpRd  : std_ulogic;
   SIGNAL ExpWr  : std_ulogic;
   SIGNAL ExpAck : std_ulogic;
   SIGNAL F8M    : std_ulogic;
   SIGNAL rst    : std_ulogic;
   SIGNAL IO     : std_logic_vector( DIGIO_N_CONNECTORS*6*8-1 DOWNTO 0);
   SIGNAL Dir    : std_logic_vector( DIGIO_N_CONNECTORS*6-1 DOWNTO 0);
   SIGNAL Done   : std_ulogic;


   -- Component declarations
   COMPONENT DigIO
      GENERIC (
         DIGIO_BASE_ADDRESS : std_logic_vector (15 DOWNTO 0) := X"0800";
         DIGIO_N_CONNECTORS : integer range 4 DOWNTO 1       := 2;
         DIGIO_FORCE_DIR : std_ulogic_vector := "000000000001";
         DIGIO_FORCE_DIR_VAL : std_ulogic_vector := "000000000001"
      );
      PORT (
         Addr   : IN     std_logic_vector(15 DOWNTO 0);
         WData  : IN     std_logic_vector(15 DOWNTO 0);
         RData  : OUT    std_logic_vector(15 DOWNTO 0);
         ExpRd  : IN     std_ulogic;
         ExpWr  : IN     std_ulogic;
         ExpAck : OUT    std_ulogic;
         F8M    : IN     std_ulogic;
         rst    : IN     std_ulogic;
         IO     : INOUT  std_logic_vector( DIGIO_N_CONNECTORS*6*8-1 DOWNTO 0);
         Dir    : OUT    std_logic_vector( DIGIO_N_CONNECTORS*6-1 DOWNTO 0)
      );
   END COMPONENT;

   -- embedded configurations
   -- pragma synthesis_off
   FOR DUT_DigIO : DigIO USE ENTITY idx_fpga_lib.DigIO;
   -- pragma synthesis_on
   
   function char_string( Ain : in std_logic_vector(3 DOWNTO 0) )
   return string is
   begin
     case Ain is
       when X"0" => return "0";
       when X"1" => return "1";
       when X"2" => return "2";
       when X"3" => return "3";
       when X"4" => return "4";
       when X"5" => return "5";
       when X"6" => return "6";
       when X"7" => return "7";
       when X"8" => return "8";
       when X"9" => return "9";
       when X"A" => return "A";
       when X"B" => return "B";
       when X"C" => return "C";
       when X"D" => return "D";
       when X"E" => return "E";
       when X"F" => return "F";
       when others => return "X";
     end case;
   end char_string;
   
   function word_string( Ain : in std_logic_vector(15 DOWNTO 0) )
   return string is
   begin
     return
       char_string(Ain(15 downto 12)) &
       char_string(Ain(11 downto 8)) &
       char_string(Ain(7 downto 4)) &
       char_string(Ain(3 downto 0));
   end word_string;

BEGIN

  DUT_DigIO : DigIO
    GENERIC MAP (
       DIGIO_BASE_ADDRESS => DIGIO_BASE_ADDRESS,
       DIGIO_N_CONNECTORS => DIGIO_N_CONNECTORS,
       DIGIO_FORCE_DIR => DIGIO_FORCE_DIR,
       DIGIO_FORCE_DIR_VAL => DIGIO_FORCE_DIR_VAL
    )
    PORT MAP (
       Addr   => Addr,
       WData  => WData,
       RData  => RData,
       ExpRd  => ExpRd,
       ExpWr  => ExpWr,
       ExpAck => ExpAck,
       F8M    => F8M,
       rst    => rst,
       IO     => IO,
       Dir    => Dir
    );

    clock : Process
    Begin
      -- pragma synthesis_off
      wait for 40 ns;
      while done = '0' loop
        F8M <= '0';
        wait for 62.5 ns;
        F8M <= '1';
        wait for 62.5 ns;
      end loop;
      wait;
      -- pragma synthesis_on
    End Process;
    
    test_proc : Process
      variable bitmask : std_logic_vector ( 15 DOWNTO 0);
      variable gbitnum : integer;
      variable portaddr : std_logic_vector ( 15 DOWNTO 0);
      variable ok : integer;
      procedure sbwr( Addr_In : IN std_logic_vector (15 downto 0);
                      Data_In : IN std_logic_vector (15 downto 0) ) is
      begin
        -- pragma synthesis_off
        wait until F8M'Event AND F8M = '1';
        Addr <= Addr_In;
        WData <= Data_in;
        ExpWr <= '1';
        wait for 1 us;
        assert ExpAck = '1' report "No acknowledge on write" severity error;
        ExpWr <= '0';
        wait for 250 ns;
        -- pragma synthesis_on
        return;
      end procedure sbwr;
      
      procedure sbrd_check( addr_in : std_logic_vector (15 DOWNTO 0);
          expected : std_logic_vector(15 DOWNTO 0) ) is
      begin
        -- pragma synthesis_off
        wait until F8M'Event AND F8M = '1';
        Addr <= addr_in;
        ExpRd <= '1';
        wait for 1 us;
        assert ExpAck = '1' report "No Acknowledge on read" severity error;
        assert RData = expected
         report "Input " & word_string(addr_in) & " Incorrect: "
                & word_string(RData) & " expected " & word_string(expected)
         severity error;
        ExpRd <= '0';
        wait for 40 ns;
        -- pragma synthesis_on
      end procedure sbrd_check;
      
      procedure check_input( conn_in : integer; portno_in : integer;
          bitmask : std_logic_vector (15 DOWNTO 0) ) is
        variable portaddr : std_logic_vector(15 DOWNTO 0);
      begin
        for conn in 0 to 1 loop
          for portno in 0 to 2 loop
            portaddr := X"0800";
            portaddr := CONV_STD_LOGIC_VECTOR(unsigned(portaddr) + conn*32 + portno*2, 16);
            if conn = conn_in AND portno = portno_in then
              sbrd_check( portaddr, bitmask );
            else
              sbrd_check( portaddr, X"0000" );
            end if;
          end loop;
        end loop;
      end procedure check_input;
    Begin
      done <= '0';
      ExpRd <= '0';
      ExpWr <= '0';
      rst <= '0';
      IO <= (others => 'Z');
      -- pragma synthesis_off
      rst <= '1';
      wait until F8M'Event AND F8M = '1';
      rst <= '0';
      -- initialize all ports to output
      sbwr(X"0806", X"0000");
      sbwr(X"0826", X"0000");
      sbrd_check(X"0806", X"0000");
      sbrd_check(X"0826", X"0000");
      for conn in 0 to 1 loop
        for portno in 0 to 2 loop
          if (DIGIO_FORCE_DIR(conn*6+portno) = '1' AND
              DIGIO_FORCE_DIR_VAL(conn*6+portno) = '1') OR
             (DIGIO_FORCE_DIR(conn*6+3+portno) = '1' AND
              DIGIO_FORCE_DIR_VAL(conn*6+3+portno) = '1') then
            report "Skipping port on output test due to forcing";
          else
            for byteno in 0 to 1 loop
              portaddr := X"0800";
              portaddr := CONV_STD_LOGIC_VECTOR(unsigned(portaddr) + conn*32 + portno*2, 16);
              for bitno in 0 to 7 loop
                gbitnum := conn*48+byteno*8+portno*16+bitno;
                bitmask := X"0000";
                bitmask(byteno*8+bitno) := '1';
                sbwr(portaddr, bitmask);
                ok := 1;
                for portno2 in 0 TO DIGIO_N_CONNECTORS*6-1 loop
                  if DIGIO_FORCE_DIR(portno2) = '0' OR
                     DIGIO_FORCE_DIR_VAL(portno2) = '0' then
                    for i in 0 TO 7 loop
                      if i+portno2*8 = gbitnum then
                        if IO(i+portno2*8) /= '1' then
                          ok := 0;
                        end if;
                      elsif IO(i+portno2*8) /= '0' then
                        ok := 0;
                      end if;
                    end loop;
                  end if;
                end loop;
                assert ok = 1 report "Bad bit output" severity error;
              end loop;
              sbwr(portaddr, X"0000");
            end loop;
          end if;
        end loop;
      end loop;
      -- initialize all ports to input
      sbwr(X"0806", X"1313");
      sbwr(X"0826", X"1313");
      sbrd_check(X"0806", X"1303"); -- Would be 1313, but we forced output on that port
      sbrd_check(X"0826", X"1313");
      IO <= (others => '0');
      wait for 40 ns;
      for conn in 0 to 1 loop
        for portno in 0 to 2 loop
          if (DIGIO_FORCE_DIR(conn*6+portno) = '1' AND
              DIGIO_FORCE_DIR_VAL(conn*6+portno) = '0') OR
             (DIGIO_FORCE_DIR(conn*6+3+portno) = '1' AND
              DIGIO_FORCE_DIR_VAL(conn*6+3+portno) = '0') then
            report "Skipping port on input test due to forcing";
          else
            for byteno in 0 to 1 loop
              portaddr := X"0800";
              portaddr := CONV_STD_LOGIC_VECTOR(unsigned(portaddr) + conn*32 + portno*2, 16);
              for bitno in 0 to 7 loop
                gbitnum := conn*48+byteno*8+portno*16+bitno;
                bitmask := X"0000";
                bitmask(byteno*8+bitno) := '1';
                IO(gbitnum) <= '1';
                check_input(conn, portno, bitmask);
                IO(gbitnum) <= '0';
              end loop;
            end loop;
          end if;
        end loop;
      end loop;
      done <= '1';
      wait;
      -- pragma synthesis_on
    End Process;


END rtl;