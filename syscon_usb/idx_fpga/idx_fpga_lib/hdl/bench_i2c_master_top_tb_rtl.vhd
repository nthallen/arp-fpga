--
-- VHDL Test Bench idx_fpga_lib.bench_i2c_master_top.i2c_master_top_tester
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 09:06:31 02/ 3/2011
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;


ENTITY bench_i2c_master_top IS
   GENERIC (
      ARST_LVL : std_logic := '0'
   );
END bench_i2c_master_top;


LIBRARY idx_fpga_lib;


ARCHITECTURE rtl OF bench_i2c_master_top IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL wb_clk_i     : std_logic;
   SIGNAL wb_rst_i     : std_logic                    := '0';
   SIGNAL arst_i       : std_logic                    := not ARST_LVL;
   SIGNAL wb_adr_i     : std_logic_vector(2 downto 0);
   SIGNAL wb_dat_i     : std_logic_vector(7 downto 0);
   SIGNAL wb_dat_o     : std_logic_vector(7 downto 0);
   SIGNAL wb_we_i      : std_logic;
   SIGNAL wb_stb_i     : std_logic;
   SIGNAL wb_cyc_i     : std_logic;
   SIGNAL wb_ack_o     : std_logic;
   SIGNAL wb_inta_o    : std_logic;
   SIGNAL scl_pad_i    : std_logic;
   SIGNAL scl_pad_o    : std_logic;
   SIGNAL scl_padoen_o : std_logic;
   SIGNAL sda_pad_i    : std_logic;
   SIGNAL sda_pad_o    : std_logic;
   SIGNAL sda_padoen_o : std_logic;
   SIGNAL Read_Result  : std_logic_vector(7 downto 0);
   SIGNAL Done         : std_ulogic;


   -- Component declarations
   COMPONENT i2c_master_top
      GENERIC (
         ARST_LVL : std_logic := '0'
      );
      PORT (
         wb_clk_i     : IN     std_logic;
         wb_rst_i     : IN     std_logic;
         arst_i       : IN     std_logic;
         wb_adr_i     : IN     std_logic_vector(2 downto 0);
         wb_dat_i     : IN     std_logic_vector(7 downto 0);
         wb_dat_o     : OUT    std_logic_vector(7 downto 0);
         wb_we_i      : IN     std_logic;
         wb_stb_i     : IN     std_logic;
         wb_cyc_i     : IN     std_logic;
         wb_ack_o     : OUT    std_logic;
         wb_inta_o    : OUT    std_logic;
         scl_pad_i    : IN     std_logic;
         scl_pad_o    : OUT    std_logic;
         scl_padoen_o : OUT    std_logic;
         sda_pad_i    : IN     std_logic;
         sda_pad_o    : OUT    std_logic;
         sda_padoen_o : OUT    std_logic
      );
   END COMPONENT;
   COMPONENT mock_sht21
      PORT (
         scl_pad_i    : OUT    std_logic;
         scl_pad_o    : IN     std_logic;
         scl_padoen_o : IN     std_logic;
         sda_pad_i    : OUT    std_logic;
         sda_pad_o    : IN     std_logic;
         sda_padoen_o : IN     std_logic;
         CLK          : IN    std_ulogic;
         rst          : IN    std_ulogic
      );
   END COMPONENT;

   -- embedded configurations
   -- pragma synthesis_off
   FOR I_i2c_master_top : i2c_master_top USE ENTITY idx_fpga_lib.i2c_master_top;
   FOR ALL : mock_sht21 USE ENTITY idx_fpga_lib.mock_sht21;
   -- pragma synthesis_on

BEGIN

   I_i2c_master_top : i2c_master_top
      GENERIC MAP (
         ARST_LVL => ARST_LVL
      )
      PORT MAP (
         wb_clk_i     => wb_clk_i,
         wb_rst_i     => wb_rst_i,
         arst_i       => arst_i,
         wb_adr_i     => wb_adr_i,
         wb_dat_i     => wb_dat_i,
         wb_dat_o     => wb_dat_o,
         wb_we_i      => wb_we_i,
         wb_stb_i     => wb_stb_i,
         wb_cyc_i     => wb_cyc_i,
         wb_ack_o     => wb_ack_o,
         wb_inta_o    => wb_inta_o,
         scl_pad_i    => scl_pad_i,
         scl_pad_o    => scl_pad_o,
         scl_padoen_o => scl_padoen_o,
         sda_pad_i    => sda_pad_i,
         sda_pad_o    => sda_pad_o,
         sda_padoen_o => sda_padoen_o
      );

   sht21 : mock_sht21
      PORT MAP (
         scl_pad_i    => scl_pad_i,
         scl_pad_o    => scl_pad_o,
         scl_padoen_o => scl_padoen_o,
         sda_pad_i    => sda_pad_i,
         sda_pad_o    => sda_pad_o,
         sda_padoen_o => sda_padoen_o,
         CLK          => wb_clk_i,
         rst          => arst_i
      );

    -- 25 MHz (40ns period)
    clock : Process
    Begin
      wb_clk_i <= '0';
      -- pragma synthesis_off
      wait for 40 ns;
      while Done = '0' loop
        wb_clk_i <= '0';
        wait for 20 ns;
        wb_clk_i <= '1';
        wait for 20 ns;
      end loop;
      wait;
      -- pragma synthesis_on
    End Process;
    
    test_proc : Process
      Procedure wb_wr(Addr : std_logic_vector(2 downto 0);
                      Data : std_logic_vector(7 downto 0) ) Is
      Begin
        wb_adr_i <= Addr;
        wb_dat_i <= Data;
        wb_we_i <= '1';
        -- pragma synthesis_off
        wb_cyc_i <= '1';
        wb_stb_i <= '1';
        wait until wb_clk_i'Event AND wb_clk_i = '1';
        wait until wb_clk_i'Event AND wb_clk_i = '1';
        assert wb_ack_o = '1'
          report "wb_ack_o not asserted"
          severity error;
        wb_cyc_i <= '0';
        wb_stb_i <= '0';
        wait until wb_clk_i'Event AND wb_clk_i = '1';
        -- pragma synthesis_on
        return;
      End Procedure;

      Procedure wb_rd(Addr : std_logic_vector(2 downto 0)) Is
      Begin
        wb_adr_i <= Addr;
        wb_we_i <= '0';
        -- pragma synthesis_off
        wb_cyc_i <= '1';
        wb_stb_i <= '1';
        wait until wb_clk_i'Event AND wb_clk_i = '1';
        wait until wb_clk_i'Event AND wb_clk_i = '1';
        assert wb_ack_o = '1'
          report "wb_ack_o not asserted during read"
          severity error;
        Read_Result <= wb_dat_o;
        wb_cyc_i <= '0';
        wb_stb_i <= '0';
        wait until wb_clk_i'Event AND wb_clk_i = '1';
        -- pragma synthesis_on
        return;
      End Procedure;
      
      Procedure i2c_wr( Addr : std_logic_vector(6 DOWNTO 0);
                       Data : std_logic_vector(7 DOWNTO 0);
                       Stop : std_ulogic ) Is
      Begin
        wb_wr( "011", Addr & '0' ); -- TXR
        wb_wr( "100", X"91" ); -- CR STA + WR + IACK
        -- pragma synthesis_off
        wait until wb_inta_o = '0';
        wait until wb_inta_o = '1';
        wb_rd( "100" ); -- SR
        assert Read_Result(7) = '0'
          report "SR read shows NACK from SHT21"
          severity error;
        wb_wr( "011", Data );
        if Stop = '1' then
          wb_wr( "100", X"D1" ); -- CR STA + STO + WR + IACK
        else
          wb_wr( "100", X"91" ); -- CR STA + WR + IACK
        end if;
        wait until wb_inta_o = '0';
        wait until wb_inta_o = '1';
        -- wait for it, check that ACK was received
        wb_rd( "100" ); -- SR
        assert Read_Result(7) = '0'
          report "SR read shows NACK from SHT21"
          severity error;
        -- pragma synthesis_on
        return;
      End Procedure;
      
      Procedure i2c_rd3( Addr : std_logic_vector(6 DOWNTO 0) ) Is
      Begin
        wb_wr( "011", Addr & '1' ); -- TXR
        wb_wr( "100", X"91" ); -- CR STA + WR + IACK
        -- pragma synthesis_off
        wait until wb_inta_o = '0';
        wait until wb_inta_o = '1';
        wb_rd( "100" ); -- SR
        assert Read_Result(7) = '0'
          report "SR read shows NACK from SHT21"
          severity error;
        wb_wr( "100", X"21" ); -- CR RD + [ACK] + IACK
        wait until wb_inta_o = '0';
        wait until wb_inta_o = '1';
        wb_wr( "100", X"21" ); -- CR RD + [ACK] + IACK
        wait until wb_inta_o = '0';
        wait until wb_inta_o = '1';
        wb_wr( "100", X"69" ); -- CR STO + RD + NACK + IACK
        wait until wb_inta_o = '0';
        wait until wb_inta_o = '1';
        -- pragma synthesis_on
        return;
      End Procedure;
                          
    Begin
      arst_i <= '0';
      wb_rst_i <= '0';
      Done <= '0';
      wb_stb_i <= '0';
      wb_we_i <= '1';
      wb_cyc_i <= '0';
      -- pragma synthesis_off
      wait for 1 us;
      arst_i <= '1';
      wait for 1 us;
      wait until wb_clk_i'Event AND wb_clk_i = '1';
      wb_wr( "000", X"2D" ); -- Set prescale register (try higher value...)
      wb_wr( "001", X"00" );
      wb_wr( "010", X"C0" ); -- Enable core and interrupt
      i2c_wr( "1000000", X"FE", '1' );
      i2c_wr( "1000000", "11100011", '0' );
      i2c_rd3( "1000000" );
      
      Done <= '1';
      wait;
      -- pragma synthesis_on
    End Process;


END rtl;