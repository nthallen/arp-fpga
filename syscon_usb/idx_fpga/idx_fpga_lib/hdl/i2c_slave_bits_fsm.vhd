-- VHDL Entity idx_fpga_lib.i2c_slave_bits.symbol
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 15:29:06 03/ 4/2011
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY i2c_slave_bits IS
   GENERIC( 
      I2C_ADDR : std_logic_vector(6 downto 0) := "1000000"
   );
   PORT( 
      clk   : IN     std_ulogic;
      err   : IN     std_ulogic;
      scl   : IN     std_logic;
      start : IN     std_ulogic;
      stop  : IN     std_ulogic;
      sda   : INOUT  std_logic
   );

-- Declarations

END i2c_slave_bits ;

--
-- VHDL Architecture idx_fpga_lib.i2c_slave_bits.fsm
--
-- Created:
--          by - nort.UNKNOWN (NORT-NBX200T)
--          at - 15:29:06 03/ 4/2011
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2009.2 (Build 10)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
 
ARCHITECTURE fsm OF i2c_slave_bits IS

   -- Architecture Declarations
   SIGNAL addd : std_ulogic;  
   SIGNAL nb : unsigned(3 DOWNTO 0);  
   SIGNAL rval : unsigned(7 DOWNTO 0);  
   SIGNAL sclq : std_ulogic;  
   SIGNAL sdaq : std_ulogic;  
   SIGNAL sr : std_logic_vector(7 DOWNTO 0);  

   TYPE STATE_TYPE IS (
      i2cs_stop,
      i2cs_addr0,
      i2cs_addr1,
      i2cs_addr2,
      i2cs_addr3,
      i2cs_w,
      i2cs_w1,
      i2cs_w2,
      i2cs_w3,
      i2cs_r,
      i2cs_r1,
      i2cs_r2,
      i2cs_r3,
      i2cs_r4,
      i2cs_r5,
      i2cs_addr4,
      i2cs_addr5
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      stop
   )
   -----------------------------------------------------------------
   BEGIN
      IF (stop = '1') THEN
         current_state <= i2cs_stop;
         -- Default Reset Values
         addd <= '0';
         nb <= (others => '0');
         rval <= (others => '0');
         sr <= (others => '0');
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;

         -- Combined Actions
         CASE current_state IS
            WHEN i2cs_stop => 
               IF (start = '1') THEN 
                  nb <= "0000";
                  addd <= '0';
               END IF;
            WHEN i2cs_addr0 => 
               IF (sclq = '1') THEN 
                  sr(7 downto 1) <= sr(6 downto 0);
                  sr(0) <= sdaq;
                  nb <= nb+1;
               END IF;
            WHEN i2cs_addr2 => 
               addd <= '1';
            WHEN i2cs_addr3 => 
               IF (sclq = '0' and
                   (addd = '0' or sr(0) ='0')) THEN 
                  nb <= "0000";
               END IF;
            WHEN i2cs_w => 
               IF (sclq = '1') THEN 
                  sr(7 downto 1) <=
                     sr(6 downto 0);
                  sr(0) <= sdaq;
                  nb <= nb+1;
               END IF;
            WHEN i2cs_w2 => 
               IF (sclq = '1') THEN 
               ELSIF (start = '1') THEN 
                  nb <= "0000";
                  addd <= '0';
               END IF;
            WHEN i2cs_w3 => 
               IF (sclq = '0') THEN 
                  nb <= "0000";
               END IF;
            WHEN i2cs_r => 
               sr <= CONV_STD_LOGIC_VECTOR(rval,8);
               rval <= rval+1;
               nb <= "0000";
            WHEN i2cs_r1 => 
               IF (sclq = '1') THEN 
                  nb <= nb+1;
               END IF;
            WHEN i2cs_r2 => 
               IF (sclq = '0' and
                     nb /= conv_unsigned(8,4)) THEN 
                  sr(7 downto 1) <=
                    sr(6 downto 0);
               END IF;
            WHEN i2cs_r5 => 
               IF (start = '1') THEN 
                  nb <= "0000";
                  addd <= '0';
               END IF;
            WHEN OTHERS =>
               NULL;
         END CASE;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      addd,
      current_state,
      nb,
      sclq,
      sdaq,
      sr,
      start
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN i2cs_stop => 
            IF (start = '1') THEN 
               next_state <= i2cs_addr0;
            ELSE
               next_state <= i2cs_stop;
            END IF;
         WHEN i2cs_addr0 => 
            IF (sclq = '1') THEN 
               next_state <= i2cs_addr1;
            ELSE
               next_state <= i2cs_addr0;
            END IF;
         WHEN i2cs_addr1 => 
            IF (sclq = '0' and nb /= conv_unsigned(8,4)) THEN 
               next_state <= i2cs_addr0;
            ELSIF (sclq = '0' and
                   nb = conv_unsigned(8,4) and
                   sr(7 downto 1) = I2C_ADDR) THEN 
               next_state <= i2cs_addr2;
            ELSIF (sclq = '0' and nb = 8 and
                   sr(7 downto 1) /= I2C_ADDR) THEN 
               next_state <= i2cs_addr4;
            ELSE
               next_state <= i2cs_addr1;
            END IF;
         WHEN i2cs_addr2 => 
            IF (sclq = '1') THEN 
               next_state <= i2cs_addr3;
            ELSE
               next_state <= i2cs_addr2;
            END IF;
         WHEN i2cs_addr3 => 
            IF (sclq = '0' and
                (addd = '0' or sr(0) ='0')) THEN 
               next_state <= i2cs_w;
            ELSIF (sclq = '0' and
                   addd = '1' and
                   sr(0) ='1') THEN 
               next_state <= i2cs_r;
            ELSE
               next_state <= i2cs_addr3;
            END IF;
         WHEN i2cs_w => 
            IF (sclq = '1') THEN 
               next_state <= i2cs_w1;
            ELSE
               next_state <= i2cs_w;
            END IF;
         WHEN i2cs_w1 => 
            IF (sclq = '0' and nb /= conv_unsigned(8,4)) THEN 
               next_state <= i2cs_w;
            ELSIF (sclq = '0' and
                   nb = conv_unsigned(8,4) and
                   addd = '1') THEN 
               next_state <= i2cs_w2;
            ELSIF (sclq = '0' and
                   nb = conv_unsigned(8,4) and
                   addd = '0') THEN 
               next_state <= i2cs_w2;
            ELSE
               next_state <= i2cs_w1;
            END IF;
         WHEN i2cs_w2 => 
            IF (sclq = '1') THEN 
               next_state <= i2cs_w3;
            ELSIF (start = '1') THEN 
               next_state <= i2cs_addr0;
            ELSE
               next_state <= i2cs_w2;
            END IF;
         WHEN i2cs_w3 => 
            IF (sclq = '0') THEN 
               next_state <= i2cs_w;
            ELSE
               next_state <= i2cs_w3;
            END IF;
         WHEN i2cs_r => 
            next_state <= i2cs_r1;
         WHEN i2cs_r1 => 
            IF (sclq = '1') THEN 
               next_state <= i2cs_r2;
            ELSE
               next_state <= i2cs_r1;
            END IF;
         WHEN i2cs_r2 => 
            IF (sclq = '0' and
                  nb /= conv_unsigned(8,4)) THEN 
               next_state <= i2cs_r1;
            ELSIF (sclq = '0' and
                   nb = conv_unsigned(8,4)) THEN 
               next_state <= i2cs_r3;
            ELSE
               next_state <= i2cs_r2;
            END IF;
         WHEN i2cs_r3 => 
            IF (sclq = '1') THEN 
               next_state <= i2cs_r4;
            ELSE
               next_state <= i2cs_r3;
            END IF;
         WHEN i2cs_r4 => 
            IF (sclq = '0' and
                  sdaq = '0') THEN 
               next_state <= i2cs_r;
            ELSIF (sclq = '0' and
                     sdaq = '1') THEN 
               next_state <= i2cs_r5;
            ELSE
               next_state <= i2cs_r4;
            END IF;
         WHEN i2cs_r5 => 
            IF (start = '1') THEN 
               next_state <= i2cs_addr0;
            ELSE
               next_state <= i2cs_r5;
            END IF;
         WHEN i2cs_addr4 => 
            IF (sclq = '1') THEN 
               next_state <= i2cs_addr5;
            ELSE
               next_state <= i2cs_addr4;
            END IF;
         WHEN i2cs_addr5 => 
            IF (sclq = '0') THEN 
               next_state <= i2cs_w;
            ELSE
               next_state <= i2cs_addr5;
            END IF;
         WHEN OTHERS =>
            next_state <= i2cs_stop;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state,
      scl,
      sda,
      sr
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      sda <= 'Z';
      -- Default Assignment To Internals
      sclq <= To_X01(scl);
      sdaq <= To_X01(sda);

      -- Combined Actions
      CASE current_state IS
         WHEN i2cs_addr2 => 
            sda <= '0';
         WHEN i2cs_addr3 => 
            sda <= '0';
         WHEN i2cs_w2 => 
            sda <= '0';
         WHEN i2cs_w3 => 
            sda <= '0';
         WHEN i2cs_r1 => 
            sda <= sr(7);
         WHEN i2cs_r2 => 
            sda <= sr(7);
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
